import { Callable, type array, type Hkt, type Json } from "@ark/util";
import type { BaseNode } from "./node.js";
import type { BaseRoot } from "./roots/root.js";
import type { BaseScope } from "./scope.js";
import { arkKind } from "./shared/utils.js";
export type GenericParamAst<name extends string = string, constraint = unknown> = [name: name, constraint: constraint];
export type GenericParamDef<name extends string = string> = name | readonly [name, unknown];
export declare const parseGeneric: (paramDefs: array<GenericParamDef>, bodyDef: unknown, $: BaseScope) => GenericRoot;
export type genericParamNames<params extends array<GenericParamAst>> = {
    [i in keyof params]: params[i][0];
};
export type genericParamConstraints<params extends array<GenericParamAst>> = {
    [i in keyof params]: params[i][1];
};
export type GenericArgResolutions<params extends array<GenericParamAst> = array<GenericParamAst>> = {
    [i in keyof params as params[i & `${number}`][0]]: BaseRoot;
};
export declare class LazyGenericBody<argResolutions = {}, returns = unknown> extends Callable<(args: argResolutions) => returns> {
}
export interface GenericAst<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = unknown, arg$ = $> {
    [arkKind]: "generic";
    paramsAst: params;
    bodyDef: bodyDef;
    $: $;
    arg$: arg$;
    names: genericParamNames<params>;
    t: this;
}
export declare class GenericRoot<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown> extends Callable<(...args: {
    [i in keyof params]: BaseRoot;
}) => BaseRoot> {
    paramDefs: array<GenericParamDef>;
    bodyDef: bodyDef;
    $: BaseScope;
    arg$: BaseScope;
    readonly [arkKind] = "generic";
    readonly paramsAst: params;
    readonly t: GenericAst<params, bodyDef, {}, {}>;
    constructor(paramDefs: array<GenericParamDef>, bodyDef: bodyDef, $: BaseScope, arg$: BaseScope);
    defIsLazy(): this is GenericRoot<params, LazyGenericBody>;
    bindScope($: BaseScope): this;
    get json(): Json;
    get params(): {
        [i in keyof params]: [params[i][0], BaseRoot];
    };
    get names(): genericParamNames<params>;
    get constraints(): {
        [i in keyof params]: BaseRoot;
    };
    get baseInstantiation(): BaseRoot;
    validateBaseInstantiation(): this;
    get internal(): this;
    get references(): BaseNode[];
}
export type genericParamSchemasToAst<schemas extends readonly GenericParamDef[]> = {
    [i in keyof schemas]: schemas[i] extends GenericParamDef<infer name> ? [
        name,
        unknown
    ] : never;
};
export type genericHktToConstraints<hkt extends abstract new () => Hkt> = InstanceType<hkt>["constraints"];
export type GenericHktSchemaParser = <const paramsDef extends readonly GenericParamDef[]>(...params: paramsDef) => GenericHktSchemaBodyParser<genericParamSchemasToAst<paramsDef>>;
export type GenericHktSchemaBodyParser<params extends array<GenericParamAst>> = <hkt extends Hkt.constructor>(instantiateDef: LazyGenericBody<GenericArgResolutions<params>>, hkt: hkt) => GenericRoot<{
    [i in keyof params]: [params[i][0], genericHktToConstraints<hkt>[i]];
}, InstanceType<hkt>>;
export declare const writeUnsatisfiedParameterConstraintMessage: <name extends string, constraint extends string, arg extends string>(name: name, constraint: constraint, arg: arg) => writeUnsatisfiedParameterConstraintMessage<name, constraint, arg>;
export type writeUnsatisfiedParameterConstraintMessage<name extends string, constraint extends string, arg extends string> = `${name} must be assignable to ${constraint} (was ${arg})`;
