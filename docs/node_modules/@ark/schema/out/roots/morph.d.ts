import { type array, type listable } from "@ark/util";
import type { nodeOfKind, NodeSchema } from "../kinds.js";
import type { NodeCompiler } from "../shared/compile.js";
import type { BaseNormalizedSchema, declareNode } from "../shared/declare.js";
import { type nodeImplementationOf } from "../shared/implement.js";
import type { TraversalContext, TraverseAllows, TraverseApply } from "../shared/traversal.js";
import { BaseRoot, type schemaKindRightOf } from "./root.js";
export declare namespace Morph {
    type ChildKind = schemaKindRightOf<"morph"> | "alias";
    type ChildNode = nodeOfKind<ChildKind>;
    type ChildSchema = NodeSchema<ChildKind>;
    interface Inner {
        readonly in: ChildNode;
        readonly morphs: array<Morph | BaseRoot>;
    }
    interface Schema extends BaseNormalizedSchema {
        readonly in: ChildSchema;
        readonly morphs: listable<Morph | BaseRoot>;
    }
    interface Declaration extends declareNode<{
        kind: "morph";
        schema: Schema;
        normalizedSchema: Schema;
        inner: Inner;
        childKind: ChildKind;
    }> {
    }
    type Node = MorphNode;
}
export type Morph<i = any, o = unknown> = (In: i, ctx: TraversalContext) => o;
export declare class MorphNode extends BaseRoot<Morph.Declaration> {
    serializedMorphs: string[];
    compiledMorphs: string;
    structure: import("../index.js").StructureNode | undefined;
    traverseAllows: TraverseAllows;
    traverseApply: TraverseApply;
    get shortDescription(): string;
    compile(js: NodeCompiler): void;
    get in(): Morph.ChildNode;
    get out(): BaseRoot;
    /** Check if the morphs of r are equal to those of this node */
    hasEqualMorphs(r: MorphNode): boolean;
    lastMorph: BaseRoot<import("./root.js").InternalRootDeclaration> | Morph<any, unknown> | undefined;
    validatedOut: BaseRoot | undefined;
    expression: string;
}
export declare const Morph: {
    implementation: nodeImplementationOf<Morph.Declaration>;
    Node: typeof MorphNode;
};
export declare const writeMorphIntersectionMessage: (lDescription: string, rDescription: string) => string;
