import { Disjoint } from "./disjoint.js";
import { rootKinds } from "./implement.js";
import { isNode } from "./utils.js";
const intersectionCache = {};
export const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, {
    $,
    invert: false,
    pipe: false
});
export const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, {
    $,
    invert: false,
    pipe: true
});
export const intersectNodes = (l, r, ctx) => {
    const operator = ctx.pipe ? "|>" : "&";
    const lrCacheKey = `${l.hash}${operator}${r.hash}`;
    if (intersectionCache[lrCacheKey] !== undefined)
        return intersectionCache[lrCacheKey];
    if (!ctx.pipe) {
        // we can only use this for the commutative & operator
        const rlCacheKey = `${r.hash}${operator}${l.hash}`;
        if (intersectionCache[rlCacheKey] !== undefined) {
            // if the cached result was a Disjoint and the operands originally
            // appeared in the opposite order, we need to invert it to match
            const rlResult = intersectionCache[rlCacheKey];
            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;
            // add the lr result to the cache directly to bypass this check in the future
            intersectionCache[lrCacheKey] = lrResult;
            return lrResult;
        }
    }
    if (l.equals(r))
        return l;
    let result = ctx.pipe && l.hasKindIn(...rootKinds) && r.hasKindIn(...rootKinds) ?
        _pipeNodes(l, r, ctx)
        : _intersectNodes(l, r, ctx);
    if (isNode(result)) {
        // if the result equals one of the operands, preserve its metadata by
        // returning the original reference
        if (l.equals(result))
            result = l;
        else if (r.equals(result))
            result = r;
    }
    intersectionCache[lrCacheKey] = result;
    return result;
};
const _intersectNodes = (l, r, ctx) => {
    const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;
    const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];
    if (implementation === undefined) {
        // should be two ConstraintNodes that have no relation
        // this could also happen if a user directly intersects a Type and a ConstraintNode,
        // but that is not allowed by the external function signature
        return null;
    }
    else if (leftmostKind === l.kind)
        return implementation(l, r, ctx);
    else {
        let result = implementation(r, l, { ...ctx, invert: !ctx.invert });
        if (result instanceof Disjoint)
            result = result.invert();
        return result;
    }
};
const _pipeNodes = (l, r, ctx) => l.includesMorph ?
    ctx.invert ?
        pipeMorphed(r, l, ctx)
        : pipeMorphed(l, r, ctx)
    : r.includesMorph ?
        ctx.invert ?
            pipeMorphed(r, l, ctx)
            : pipeMorphed(l, r, ctx)
        : _intersectNodes(l, r, ctx);
const pipeMorphed = (from, to, ctx) => from.distribute(fromBranch => _pipeMorphed(fromBranch, to, ctx), results => {
    const viableBranches = results.filter(isNode);
    return viableBranches.length === 0 ?
        Disjoint.init("union", from.branches, to.branches)
        : ctx.$.rootNode(viableBranches);
});
const _pipeMorphed = (from, to, ctx) => {
    const fromIsMorph = from.hasKind("morph");
    if (fromIsMorph) {
        const morphs = [...from.morphs];
        if (from.validatedOut) {
            // still piped from context, so allows appending additional morphs
            const outIntersection = intersectNodes(from.validatedOut, to, ctx);
            if (outIntersection instanceof Disjoint)
                return outIntersection;
            morphs[morphs.length - 1] = outIntersection;
        }
        else
            morphs.push(to);
        return ctx.$.node("morph", {
            morphs,
            in: fromIsMorph ? from.in : from
        });
    }
    return to.hasKind("morph") ?
        ctx.$.node("morph", {
            morphs: to.morphs,
            in: _intersectNodes(from, to.in, ctx)
        })
        : ctx.$.node("morph", {
            morphs: [to],
            in: from
        });
};
