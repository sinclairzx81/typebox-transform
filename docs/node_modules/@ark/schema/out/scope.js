var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { ParseError, bound, flatMorph, hasDomain, isArray, printable, throwInternalError, throwParseError } from "@ark/util";
import { resolveConfig } from "./config.js";
import { GenericRoot, LazyGenericBody } from "./generic.js";
import { nodeImplementationsByKind } from "./kinds.js";
import { RootModule, bindModule } from "./module.js";
import { parseNode, registerNodeId, schemaKindOf } from "./parse.js";
import { normalizeAliasSchema } from "./roots/alias.js";
import { CompiledFunction, NodeCompiler } from "./shared/compile.js";
import { $ark } from "./shared/registry.js";
import { arkKind, hasArkKind, isNode } from "./shared/utils.js";
const schemaBranchesOf = (schema) => isArray(schema) ? schema
    : "branches" in schema && isArray(schema.branches) ? schema.branches
        : undefined;
const throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);
export const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;
const scopesById = {};
$ark.ambient ??= {};
let BaseScope = (() => {
    let _instanceExtraInitializers = [];
    let _defineSchema_decorators;
    let _defineRoot_decorators;
    let _generic_decorators;
    let _units_decorators;
    let _rootNode_decorators;
    let _preparseNode_decorators;
    let _node_decorators;
    return class BaseScope {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _defineSchema_decorators = [bound];
            _defineRoot_decorators = [bound];
            _generic_decorators = [bound];
            _units_decorators = [bound];
            _rootNode_decorators = [bound];
            _preparseNode_decorators = [bound];
            _node_decorators = [bound];
            __esDecorate(this, null, _defineSchema_decorators, { kind: "method", name: "defineSchema", static: false, private: false, access: { has: obj => "defineSchema" in obj, get: obj => obj.defineSchema }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _defineRoot_decorators, { kind: "method", name: "defineRoot", static: false, private: false, access: { has: obj => "defineRoot" in obj, get: obj => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _generic_decorators, { kind: "method", name: "generic", static: false, private: false, access: { has: obj => "generic" in obj, get: obj => obj.generic }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _units_decorators, { kind: "method", name: "units", static: false, private: false, access: { has: obj => "units" in obj, get: obj => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _rootNode_decorators, { kind: "method", name: "rootNode", static: false, private: false, access: { has: obj => "rootNode" in obj, get: obj => obj.rootNode }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _preparseNode_decorators, { kind: "method", name: "preparseNode", static: false, private: false, access: { has: obj => "preparseNode" in obj, get: obj => obj.preparseNode }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _node_decorators, { kind: "method", name: "node", static: false, private: false, access: { has: obj => "node" in obj, get: obj => obj.node }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        config = __runInitializers(this, _instanceExtraInitializers);
        resolvedConfig;
        id = `${Object.keys(scopesById).length}$`;
        [arkKind] = "scope";
        referencesById = {};
        references = [];
        resolutions = {};
        json = {};
        exportedNames = [];
        aliases = {};
        resolved = false;
        constructor(
        /** The set of names defined at the root-level of the scope mapped to their
         * corresponding definitions.**/
        def, config) {
            this.config = config ?? {};
            this.resolvedConfig = resolveConfig(config);
            const aliasEntries = Object.entries(def).map(entry => this.preparseAlias(...entry));
            aliasEntries.forEach(([k, v]) => {
                if (k[0] === "#") {
                    const name = k.slice(1);
                    if (name in this.aliases)
                        throwParseError(writeDuplicateAliasError(name));
                    this.aliases[name] = v;
                }
                else {
                    if (k in this.aliases)
                        throwParseError(writeDuplicateAliasError(k));
                    this.aliases[k] = v;
                    this.exportedNames.push(k);
                }
            });
            scopesById[this.id] = this;
        }
        get internal() {
            return this;
        }
        defineSchema(def) {
            return def;
        }
        defineRoot(def) {
            return this.defineSchema(def);
        }
        generic(...params) {
            const $ = this;
            return instantiateDef => new GenericRoot(params, new LazyGenericBody(instantiateDef), $, $);
        }
        units(values, opts) {
            const uniqueValues = [];
            for (const value of values)
                if (!uniqueValues.includes(value))
                    uniqueValues.push(value);
            const branches = uniqueValues.map(unit => this.node("unit", { unit }, opts));
            return this.node("union", branches, {
                ...opts,
                prereduced: true
            });
        }
        lazyResolutions = [];
        lazilyResolve(resolve, syntheticAlias) {
            const node = this.node("alias", {
                alias: syntheticAlias ?? "synthetic",
                resolve
            }, { prereduced: true });
            if (!this.resolved)
                this.lazyResolutions.push(node);
            return node;
        }
        rootNode(def, opts) {
            return this.node(schemaKindOf(def), def, opts);
        }
        preparseNode(kinds, schema, opts) {
            let kind = typeof kinds === "string" ? kinds : schemaKindOf(schema, kinds);
            if (isNode(schema) && schema.kind === kind)
                return schema.bindScope(this);
            if (kind === "alias" && !opts?.prereduced) {
                const resolution = this.resolveRoot(normalizeAliasSchema(schema).alias);
                schema = resolution;
                kind = resolution.kind;
            }
            else if (kind === "union" && hasDomain(schema, "object")) {
                const branches = schemaBranchesOf(schema);
                if (branches?.length === 1) {
                    schema = branches[0];
                    kind = schemaKindOf(schema);
                }
            }
            const impl = nodeImplementationsByKind[kind];
            const normalizedSchema = impl.normalize?.(schema) ?? schema;
            // check again after normalization in case a node is a valid collapsed
            // schema for the kind (e.g. sequence can collapse to element accepting a Node')
            if (isNode(normalizedSchema)) {
                return normalizedSchema.kind === kind ?
                    normalizedSchema.bindScope(this)
                    : throwMismatchedNodeRootError(kind, normalizedSchema.kind);
            }
            const id = registerNodeId(kind, opts.alias);
            return {
                ...opts,
                $: this,
                args: opts.args ?? {},
                kind,
                normalizedSchema,
                id
            };
        }
        node(kinds, nodeSchema, opts = {}) {
            const preparsed = this.preparseNode(kinds, nodeSchema, opts);
            const node = isNode(preparsed) ? preparsed : parseNode(preparsed).bindScope(this);
            if (this.resolved) {
                // this node was not part of the original scope, so compile an anonymous scope
                // including only its references
                if (!this.resolvedConfig.jitless)
                    bindCompiledScope(node.references);
            }
            else {
                // we're still parsing the scope itself, so defer compilation but
                // add the node as a reference
                Object.assign(this.referencesById, node.referencesById);
            }
            return node;
        }
        finalizeRootArgs(opts, resolve) {
            const isResolution = opts.alias && opts.alias in this.aliases;
            // if the definition being parsed is not a scope alias and is not a
            // generic instantiation (i.e. opts don't include args), add this as a resolution.
            if (!isResolution)
                // this.lazilyResolve(resolve) as never
                opts.args ??= { this: $ark.intrinsic.unknown || resolve };
            return opts;
        }
        resolveRoot(name) {
            return (this.maybeResolveRoot(name) ??
                throwParseError(writeUnresolvableMessage(name)));
        }
        maybeResolveRoot(name) {
            const result = this.maybeResolve(name);
            if (hasArkKind(result, "generic"))
                return;
            return result;
        }
        preparseRoot(def) {
            return def;
        }
        preparseAlias(k, v) {
            return [k, v];
        }
        maybeResolve(name) {
            const resolution = this.maybeShallowResolve(name);
            return typeof resolution === "string" ?
                this.node("alias", { alias: resolution }, { prereduced: true })
                : (resolution ?? maybeResolveSubalias(this.aliases, name));
        }
        get ambient() {
            return $ark.ambient;
        }
        maybeShallowResolve(name) {
            const cached = this.resolutions[name];
            if (cached)
                return cached;
            const def = this.aliases[name] ?? this.ambient?.[name];
            if (!def)
                return this.maybeResolveSubalias(name);
            const preparsed = this.preparseRoot(def);
            if (hasArkKind(preparsed, "generic"))
                return (this.resolutions[name] = preparsed.bindScope(this));
            if (hasArkKind(preparsed, "module"))
                return throwParseError(writeMissingSubmoduleAccessMessage(name));
            this.resolutions[name] = name;
            return (this.resolutions[name] = this.parseRoot(preparsed, {
                alias: name
            }).bindScope(this));
        }
        /** If name is a valid reference to a submodule alias, return its resolution  */
        maybeResolveSubalias(name) {
            return maybeResolveSubalias(this.aliases, name);
        }
        import(...names) {
            return new RootModule(flatMorph(this.export(...names), (alias, value) => [
                `#${alias}`,
                value
            ]));
        }
        _exportedResolutions;
        _exports;
        export(...names) {
            if (!this._exports) {
                this._exports = {};
                for (const name of this.exportedNames) {
                    const def = this.aliases[name];
                    if (hasArkKind(def, "module"))
                        this._exports[name] = bindModule(def, this);
                    else {
                        const resolution = this.maybeResolve(name);
                        resolution.references
                            .filter(node => node.hasKind("alias"))
                            .forEach(aliasNode => {
                            Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);
                            resolution.references.forEach(ref => {
                                if (aliasNode.id in ref.referencesById)
                                    Object.assign(ref.referencesById, aliasNode.referencesById);
                            });
                        });
                        this._exports[name] = resolution;
                    }
                }
                this.lazyResolutions.forEach(node => node.resolution);
                if (this.resolvedConfig.ambient === true)
                    // spread all exports to ambient
                    Object.assign($ark.ambient, this._exports);
                else if (typeof this.resolvedConfig.ambient === "string") {
                    // add exports as a subscope with the config value as a name
                    Object.assign($ark.ambient, {
                        [this.resolvedConfig.ambient]: new RootModule({
                            ...this._exports
                        })
                    });
                }
                this._exportedResolutions = resolutionsOfModule(this, this._exports);
                Object.assign(this.json, resolutionsToJson(this._exportedResolutions));
                Object.assign(this.resolutions, this._exportedResolutions);
                this.references = Object.values(this.referencesById);
                if (!this.resolvedConfig.jitless)
                    bindCompiledScope(this.references);
                this.resolved = true;
            }
            const namesToExport = names.length ? names : this.exportedNames;
            return new RootModule(flatMorph(namesToExport, (_, name) => [
                name,
                this._exports[name]
            ]));
        }
        resolve(name) {
            return this.export()[name];
        }
    };
})();
export { BaseScope };
const resolutionsToJson = (resolutions) => flatMorph(resolutions, (k, v) => [
    k,
    hasArkKind(v, "root") || hasArkKind(v, "generic") ? v.json
        : hasArkKind(v, "module") ? resolutionsToJson(v)
            : throwInternalError(`Unexpected resolution ${printable(v)}`)
]);
const maybeResolveSubalias = (base, name) => {
    const dotIndex = name.indexOf(".");
    if (dotIndex === -1)
        return;
    const dotPrefix = name.slice(0, dotIndex);
    const prefixSchema = base[dotPrefix];
    // if the name includes ".", but the prefix is not an alias, it
    // might be something like a decimal literal, so just fall through to return
    if (prefixSchema === undefined)
        return;
    if (!hasArkKind(prefixSchema, "module"))
        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));
    const subalias = name.slice(dotIndex + 1);
    const resolution = prefixSchema[subalias];
    if (resolution === undefined)
        return maybeResolveSubalias(prefixSchema, subalias);
    if (hasArkKind(resolution, "root") || hasArkKind(resolution, "generic"))
        return resolution;
    if (hasArkKind(resolution, "module"))
        return throwParseError(writeMissingSubmoduleAccessMessage(name));
    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);
};
export const schemaScope = (aliases, config) => new SchemaScope(aliases, config);
export class SchemaScope extends BaseScope {
    defineRoot(schema) {
        return schema;
    }
    parseRoot(schema, opts = {}) {
        const node = this.rootNode(schema, this.finalizeRootArgs(opts, () => node));
        return node;
    }
}
export const $root = new SchemaScope({});
export const rootNode = $root.rootNode;
export const node = $root.node;
export const defineSchema = $root.defineSchema;
export const genericNode = $root.generic;
export const parseAsSchema = (def, opts) => {
    try {
        return rootNode(def, opts);
    }
    catch (e) {
        if (e instanceof ParseError)
            return e;
        throw e;
    }
};
const resolutionsOfModule = ($, typeSet) => {
    const result = {};
    for (const k in typeSet) {
        const v = typeSet[k];
        if (hasArkKind(v, "module")) {
            const innerResolutions = resolutionsOfModule($, v);
            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);
            Object.assign(result, prefixedResolutions);
        }
        else if (hasArkKind(v, "root") || hasArkKind(v, "generic"))
            result[k] = v;
        else
            throwInternalError(`Unexpected scope resolution ${printable(v)}`);
    }
    return result;
};
export const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;
export const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;
export const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;
export const bindCompiledScope = (references) => {
    const compiledTraversals = compileScope(references);
    for (const node of references) {
        if (node.jit) {
            // if node has already been bound to another scope or anonymous type, don't rebind it
            continue;
        }
        node.jit = true;
        node.traverseAllows =
            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);
        if (node.isRoot() && !node.allowsRequiresContext) {
            // if the reference doesn't require context, we can assign over
            // it directly to avoid having to initialize it
            node.allows = node.traverseAllows;
        }
        node.traverseApply =
            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);
    }
};
const compileScope = (references) => new CompiledFunction()
    .block("return", js => {
    references.forEach(node => {
        const allowsCompiler = new NodeCompiler("Allows").indent();
        node.compile(allowsCompiler);
        const applyCompiler = new NodeCompiler("Apply").indent();
        node.compile(applyCompiler);
        js.line(`${allowsCompiler.writeMethod(`${node.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node.id}Apply`)},`);
    });
    return js;
})
    .compile()();
