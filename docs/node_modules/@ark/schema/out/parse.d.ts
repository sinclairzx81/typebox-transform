import { type dict } from "@ark/util";
import type { GenericArgResolutions } from "./generic.js";
import { type NormalizedSchema } from "./kinds.js";
import type { BaseNode } from "./node.js";
import type { BaseScope } from "./scope.js";
import type { BaseMeta } from "./shared/declare.js";
import { type NodeKind, type RootKind } from "./shared/implement.js";
export type NodeParseOptions<prereduced extends boolean = boolean> = {
    alias?: string;
    prereduced?: prereduced;
    /** Instead of creating the node, compute the innerHash of the definition and
     * point it to the specified resolution.
     *
     * Useful for defining reductions like number|string|bigint|symbol|object|true|false|null|undefined => unknown
     **/
    reduceTo?: BaseNode;
    args?: GenericArgResolutions;
};
export interface NodeParseContext<kind extends NodeKind = NodeKind> extends NodeParseOptions {
    $: BaseScope;
    args: GenericArgResolutions;
    kind: kind;
    normalizedSchema: NormalizedSchema<kind>;
    id: string;
}
export declare const schemaKindOf: <kind extends RootKind = "alias" | "union" | "morph" | "unit" | "intersection" | "proto" | "domain">(schema: unknown, allowedKinds?: readonly kind[]) => kind;
export declare const writeInvalidSchemaMessage: (schema: unknown) => string;
export declare const registerNodeId: (kind: NodeKind, alias?: string) => string;
export declare const parseNode: <kind extends NodeKind>(ctx: NodeParseContext<kind>) => BaseNode;
export declare const createNode: (id: string, kind: NodeKind, inner: dict, meta: BaseMeta, $: BaseScope) => BaseNode;
export declare const withMeta: (node: BaseNode, meta: ArkEnv.meta) => BaseNode;
