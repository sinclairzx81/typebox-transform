import { ParseError, type Json, type anyOrNever, type array, type conform, type flattenListable, type listable, type noSuggest, type show } from "@ark/util";
import { resolveConfig, type ArkConfig } from "./config.js";
import { GenericRoot, type GenericHktSchemaBodyParser, type GenericParamDef, type genericParamSchemasToAst } from "./generic.js";
import { type NodeSchema, type RootSchema, type nodeOfKind, type reducibleKindOf } from "./kinds.js";
import { RootModule, type InternalModule, type PreparsedNodeResolution, type SchemaModule } from "./module.js";
import type { BaseNode } from "./node.js";
import { type NodeParseContext, type NodeParseOptions } from "./parse.js";
import { type Alias } from "./roots/alias.js";
import type { BaseRoot } from "./roots/root.js";
import type { NodeKind, RootKind } from "./shared/implement.js";
import { arkKind } from "./shared/utils.js";
export type InternalResolutions = Record<string, InternalResolution | undefined>;
export type exportedNameOf<$> = Exclude<keyof $ & string, PrivateDeclaration>;
export type resolvableReferenceIn<$> = {
    [k in keyof $]: k extends string ? k extends PrivateDeclaration<infer alias> ? alias : k extends noSuggest ? never : k : never;
}[keyof $];
export type resolveReference<reference extends resolvableReferenceIn<$>, $> = reference extends keyof $ ? $[reference] : $[`#${reference}` & keyof $];
export type PrivateDeclaration<key extends string = string> = `#${key}`;
export type InternalResolution = BaseRoot | GenericRoot | InternalModule;
export type toInternalScope<$> = BaseScope<{
    [k in keyof $]: $[k] extends {
        [arkKind]: infer kind;
    } ? [
        $[k]
    ] extends [anyOrNever] ? BaseRoot : kind extends "generic" ? GenericRoot : kind extends "module" ? InternalModule : never : BaseRoot;
}>;
type CachedResolution = string | BaseRoot | GenericRoot;
export declare const writeDuplicateAliasError: <alias extends string>(alias: alias) => writeDuplicateAliasError<alias>;
export type writeDuplicateAliasError<alias extends string> = `#${alias} duplicates public alias ${alias}`;
export type AliasDefEntry = [name: string, defValue: unknown];
export interface ArkScopeConfig extends ArkConfig {
    ambient?: boolean | string;
    prereducedAliases?: boolean;
}
export type ResolvedArkScopeConfig = resolveConfig<ArkScopeConfig>;
export declare abstract class BaseScope<$ extends {} = {}> {
    readonly config: ArkScopeConfig;
    readonly resolvedConfig: ResolvedArkScopeConfig;
    readonly id: string;
    readonly [arkKind] = "scope";
    readonly referencesById: {
        [id: string]: BaseNode;
    };
    references: readonly BaseNode[];
    protected readonly resolutions: {
        [alias: string]: CachedResolution | undefined;
    };
    readonly json: Json;
    exportedNames: string[];
    readonly aliases: Record<string, unknown>;
    protected resolved: boolean;
    constructor(
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    def: Record<string, unknown>, config?: ArkScopeConfig);
    get internal(): this;
    defineSchema<def extends RootSchema>(def: def): def;
    defineRoot(def: RootSchema): RootSchema;
    generic<const paramsDef extends readonly GenericParamDef[]>(...params: paramsDef): GenericHktSchemaBodyParser<genericParamSchemasToAst<paramsDef>>;
    units(values: array, opts?: NodeParseOptions): BaseRoot;
    protected lazyResolutions: Alias.Node[];
    lazilyResolve(resolve: () => BaseRoot, syntheticAlias?: string): Alias.Node;
    rootNode(def: RootSchema, opts?: NodeParseOptions): BaseRoot;
    protected preparseNode(kinds: NodeKind | listable<RootKind>, schema: unknown, opts: NodeParseOptions): BaseNode | NodeParseContext;
    node<kinds extends NodeKind | array<RootKind>, prereduced extends boolean = false>(kinds: kinds, nodeSchema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions<prereduced>): nodeOfKind<prereduced extends true ? flattenListable<kinds> : reducibleKindOf<flattenListable<kinds>>>;
    protected finalizeRootArgs(opts: NodeParseOptions, resolve: () => BaseRoot): NodeParseOptions;
    resolveRoot(name: string): BaseRoot;
    maybeResolveRoot(name: string): BaseRoot | undefined;
    preparseRoot(def: unknown): unknown;
    preparseAlias(k: string, v: unknown): AliasDefEntry;
    maybeResolve(name: string): Exclude<CachedResolution, string> | undefined;
    get ambient(): InternalModule;
    maybeShallowResolve(name: string): CachedResolution | undefined;
    /** If name is a valid reference to a submodule alias, return its resolution  */
    protected maybeResolveSubalias(name: string): BaseRoot | GenericRoot | undefined;
    import<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredImportContext<$, names>>>;
    private _exportedResolutions;
    private _exports;
    export<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredExportContext<$, names>>>;
    resolve<name extends exportedNameOf<$>>(name: name): destructuredExportContext<$, []>[name];
    abstract parseRoot(schema: unknown, opts?: NodeParseOptions): BaseRoot;
}
type instantiateAliases<aliases> = {
    [k in keyof aliases]: aliases[k] extends InternalResolution ? aliases[k] : BaseRoot;
} & unknown;
export declare const schemaScope: <const aliases extends { [k in keyof aliases]: conform<aliases[k], RootSchema | PreparsedNodeResolution>; }>(aliases: aliases, config?: ArkScopeConfig) => SchemaScope<instantiateAliases<aliases>>;
export declare class SchemaScope<$ extends InternalResolutions = InternalResolutions> extends BaseScope<$> {
    defineRoot<schema extends RootSchema>(schema: schema): schema;
    parseRoot(schema: RootSchema, opts?: NodeParseOptions): BaseRoot;
}
export declare const $root: SchemaScope;
export declare const rootNode: SchemaScope["rootNode"];
export declare const node: SchemaScope["node"];
export declare const defineSchema: SchemaScope["defineSchema"];
export declare const genericNode: SchemaScope["generic"];
export declare const parseAsSchema: (def: unknown, opts?: NodeParseOptions) => BaseRoot | ParseError;
export type destructuredExportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names["length"] extends 0 ? exportedNameOf<$> : names[number]]: $[k];
};
export type destructuredImportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names["length"] extends 0 ? exportedNameOf<$> : names[number] as `#${k & string}`]: $[k];
};
export type RootExportCache = Record<string, BaseRoot | GenericRoot | RootModule | undefined>;
export declare const writeUnresolvableMessage: <token extends string>(token: token) => writeUnresolvableMessage<token>;
export type writeUnresolvableMessage<token extends string> = `'${token}' is unresolvable`;
export declare const writeNonSubmoduleDotMessage: <name extends string>(name: name) => writeNonSubmoduleDotMessage<name>;
export type writeNonSubmoduleDotMessage<name extends string> = `'${name}' must reference a module to be accessed using dot syntax`;
export declare const writeMissingSubmoduleAccessMessage: <name extends string>(name: name) => writeMissingSubmoduleAccessMessage<name>;
export type writeMissingSubmoduleAccessMessage<name extends string> = `Reference to submodule '${name}' must specify an alias`;
export declare const bindCompiledScope: (references: readonly BaseNode[]) => void;
export {};
