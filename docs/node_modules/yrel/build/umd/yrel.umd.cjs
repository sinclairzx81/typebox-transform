(function(c,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(c=typeof globalThis<"u"?globalThis:c||self,p(c.yrel={}))})(this,function(c){"use strict";const p=Symbol("SCHEMA"),g=Symbol("SCHEMA_ANY"),b=Symbol("SCHEMA_BOOLEAN"),d=Symbol("SCHEMA_NUMBER"),v=Symbol("SCHEMA_STRING"),E=Symbol("SCHEMA_LITERAL"),C=Symbol("SCHEMA_ARRAY"),O=Symbol("SCHEMA_UNION"),M=Symbol("SCHEMA_TUPLE"),N=Symbol("SCHEMA_OBJECT"),A=(n,e,r)=>{const s=(r==null?void 0:r.key)??"",i=[];let t=!0,y=[];try{for(const a of n.__checkers)if(a(e,n.__cache))return{key:s,isValid:t,errors:i,children:y};for(const a of n.__resolvers){const u=a(e,n.__cache,{key:s});u.errors&&i.push(...u.errors),u.children&&(y=u.children)}for(const a of n.__validators){const u=a(e,n.__cache);u!==!0&&i.push(...u)}}catch(a){console.error(a),i.push(["err_unknown"])}return t=i.length===0&&y.every(a=>a.isValid),{key:s,isValid:t,errors:i,children:y}},_=n=>{const{name:e,resolver:r,validators:s,narrowers:i}=n,t=n.schemaBase??{},{__cache:y,__checkers:a,__resolvers:u,__validators:m}=t;for(const o of Object.keys(t))delete t[o];if(t.__type=p,t.__name=e,t.__cache=y??{},t.__checkers=Array.isArray(a)?[...a]:[(o,l)=>!!l.isOptional&&o===void 0,(o,l)=>!!l.isNullable&&o===null],t.__resolvers=u??[],t.__resolvers.push(r),t.__validators=Array.isArray(m)?[...m]:[],t.validate=o=>(t.__validators.push(l=>o(l,t.__cache)),t),s)for(const o of Object.keys(s)){const l=o,h=s[l];Object.assign(t,{[l]:(...f)=>{const[S,...R]=[...f].reverse(),w=R.reverse(),D=S!==null&&typeof S=="object"&&"errors"in S&&Array.isArray(S.errors)&&S.errors.every(k=>Array.isArray(k)),L=D?w:f,B=(k,U)=>{const V=h(...L)(k,U);return V===!0?!0:D&&S.errors||V};return t.__validators.push(B),t}})}if(Object.assign(t,{optional:()=>(t.__cache.isOptional=!0,t),nullable:()=>(t.__cache.isNullable=!0,t)}),i)for(const o of Object.keys(i)){const l=o,h=i[l];Object.assign(t,{[l]:(...f)=>h(t)(...f)})}return t},j={any:()=>_({schemaBase:null,name:g,resolver:(n,e,r)=>({key:r.key,isValid:!0,errors:[],children:[]})}),boolean:n=>_({schemaBase:n,name:b,resolver:(e,r,s)=>typeof e=="boolean"?{key:s.key,isValid:!0,errors:[],children:[]}:{key:s.key,isValid:!1,errors:[["err_boolean"]],children:[]},validators:{truthy:()=>e=>e===!0||[["err_boolean_truthy"]]}}),number:n=>_({schemaBase:n,name:d,resolver:(e,r,s)=>typeof e=="number"&&!isNaN(e)&&Number.isFinite(e)?{key:s.key,isValid:!0,errors:[],children:[]}:{key:s.key,isValid:!1,errors:[["err_number"]],children:[]},validators:{gt:e=>r=>typeof r!="number"?[]:r>e||[["err_number_gt",{gt:e}]],gte:e=>r=>typeof r!="number"?[]:r>=e||[["err_number_gte",{gte:e}]],lt:e=>r=>typeof r!="number"?[]:r<e||[["err_number_lt",{lt:e}]],lte:e=>r=>typeof r!="number"?[]:r<=e||[["err_number_lte",{lte:e}]],integer:()=>e=>typeof e!="number"?[]:Number.isInteger(e)&&Number.isSafeInteger(e)||[["err_number_integer"]]}}),string:n=>_({schemaBase:n,name:v,resolver:(e,r,s)=>typeof e=="string"?{key:s.key,isValid:!0,errors:[],children:[]}:{key:s.key,isValid:!1,errors:[["err_string"]],children:[]},validators:{nonempty:()=>e=>typeof e!="string"?[]:e.length>0||[["err_string_nonempty"]],trim:()=>e=>typeof e!="string"?[]:e===e.trim()||[["err_string_trim"]],length:e=>r=>typeof r!="string"?[]:r.length===e||[["err_string_length",{length:e}]],min:e=>r=>typeof r!="string"?[]:r.length>=e||[["err_string_min",{min:e}]],max:e=>r=>typeof r!="string"?[]:r.length<=e||[["err_string_max",{max:e}]],datetime:()=>e=>{if(typeof e!="string")return[];const r=Date.parse(e);return(isNaN(r)?null:new Date(r).toISOString())===e||[["err_string_date_time"]]},date:()=>e=>{if(typeof e!="string")return[];const r=Date.parse(e);return(isNaN(r)?null:new Date(r).toISOString().slice(0,10))===e||[["err_string_date"]]},time:()=>e=>{if(typeof e!="string")return[];const r=Date.parse(`2000-01-01T${e}Z`);return(isNaN(r)?null:new Date(r).toISOString().slice(11,23))===e||[["err_string_time"]]},lowercase:()=>e=>typeof e!="string"?[]:e===e.toLowerCase()||[["err_string_lowercase"]],uppercase:()=>e=>typeof e!="string"?[]:e===e.toUpperCase()||[["err_string_uppercase"]],capitalcase:()=>e=>typeof e!="string"?[]:e===e.replace(/(?:^|\s|["'([{])+\S/g,r=>r.toUpperCase())||[["err_string_capitalcase"]]}}),literal:(n,e)=>_({schemaBase:e,name:E,resolver:(r,s,i)=>Object.is(r,n)?{key:i.key,isValid:!0,errors:[],children:[]}:{key:i.key,isValid:!1,errors:[["err_literal",{literal:n}]],children:[]}}),array:(n,e)=>_({schemaBase:e,name:C,resolver:(r,s,i)=>{if(!Array.isArray(r))return{key:i.key,isValid:!1,errors:[["err_array"]],children:[]};const t=r.map((a,u)=>{const m=i.key?`${i.key}.${u}`:String(u);return A(n,a,{key:m})}),y=t.every(a=>a.isValid);return{key:i.key,isValid:y,errors:[],children:t}},validators:{nonempty:()=>r=>Array.isArray(r)?r.length>0||[["err_array_nonempty"]]:[],length:r=>s=>Array.isArray(s)?s.length===r||[["err_array_length",{length:r}]]:[],min:r=>s=>Array.isArray(s)?s.length>=r||[["err_array_min",{min:r}]]:[],max:r=>s=>Array.isArray(s)?s.length<=r||[["err_array_max",{max:r}]]:[]}}),union:(n,e,r)=>{if(!n||!n.length)throw new Error("Data validator .union([...schemas]) requires at least one schema definition.");return _({schemaBase:r,name:O,resolver:(s,i,t)=>{for(const y of n)if(A(y,s,t).isValid)return{key:t.key,isValid:!0,errors:[],children:[]};return e!=null&&e.errors?{key:t.key,isValid:!1,errors:e.errors,children:[]}:{key:t.key,isValid:!1,errors:[["err_union"]],children:[]}}})},tuple:(n,e,r)=>{if(!n||!n.length)throw new Error("Data validator .tuple([...schemas]) requires at least one schema definition.");return _({schemaBase:r,name:M,resolver:(s,i,t)=>{if(!Array.isArray(s)||!e&&s.length!==n.length)return{key:t.key,isValid:!1,errors:[["err_tuple"]],children:[]};const y=n.map((o,l)=>{const h=t.key?`${t.key}.${l}`:String(l);return A(o,s[l],{key:h})});let a=[];e&&(a=s.slice(n.length).map((l,h)=>{const f=n.length+h,S=t.key?`${t.key}.${f}`:String(f);return A(e,l,{key:S})}));const u=[...y,...a],m=u.every(o=>o.isValid);return{key:t.key,isValid:m,errors:[],children:u}}})},object:(n,e)=>_({schemaBase:e,name:N,resolver:(r,s,i)=>{if(!(r!==null&&typeof r=="object"&&typeof r!="function"&&!Array.isArray(r)))return{key:i.key,isValid:!1,errors:[["err_object"]],children:[]};const y=Object.keys(n),a=Object.keys(r);if(!s.passthroughObjectProps){const o=a.filter(l=>!Object.prototype.hasOwnProperty.call(n,l));if(o.length>0)return{key:i.key,isValid:!1,errors:[["err_object_unexpected_props",{props:o}]],children:[]}}const u=y.map(o=>{const l=n[o],h=r[o],f=i.key?`${i.key}.${String(o)}`:String(o);return A(l,h,{key:f})}),m=u.every(o=>o.isValid);return{key:i.key,isValid:m,errors:[],children:u}},narrowers:{passthrough:r=>()=>(r.__cache.passthroughObjectProps=!0,r)}})},T=n=>n!==null&&typeof n=="object"&&n.__type===p,H=n=>[...n.errors.length>0?[{key:n.key,errors:n.errors}]:[],...n.children.reduce((e,r)=>[...e,...H(r)],[])],I=(n,e,r)=>{const{rootKey:s=""}={...r},i=A(n,e,{key:s}),t=i.isValid,y=t?e:void 0;return{isValid:t,issues:H(i),data:y}};c.SCHEMA=p,c.SCHEMA_ANY=g,c.SCHEMA_ARRAY=C,c.SCHEMA_BOOLEAN=b,c.SCHEMA_LITERAL=E,c.SCHEMA_NUMBER=d,c.SCHEMA_OBJECT=N,c.SCHEMA_STRING=v,c.SCHEMA_TUPLE=M,c.SCHEMA_UNION=O,c.isSchema=T,c.processSchema=A,c.v=j,c.validate=I,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
