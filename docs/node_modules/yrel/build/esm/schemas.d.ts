import type { InferDataSchemaType, DataValidationInSchemaConfig, DataSchema, DataSchemaBoolean, DataSchemaNumber, DataSchemaString, DataSchemaLiteral, DataSchemaArray, DataSchemaUnion, DataSchemaTuple, DataSchemaObject, DataSchemaAny } from './types';
declare const v: {
    any: () => DataSchemaAny;
    boolean: (schemaBase?: DataSchema) => DataSchemaBoolean;
    number: (schemaBase?: DataSchema) => DataSchemaNumber;
    string: (schemaBase?: DataSchema) => DataSchemaString;
    literal: <Data extends string | number | boolean | null | undefined>(literal: Data, schemaBase?: DataSchema) => DataSchemaLiteral<Data>;
    array: <Structure extends DataSchema<any> = DataSchema<any>, Data_1 extends unknown[] | null | undefined = InferDataSchemaType<Structure>[]>(structure: Structure, schemaBase?: DataSchema) => DataSchemaArray<Structure, Data_1>;
    union: <Structures extends [DataSchema<any>, ...DataSchema<any>[]] = [DataSchema<any>], Data_2 extends unknown = InferDataSchemaType<Structures[number]>>(structures: Structures, config?: DataValidationInSchemaConfig, schemaBase?: DataSchema) => DataSchemaUnion<Structures, Data_2>;
    tuple: <Structures_1 extends [DataSchema<any>, ...DataSchema<any>[]] = [DataSchema<any>], RestStructure extends DataSchema<any> | undefined = undefined, Data_3 extends unknown = InferDataSchemaType<Structures_1>>(structures: Structures_1, restStructure?: RestStructure | undefined, schemaBase?: DataSchema) => DataSchemaTuple<Structures_1, RestStructure, Data_3>;
    object: <Structure_1 extends Record<string, DataSchema<any>> = Record<string, DataSchema<any>>, Data_4 extends Record<string, unknown> | null | undefined = { [P in keyof Structure_1]: InferDataSchemaType<Structure_1[P]>; }>(structure: Structure_1, schemaBase?: DataSchema) => DataSchemaObject<Structure_1, Data_4>;
};
export { v };
