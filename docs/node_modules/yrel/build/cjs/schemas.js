"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.v = void 0;
const constants_1 = require("./constants");
const processSchema_1 = require("./processSchema");
const createSchemaFactory = (props) => {
    const { name, resolver, validators, narrowers } = props;
    const schemaBase = props.schemaBase ?? {};
    const { __cache, __checkers, __resolvers, __validators } = schemaBase;
    for (const key of Object.keys(schemaBase)) {
        delete schemaBase[key];
    }
    schemaBase.__type = constants_1.SCHEMA;
    schemaBase.__name = name;
    schemaBase.__cache = __cache ?? {};
    schemaBase.__checkers = Array.isArray(__checkers)
        ? [...__checkers]
        : [
            (data, cache) => !!cache.isOptional && data === undefined,
            (data, cache) => !!cache.isNullable && data === null
        ];
    schemaBase.__resolvers = __resolvers ?? [];
    schemaBase.__resolvers.push(resolver);
    schemaBase.__validators = Array.isArray(__validators) ? [...__validators] : [];
    schemaBase.validate = (validate) => {
        schemaBase.__validators.push((data) => validate(data, schemaBase.__cache));
        return schemaBase;
    };
    if (validators) {
        for (const _key of Object.keys(validators)) {
            const key = _key;
            const validator = validators[key];
            Object.assign(schemaBase, {
                [key]: (...params) => {
                    const [config, ...paramsExtra] = [...params].reverse();
                    const validateParamsWithoutConfig = paramsExtra.reverse();
                    const isConfigProvided = config !== null &&
                        typeof config === 'object' &&
                        'errors' in config &&
                        Array.isArray(config.errors) &&
                        config.errors.every((err) => Array.isArray(err));
                    const validateParams = isConfigProvided ? validateParamsWithoutConfig : params;
                    const validate = (data, cache) => {
                        const result = validator(...validateParams)(data, cache);
                        if (result === true) {
                            return true;
                        }
                        return (isConfigProvided && config.errors) || result;
                    };
                    schemaBase.__validators.push(validate);
                    return schemaBase;
                }
            });
        }
    }
    Object.assign(schemaBase, {
        optional: () => {
            schemaBase.__cache.isOptional = true;
            return schemaBase;
        },
        nullable: () => {
            schemaBase.__cache.isNullable = true;
            return schemaBase;
        }
    });
    if (narrowers) {
        for (const _key of Object.keys(narrowers)) {
            const key = _key;
            const narrower = narrowers[key];
            Object.assign(schemaBase, {
                [key]: (...params) => narrower(schemaBase)(...params)
            });
        }
    }
    return schemaBase;
};
const createDataSchemaBoolean = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_BOOLEAN,
        resolver: (data, cache, context) => {
            if (typeof data === 'boolean') {
                return { key: context.key, isValid: true, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, errors: [['err_boolean']], children: [] };
        },
        validators: {
            truthy: () => (data) => {
                return data === true || [['err_boolean_truthy']];
            }
        }
    });
};
const createDataSchemaNumber = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_NUMBER,
        resolver: (data, cache, context) => {
            if (typeof data === 'number' && !isNaN(data) && Number.isFinite(data)) {
                return { key: context.key, isValid: true, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, errors: [['err_number']], children: [] };
        },
        validators: {
            gt: (gt) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data > gt || [['err_number_gt', { gt }]];
            },
            gte: (gte) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data >= gte || [['err_number_gte', { gte }]];
            },
            lt: (lt) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data < lt || [['err_number_lt', { lt }]];
            },
            lte: (lte) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data <= lte || [['err_number_lte', { lte }]];
            },
            integer: () => (data) => {
                if (typeof data !== 'number')
                    return [];
                return (Number.isInteger(data) && Number.isSafeInteger(data)) || [['err_number_integer']];
            }
        }
    });
};
const createDataSchemaString = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_STRING,
        resolver: (data, cache, context) => {
            if (typeof data === 'string') {
                return { key: context.key, isValid: true, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, errors: [['err_string']], children: [] };
        },
        validators: {
            nonempty: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length > 0 || [['err_string_nonempty']];
            },
            trim: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.trim() || [['err_string_trim']];
            },
            length: (length) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length === length || [['err_string_length', { length }]];
            },
            min: (min) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length >= min || [['err_string_min', { min }]];
            },
            max: (max) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length <= max || [['err_string_max', { max }]];
            },
            datetime: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(data);
                const datetime = isNaN(timestamp) ? null : new Date(timestamp).toISOString();
                return datetime === data || [['err_string_date_time']];
            },
            date: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(data);
                const datetime = isNaN(timestamp) ? null : new Date(timestamp).toISOString().slice(0, 10);
                return datetime === data || [['err_string_date']];
            },
            time: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(`2000-01-01T${data}Z`);
                const datetime = isNaN(timestamp) ? null : new Date(timestamp).toISOString().slice(11, 23);
                return datetime === data || [['err_string_time']];
            },
            lowercase: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.toLowerCase() || [['err_string_lowercase']];
            },
            uppercase: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.toUpperCase() || [['err_string_uppercase']];
            },
            capitalcase: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return (data === data.replace(/(?:^|\s|["'([{])+\S/g, (match) => match.toUpperCase()) || [
                    ['err_string_capitalcase']
                ]);
            }
        }
    });
};
const createDataSchemaLiteral = (literal, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_LITERAL,
        resolver: (data, cache, context) => {
            if (Object.is(data, literal)) {
                return { key: context.key, isValid: true, errors: [], children: [] };
            }
            return {
                key: context.key,
                isValid: false,
                errors: [['err_literal', { literal: literal }]],
                children: []
            };
        }
    });
};
const createDataSchemaArray = (structure, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_ARRAY,
        resolver: (data, cache, context) => {
            if (!Array.isArray(data)) {
                return { key: context.key, isValid: false, errors: [['err_array']], children: [] };
            }
            const children = data.map((dataItem, index) => {
                const key = context.key ? `${context.key}.${index}` : String(index);
                return (0, processSchema_1.processSchema)(structure, dataItem, { key });
            });
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, errors: [], children };
        },
        validators: {
            nonempty: () => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length > 0 || [['err_array_nonempty']];
            },
            length: (length) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length === length || [['err_array_length', { length }]];
            },
            min: (min) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length >= min || [['err_array_min', { min }]];
            },
            max: (max) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length <= max || [['err_array_max', { max }]];
            }
        }
    });
};
const createDataSchemaUnion = (structures, config, schemaBase) => {
    if (!structures || !structures.length) {
        throw new Error('Data validator .union([...schemas]) requires at least one schema definition.');
    }
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_UNION,
        resolver: (data, cache, context) => {
            for (const structure of structures) {
                const resolution = (0, processSchema_1.processSchema)(structure, data, context);
                if (resolution.isValid) {
                    return { key: context.key, isValid: true, errors: [], children: [] };
                }
            }
            if (config?.errors) {
                return { key: context.key, isValid: false, errors: config.errors, children: [] };
            }
            return { key: context.key, isValid: false, errors: [['err_union']], children: [] };
        }
    });
};
const createDataSchemaTuple = (structures, restStructure, schemaBase) => {
    if (!structures || !structures.length) {
        throw new Error('Data validator .tuple([...schemas]) requires at least one schema definition.');
    }
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_TUPLE,
        resolver: (data, cache, context) => {
            if (!Array.isArray(data) || (!restStructure && data.length !== structures.length)) {
                return { key: context.key, isValid: false, errors: [['err_tuple']], children: [] };
            }
            const mainItemsResolutions = structures.map((structure, index) => {
                const key = context.key ? `${context.key}.${index}` : String(index);
                return (0, processSchema_1.processSchema)(structure, data[index], { key });
            });
            let restItemsResolutions = [];
            if (restStructure) {
                const restData = data.slice(structures.length);
                restItemsResolutions = restData.map((restItem, restItemIndex) => {
                    const index = structures.length + restItemIndex;
                    const key = context.key ? `${context.key}.${index}` : String(index);
                    return (0, processSchema_1.processSchema)(restStructure, restItem, { key });
                });
            }
            const children = [...mainItemsResolutions, ...restItemsResolutions];
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, errors: [], children };
        }
    });
};
const createDataSchemaObject = (structure, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.SCHEMA_OBJECT,
        resolver: (data, cache, context) => {
            const isObject = data !== null &&
                typeof data === 'object' &&
                typeof data !== 'function' &&
                !Array.isArray(data);
            if (!isObject) {
                return { key: context.key, isValid: false, errors: [['err_object']], children: [] };
            }
            const structureKeys = Object.keys(structure);
            const dataKeys = Object.keys(data);
            if (!cache.passthroughObjectProps) {
                const unexpectedProps = dataKeys.filter((dataKey) => !Object.prototype.hasOwnProperty.call(structure, dataKey));
                if (unexpectedProps.length > 0) {
                    return {
                        key: context.key,
                        isValid: false,
                        errors: [['err_object_unexpected_props', { props: unexpectedProps }]],
                        children: []
                    };
                }
            }
            const children = structureKeys.map((itemKey) => {
                const itemSchema = structure[itemKey];
                const itemData = data[itemKey];
                const key = context.key ? `${context.key}.${String(itemKey)}` : String(itemKey);
                return (0, processSchema_1.processSchema)(itemSchema, itemData, { key });
            });
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, errors: [], children };
        },
        narrowers: {
            passthrough: (schema) => () => {
                schema.__cache.passthroughObjectProps = true;
                return schema;
            }
        }
    });
};
const createDataSchemaAny = () => {
    return createSchemaFactory({
        schemaBase: null,
        name: constants_1.SCHEMA_ANY,
        resolver: (data, cache, context) => ({
            key: context.key,
            isValid: true,
            errors: [],
            children: []
        })
    });
};
const v = {
    any: createDataSchemaAny,
    boolean: createDataSchemaBoolean,
    number: createDataSchemaNumber,
    string: createDataSchemaString,
    literal: createDataSchemaLiteral,
    array: createDataSchemaArray,
    union: createDataSchemaUnion,
    tuple: createDataSchemaTuple,
    object: createDataSchemaObject
};
exports.v = v;
