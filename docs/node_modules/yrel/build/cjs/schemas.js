"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.y = exports.yrel = void 0;
const constants_1 = require("./constants");
const processYrel_1 = require("./processYrel");
const isObject = (data) => data !== null &&
    typeof data === 'object' &&
    typeof data !== 'function' &&
    !Array.isArray(data);
const createSchemaFactory = (props) => {
    const { name, resolver, properties, validators, narrowers } = props;
    const schemaBase = props.schemaBase ?? {};
    const { __cache, __checkers, __resolvers, __validators } = schemaBase;
    for (const key of Object.keys(schemaBase)) {
        delete schemaBase[key];
    }
    schemaBase.__type = constants_1.YREL;
    schemaBase.__name = name;
    schemaBase.__cache = __cache ?? {};
    schemaBase.__checkers = Array.isArray(__checkers)
        ? [...__checkers]
        : [
            (data, cache) => !!cache.isOptional && data === undefined,
            (data, cache) => !!cache.isNullable && data === null
        ];
    schemaBase.__resolvers = __resolvers ?? [];
    schemaBase.__resolvers.push(resolver);
    schemaBase.__validators = Array.isArray(__validators) ? [...__validators] : [];
    if (properties) {
        Object.assign(schemaBase, properties);
    }
    schemaBase.preprocess = (preprocess) => {
        schemaBase.__cache.preprocessors = schemaBase.__cache.preprocessors
            ? [...schemaBase.__cache.preprocessors, preprocess]
            : [preprocess];
        return schemaBase;
    };
    schemaBase.defaultsTo = (data) => {
        schemaBase.__cache.defaultData = data;
        return schemaBase;
    };
    schemaBase.transform = (transform) => {
        schemaBase.__cache.transformers = schemaBase.__cache.transformers
            ? [...schemaBase.__cache.transformers, transform]
            : [transform];
        return schemaBase;
    };
    schemaBase.validate = (validate) => {
        schemaBase.__validators.push((data) => validate(data, schemaBase.__cache));
        return schemaBase;
    };
    if (validators) {
        for (const _key of Object.keys(validators)) {
            const key = _key;
            const validator = validators[key];
            Object.assign(schemaBase, {
                [key]: (...params) => {
                    const [config, ...paramsExtra] = [...params].reverse();
                    const validateParamsWithoutConfig = paramsExtra.reverse();
                    const isConfigProvided = config !== null &&
                        typeof config === 'object' &&
                        'errors' in config &&
                        Array.isArray(config.errors) &&
                        config.errors.every((err) => Array.isArray(err));
                    const validateParams = isConfigProvided ? validateParamsWithoutConfig : params;
                    const validate = (data, cache) => {
                        const result = validator(...validateParams)(data, cache);
                        if (result === true) {
                            return true;
                        }
                        return (isConfigProvided && config.errors) || result;
                    };
                    schemaBase.__validators.push(validate);
                    return schemaBase;
                }
            });
        }
    }
    Object.assign(schemaBase, {
        coerce: () => {
            schemaBase.__cache.coerce = true;
            return schemaBase;
        },
        optional: () => {
            schemaBase.__cache.isOptional = true;
            return schemaBase;
        },
        nullable: () => {
            schemaBase.__cache.isNullable = true;
            return schemaBase;
        }
    });
    if (narrowers) {
        for (const _key of Object.keys(narrowers)) {
            const key = _key;
            const narrower = narrowers[key];
            Object.assign(schemaBase, {
                [key]: (...params) => narrower(schemaBase)(...params)
            });
        }
    }
    return schemaBase;
};
const createYrelSchemaBoolean = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_BOOLEAN,
        resolver: (input, cache, context) => {
            const data = cache.coerce ? Boolean(input) : input;
            if (typeof data === 'boolean') {
                return { key: context.key, isValid: true, data, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, data, errors: [['err_boolean']], children: [] };
        },
        validators: {
            truthy: () => (data) => {
                return data === true || [['err_boolean_truthy']];
            }
        }
    });
};
const createYrelSchemaNumber = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_NUMBER,
        resolver: (input, cache, context) => {
            const data = cache.coerce ? Number(input) : input;
            if (typeof data === 'number' && !isNaN(data) && Number.isFinite(data)) {
                return { key: context.key, isValid: true, data, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, data, errors: [['err_number']], children: [] };
        },
        validators: {
            gt: (gt) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data > gt || [['err_number_gt', { gt }]];
            },
            gte: (gte) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data >= gte || [['err_number_gte', { gte }]];
            },
            lt: (lt) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data < lt || [['err_number_lt', { lt }]];
            },
            lte: (lte) => (data) => {
                if (typeof data !== 'number')
                    return [];
                return data <= lte || [['err_number_lte', { lte }]];
            },
            integer: () => (data) => {
                if (typeof data !== 'number')
                    return [];
                return (Number.isInteger(data) && Number.isSafeInteger(data)) || [['err_number_integer']];
            }
        }
    });
};
const createYrelSchemaString = (schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_STRING,
        resolver: (input, cache, context) => {
            const data = cache.coerce
                ? input instanceof Date ? input.toISOString() : String(input)
                : input;
            if (typeof data === 'string') {
                return { key: context.key, isValid: true, data, errors: [], children: [] };
            }
            return { key: context.key, isValid: false, data, errors: [['err_string']], children: [] };
        },
        validators: {
            nonempty: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length > 0 || [['err_string_nonempty']];
            },
            trim: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.trim() || [['err_string_trim']];
            },
            length: (length) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length === length || [['err_string_length', { length }]];
            },
            min: (min) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length >= min || [['err_string_min', { min }]];
            },
            max: (max) => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data.length <= max || [['err_string_max', { max }]];
            },
            datetime: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(data);
                const expectedDateTime = isNaN(timestamp) ? null : new Date(timestamp).toISOString().slice(0, 19);
                const receivedDateTime = data.slice(0, 19);
                const hasValidMilliseconds = /^(\.\d{1,3})?Z$/.test(data.slice(19));
                return (expectedDateTime === receivedDateTime && hasValidMilliseconds) || [['err_string_date_time']];
            },
            date: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(data);
                const datetime = isNaN(timestamp) ? null : new Date(timestamp).toISOString().slice(0, 10);
                return datetime === data || [['err_string_date']];
            },
            time: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                const timestamp = Date.parse(`2000-01-01T${data}Z`);
                const expectedDateTime = isNaN(timestamp) ? null : new Date(timestamp).toISOString().slice(11, 19);
                const receivedDateTime = data.slice(0, 8);
                const hasValidMilliseconds = /^(\.\d{1,3})?$/.test(data.slice(8));
                return (expectedDateTime === receivedDateTime && hasValidMilliseconds) || [['err_string_time']];
            },
            lowercase: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.toLowerCase() || [['err_string_lowercase']];
            },
            uppercase: () => (data) => {
                if (typeof data !== 'string')
                    return [];
                return data === data.toUpperCase() || [['err_string_uppercase']];
            },
            capitalcase: (conf) => (data) => {
                if (typeof data !== 'string')
                    return [];
                const baseString = conf?.lower ? data.toLowerCase() : data;
                return (data === baseString.replace(/(?:^|\s|["'([{])+\S/g, (match) => match.toUpperCase()) || [
                    ['err_string_capitalcase', { lower: !!conf?.lower }]
                ]);
            }
        }
    });
};
const createYrelSchemaLiteral = (literal, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_LITERAL,
        resolver: (data, cache, context) => {
            if (Object.is(data, literal)) {
                return { key: context.key, isValid: true, data, errors: [], children: [] };
            }
            return {
                key: context.key,
                isValid: false,
                data,
                errors: [['err_literal', { literal: literal }]],
                children: []
            };
        }
    });
};
const createYrelSchemaArray = (structure, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_ARRAY,
        resolver: (data, cache, context) => {
            if (!Array.isArray(data)) {
                return { key: context.key, isValid: false, data, errors: [['err_array']], children: [] };
            }
            const children = data.map((dataItem, index) => {
                const key = context.key ? `${context.key}.${index}` : String(index);
                return (0, processYrel_1.processYrel)(structure, dataItem, { key });
            });
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, data, errors: [], children };
        },
        validators: {
            nonempty: () => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length > 0 || [['err_array_nonempty']];
            },
            length: (length) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length === length || [['err_array_length', { length }]];
            },
            min: (min) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length >= min || [['err_array_min', { min }]];
            },
            max: (max) => (data) => {
                if (!Array.isArray(data))
                    return [];
                return data.length <= max || [['err_array_max', { max }]];
            }
        }
    });
};
const createYrelSchemaUnion = (structures, config, schemaBase) => {
    if (!structures || !structures.length) {
        throw new Error('Data validator .union([...schemas]) requires schema definitions.');
    }
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_UNION,
        resolver: (data, cache, context) => {
            for (const structure of structures) {
                const resolution = (0, processYrel_1.processYrel)(structure, data, context);
                if (resolution.isValid) {
                    return { key: context.key, isValid: true, data, errors: [], children: [] };
                }
            }
            if (config?.errors) {
                return { key: context.key, isValid: false, data, errors: config.errors, children: [] };
            }
            return { key: context.key, isValid: false, data, errors: [['err_union']], children: [] };
        }
    });
};
const createYrelSchemaTuple = (structures, restStructure, schemaBase) => {
    if (!structures || !structures.length) {
        throw new Error('Data validator .tuple([...schemas]) requires at least one schema definition.');
    }
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_TUPLE,
        resolver: (data, cache, context) => {
            if (!Array.isArray(data) || (!restStructure && data.length !== structures.length)) {
                return { key: context.key, isValid: false, data, errors: [['err_tuple']], children: [] };
            }
            const mainItemsResolutions = structures.map((structure, index) => {
                const key = context.key ? `${context.key}.${index}` : String(index);
                return (0, processYrel_1.processYrel)(structure, data[index], { key });
            });
            let restItemsResolutions = [];
            if (restStructure) {
                const restData = data.slice(structures.length);
                restItemsResolutions = restData.map((restItem, restItemIndex) => {
                    const index = structures.length + restItemIndex;
                    const key = context.key ? `${context.key}.${index}` : String(index);
                    return (0, processYrel_1.processYrel)(restStructure, restItem, { key });
                });
            }
            const children = [...mainItemsResolutions, ...restItemsResolutions];
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, data, errors: [], children };
        }
    });
};
const createYrelSchemaObject = (structure, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_OBJECT,
        resolver: (data, cache, context) => {
            if (!isObject(data)) {
                return { key: context.key, isValid: false, data, errors: [['err_object']], children: [] };
            }
            const structureKeys = Object.keys(structure);
            const dataKeys = Object.keys(data);
            if (!cache.passthroughObjectProps) {
                const unexpectedProps = dataKeys.filter((dataKey) => !Object.prototype.hasOwnProperty.call(structure, dataKey));
                if (unexpectedProps.length > 0) {
                    return {
                        key: context.key,
                        isValid: false,
                        data,
                        errors: [['err_object_unexpected_props', { props: unexpectedProps }]],
                        children: []
                    };
                }
            }
            const children = structureKeys.map((itemKey) => {
                const itemSchema = structure[itemKey];
                const itemData = data[itemKey];
                const key = context.key ? `${context.key}.${String(itemKey)}` : String(itemKey);
                return (0, processYrel_1.processYrel)(itemSchema, itemData, { key });
            });
            const isValid = children.every((child) => child.isValid);
            return { key: context.key, isValid, data, errors: [], children };
        },
        properties: {
            shape: structure
        },
        narrowers: {
            passthrough: (schema) => () => {
                schema.__cache.passthroughObjectProps = true;
                return schema;
            }
        }
    });
};
const createYrelSchemaRecord = (key, value, schemaBase) => {
    return createSchemaFactory({
        schemaBase,
        name: constants_1.YREL_RECORD,
        resolver: (data, cache, context) => {
            if (!isObject(data)) {
                return { key: context.key, isValid: false, data, errors: [['err_record']], children: [] };
            }
            const record = data;
            const itemsKeys = Object.keys(record);
            const keysInvalid = itemsKeys.filter(itemKey => {
                const validation = (0, processYrel_1.processYrel)(key, itemKey);
                return !validation.isValid;
            });
            const children = itemsKeys.map(itemKey => {
                const item = record[itemKey];
                const contextKey = context.key ? `${context.key}.${String(itemKey)}` : String(itemKey);
                return (0, processYrel_1.processYrel)(value, item, { key: contextKey });
            });
            const isValid = !keysInvalid.length && children.every((child) => child.isValid);
            const errors = keysInvalid.length
                ? [['err_record_keys', { keys: keysInvalid }]]
                : [];
            return { key: context.key, isValid, data, errors, children };
        }
    });
};
const createYrelSchemaAny = () => {
    return createSchemaFactory({
        schemaBase: null,
        name: constants_1.YREL_ANY,
        resolver: (data, cache, context) => ({
            key: context.key,
            isValid: true,
            data,
            errors: [],
            children: []
        })
    });
};
const yrel = {
    any: createYrelSchemaAny,
    boolean: createYrelSchemaBoolean,
    number: createYrelSchemaNumber,
    string: createYrelSchemaString,
    literal: createYrelSchemaLiteral,
    array: createYrelSchemaArray,
    union: createYrelSchemaUnion,
    tuple: createYrelSchemaTuple,
    object: createYrelSchemaObject,
    record: createYrelSchemaRecord
};
exports.yrel = yrel;
const y = yrel;
exports.y = y;
