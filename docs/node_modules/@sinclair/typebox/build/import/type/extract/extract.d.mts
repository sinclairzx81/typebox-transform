import type { TSchema, SchemaOptions } from '../schema/index.mjs';
import type { Assert, AssertRest, AssertType, UnionToTuple } from '../helpers/index.mjs';
import type { TMappedResult } from '../mapped/index.mjs';
import { type TTemplateLiteral } from '../template-literal/index.mjs';
import { type TLiteral } from '../literal/index.mjs';
import { type TUnion } from '../union/index.mjs';
import { type Static } from '../static/index.mjs';
import { type TNever } from '../never/index.mjs';
import { type TUnionEvaluated } from '../union/index.mjs';
import { type TExtractFromMappedResult } from './extract-from-mapped-result.mjs';
type TExtractTemplateLiteralResult<T extends string> = TUnionEvaluated<AssertRest<UnionToTuple<{
    [K in T]: TLiteral<K>;
}[T]>>>;
type TExtractTemplateLiteral<L extends TTemplateLiteral, R extends TSchema> = Extract<Static<L>, Static<R>> extends infer S ? TExtractTemplateLiteralResult<Assert<S, string>> : never;
type TExtractRest<L extends TSchema[], R extends TSchema> = AssertRest<UnionToTuple<{
    [K in keyof L]: Static<AssertType<L[K]>> extends Static<R> ? L[K] : never;
}[number]>> extends infer R extends TSchema[] ? TUnionEvaluated<R> : never;
export type TExtract<L extends TSchema, U extends TSchema> = (L extends TMappedResult ? TExtractFromMappedResult<L, U> : L extends TTemplateLiteral ? TExtractTemplateLiteral<L, U> : L extends TUnion<infer S> ? TExtractRest<S, U> : L extends U ? L : TNever);
/** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
export declare function Extract<L extends TSchema, R extends TSchema>(L: L, R: R, options?: SchemaOptions): TExtract<L, R>;
export {};
