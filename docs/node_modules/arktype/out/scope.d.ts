import { BaseScope, type AliasDefEntry, type ArkScopeConfig, type BaseNode, type BaseRoot, type GenericArgResolutions, type GenericAst, type GenericParamAst, type InternalResolutions, type NodeKind, type NodeParseOptions, type NodeSchema, type PreparsedNodeResolution, type PrivateDeclaration, type RootKind, type RootSchema, type arkKind, type destructuredExportContext, type destructuredImportContext, type exportedNameOf, type nodeOfKind, type reducibleKindOf, type toInternalScope, type writeDuplicateAliasError } from "@ark/schema";
import { type ErrorType, type Json, type anyOrNever, type array, type flattenListable, type nominal, type show } from "@ark/util";
import type { Ark } from "./ark.js";
import { parseGenericParams, type GenericDeclaration, type GenericHktParser, type ParameterString, type baseGenericConstraints, type parseValidGenericParams } from "./generic.js";
import type { BoundModule, Module, Submodule, instantiateExport } from "./module.js";
import { type inferDefinition, type validateDefinition } from "./parser/definition.js";
import type { ParsedDefault } from "./parser/string/shift/operator/default.js";
import { InternalTypeParser, type DeclarationParser, type DefinitionParser, type Type, type TypeParser } from "./type.js";
export type ScopeParser = <const def>(def: validateScope<def>, config?: ArkScopeConfig) => Scope<inferScope<def>>;
export type validateScope<def> = {
    [k in keyof def]: parseScopeKey<k, def>["params"] extends infer params ? params extends array<GenericParamAst> ? params["length"] extends 0 ? def[k] extends Type.Any | PreparsedResolution ? def[k] : k extends PrivateDeclaration<infer name extends keyof def & string> ? ErrorType<writeDuplicateAliasError<name>> : validateDefinition<def[k], bootstrapAliases<def>, {}> : validateDefinition<def[k], bootstrapAliases<def>, baseGenericConstraints<params>> : params : never;
};
export type inferScope<def> = inferBootstrapped<bootstrapAliases<def>>;
export type bindThis<def> = {
    this: Def<def>;
};
/** nominal type for an unparsed definition used during scope bootstrapping */
type Def<def = {}> = nominal<def, "unparsed">;
/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */
export type UnparsedScope = "$";
/** These are legal as values of a scope but not as definitions in other contexts */
type PreparsedResolution = PreparsedNodeResolution;
type bootstrapAliases<def> = {
    [k in Exclude<keyof def, GenericDeclaration>]: def[k] extends (PreparsedResolution) ? def[k] extends {
        t: infer g extends GenericAst;
    } ? g : def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn extends {
        t: infer g extends GenericAst;
    } ? g : thunkReturn : Def<def[k]>;
} & {
    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericAst<parseValidGenericParams<extractGenericParameters<k>, bootstrapAliases<def>>, def[k], UnparsedScope>;
};
type inferBootstrapped<$> = {
    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $, {}> : $[name] extends {
        t: GenericAst<infer params, infer def, infer body$>;
    } ? GenericAst<params, def, body$ extends UnparsedScope ? $ : body$, $> : $[name] extends Module<infer exports> ? Submodule<exports> : never;
} & unknown;
type extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;
type extractGenericParameters<k> = k extends `${string}<${infer params}>` ? ParameterString<params> : never;
export type resolve<reference extends keyof $ | keyof args, $, args> = (reference extends keyof args ? args[reference] : $[reference & keyof $]) extends infer resolution ? [
    resolution
] extends [anyOrNever] ? resolution : resolution extends Def<infer def> ? inferDefinition<def, $, args> : resolution : never;
export type moduleKeyOf<$> = {
    [k in keyof $]: $[k] extends {
        [arkKind]: "module";
    } ? [
        $[k]
    ] extends [anyOrNever] ? never : k & string : never;
}[keyof $];
export type tryInferSubmoduleReference<$, token> = token extends `${infer submodule extends moduleKeyOf<$>}.${infer subalias}` ? subalias extends keyof $[submodule] ? $[submodule][subalias] : tryInferSubmoduleReference<$[submodule], subalias> : token extends (`${infer submodule extends moduleKeyOf<Ark>}.${infer subalias}`) ? subalias extends keyof Ark[submodule] ? Ark[submodule][subalias] : tryInferSubmoduleReference<Ark[submodule], subalias> : never;
export interface ParseContext extends TypeParseOptions {
    $: InternalScope;
}
export interface TypeParseOptions {
    args?: GenericArgResolutions;
}
export declare const scope: ScopeParser;
export declare class InternalScope<$ extends InternalResolutions = InternalResolutions> extends BaseScope<$> {
    private parseCache;
    type: InternalTypeParser;
    declare: () => {
        type: InternalTypeParser;
    };
    define: (def: unknown) => unknown;
    preparseAlias(k: string, v: unknown): AliasDefEntry;
    preparseRoot(def: unknown): unknown;
    parseRoot(def: unknown, opts?: TypeParseOptions): BaseRoot;
    parse<defaultable extends boolean = false>(def: unknown, ctx: ParseContext, defaultable?: defaultable): BaseRoot | (defaultable extends false ? never : ParsedDefault);
    parseString<defaultable extends boolean>(def: string, ctx: ParseContext, defaultable: defaultable): BaseRoot | (defaultable extends false ? never : ParsedDefault);
}
export interface Scope<$ = {}> {
    t: $;
    [arkKind]: "scope";
    config: ArkScopeConfig;
    references: readonly BaseNode[];
    json: Json;
    exportedNames: array<exportedNameOf<$>>;
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    aliases: Record<string, unknown>;
    internal: toInternalScope<$>;
    defineSchema<const def extends RootSchema>(schema: def): def;
    schema(schema: RootSchema, opts?: NodeParseOptions): BaseRoot;
    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions): nodeOfKind<reducibleKindOf<flattenListable<kinds>>>;
    type: TypeParser<$>;
    declare: DeclarationParser<$>;
    define: DefinitionParser<$>;
    generic: GenericHktParser<$>;
    import(): Module<{
        [k in exportedNameOf<$> as PrivateDeclaration<k>]: $[k];
    }>;
    import<names extends exportedNameOf<$>[]>(...names: names): BoundModule<destructuredImportContext<$, names>, $>;
    export(): Module<{
        [k in exportedNameOf<$>]: $[k];
    }>;
    export<names extends exportedNameOf<$>[]>(...names: names): BoundModule<show<destructuredExportContext<$, names>>, $>;
    resolve<name extends exportedNameOf<$>>(name: name): instantiateExport<$[name], $>;
}
export declare const Scope: new <$ = {}>(...args: ConstructorParameters<typeof InternalScope>) => Scope<$>;
export declare const writeShallowCycleErrorMessage: (name: string, seen: string[]) => string;
export type parseScopeKey<k, def> = k extends `${infer name}<${infer params}>` ? parseGenericScopeKey<name, params, def> : {
    name: k;
    params: [];
};
type parseGenericScopeKey<name extends string, params extends string, def> = {
    name: name;
    params: parseGenericParams<params, bootstrapAliases<def>>;
};
export {};
