import { ArkErrors, BaseRoot, type MetaSchema, type Morph, type Predicate } from "@ark/schema";
import { Callable, type Constructor, type array, type conform } from "@ark/util";
import type { distillIn, distillOut } from "./ast.js";
import { type Generic, type ParameterString, type baseGenericConstraints, type parseValidGenericParams, type validateParameterString } from "./generic.js";
import type { inferDefinition, validateDeclared, validateDefinition } from "./parser/definition.js";
import type { IndexOneOperator, IndexZeroOperator, TupleInfixOperator } from "./parser/tuple.js";
import type { InternalScope, Scope, bindThis } from "./scope.js";
import type { BaseType } from "./subtypes/base.js";
import type { instantiateType } from "./subtypes/instantiate.js";
/** The convenience properties attached to `type` */
export type TypeParserAttachments = Omit<TypeParser, never>;
export interface TypeParser<$ = {}> {
    <const def, r = Type<inferTypeRoot<def, $>, $>>(def: validateTypeRoot<def, $>): r;
    <params extends ParameterString, const def>(params: validateParameterString<params, $>, def: validateDefinition<def, $, baseGenericConstraints<parseValidGenericParams<params, $>>>): Generic<parseValidGenericParams<params, $>, def, $>;
    <const zero, const one, const rest extends array, r = Type<inferTypeRoot<[zero, one, ...rest], $>, $>>(_0: zero extends IndexZeroOperator ? zero : validateTypeRoot<zero, $>, _1: zero extends "keyof" ? validateTypeRoot<one, $> : zero extends "instanceof" ? conform<one, Constructor> : zero extends "===" ? conform<one, unknown> : conform<one, IndexOneOperator>, ..._2: zero extends "===" ? rest : zero extends "instanceof" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends ":" ? [Predicate<distillIn<inferTypeRoot<zero, $>>>] : one extends "=>" ? [Morph<distillOut<inferTypeRoot<zero, $>>, unknown>] : one extends "@" ? [MetaSchema] : [validateTypeRoot<rest[0], $>] : []): r;
    raw(def: unknown): BaseType<any, $>;
    errors: typeof ArkErrors;
}
export declare class InternalTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {
    constructor($: InternalScope);
}
export type DeclarationParser<$> = <preinferred>() => {
    type: <const def>(def: validateDeclared<preinferred, def, $, bindThis<def>>) => Type<preinferred, $>;
};
export type DefinitionParser<$> = <def>(def: validateTypeRoot<def, $>) => def;
export type validateTypeRoot<def, $ = {}> = validateDefinition<def, $, bindThis<def>>;
export type inferTypeRoot<def, $> = inferDefinition<def, $, bindThis<def>>;
export type validateAmbient<def> = validateTypeRoot<def, {}>;
export type inferAmbient<def> = inferTypeRoot<def, {}>;
export type Type<t = unknown, $ = {}> = instantiateType<t, $>;
export declare namespace Type {
    type Any<t = any> = BaseType<t, any>;
}
export type TypeConstructor<t = unknown, $ = {}> = new (def: unknown, $: Scope<$>) => Type<t, $>;
export declare const Type: TypeConstructor;
