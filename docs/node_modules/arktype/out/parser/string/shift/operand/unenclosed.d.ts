import { BaseRoot, writeUnresolvableMessage, type GenericAst, type GenericRoot, type arkKind, type genericParamNames, type resolvableReferenceIn, type resolveReference, type writeNonSubmoduleDotMessage } from "@ark/schema";
import { type BigintLiteral, type Completion, type ErrorMessage, type anyOrNever, type join } from "@ark/util";
import type { Ark } from "../../../../ark.js";
import type { GenericInstantiationAst } from "../../../semantic/infer.js";
import type { DynamicState } from "../../reduce/dynamic.js";
import type { StaticState, state } from "../../reduce/static.js";
import type { BaseCompletions } from "../../string.js";
import type { Scanner } from "../scanner.js";
import { parseGenericArgs, writeInvalidGenericArgCountMessage, type ParsedArgs } from "./genericArgs.js";
export declare const parseUnenclosed: (s: DynamicState) => void;
export type parseUnenclosed<s extends StaticState, $, args> = Scanner.shiftUntilNextTerminator<s["unscanned"]> extends (Scanner.shiftResult<infer token, infer unscanned>) ? token extends "keyof" ? state.addPrefix<s, "keyof", unscanned> : tryResolve<s, token, $, args> extends infer result ? result extends ErrorMessage<infer message> ? state.error<message> : result extends resolvableReferenceIn<$> ? parseResolution<s, unscanned, result, resolveReference<result, $>, $, args> : result extends resolvableReferenceIn<Ark> ? parseResolution<s, unscanned, result, resolveReference<result, Ark>, $, args> : state.setRoot<s, result, unscanned> : never : never;
type parseResolution<s extends StaticState, unscanned extends string, alias extends string, resolution, $, args> = [
    resolution
] extends [anyOrNever] ? state.setRoot<s, alias, unscanned> : resolution extends GenericAst ? parseGenericInstantiation<alias, resolution, state.scanTo<s, unscanned>, $, args> : state.setRoot<s, alias, unscanned>;
export declare const parseGenericInstantiation: (name: string, g: GenericRoot, s: DynamicState) => BaseRoot;
export type parseGenericInstantiation<name extends string, g extends GenericAst, s extends StaticState, $, args> = Scanner.skipWhitespace<s["unscanned"]> extends `<${infer unscanned}` ? parseGenericArgs<name, g, unscanned, $, args> extends infer result ? result extends ParsedArgs<infer argAsts, infer nextUnscanned> ? state.setRoot<s, GenericInstantiationAst<g, argAsts>, nextUnscanned> : result : never : state.error<writeInvalidGenericArgCountMessage<name, genericParamNames<g["paramsAst"]>, [
]>>;
type tryResolve<s extends StaticState, token extends string, $, args> = token extends keyof Ark ? token : token extends keyof $ ? token : `#${token}` extends keyof $ ? token : token extends keyof args ? token : token extends `${number}` ? token : token extends BigintLiteral ? token : token extends (`${infer submodule extends (keyof $ | keyof Ark) & string}.${infer reference}`) ? tryResolveSubmodule<token, submodule, reference, s, $ & Ark, [submodule]> : unresolvableError<s, token, $, args, []>;
type tryResolveSubmodule<token, submodule extends keyof $ & string, reference extends string, s extends StaticState, $, submodulePath extends string[]> = $[submodule] extends {
    [arkKind]: "module";
} ? reference extends keyof $[submodule] ? token : reference extends (`${infer nestedSubmodule extends keyof $[submodule] & string}.${infer nestedReference}`) ? tryResolveSubmodule<token, nestedSubmodule, nestedReference, s, $[submodule], [
    ...submodulePath,
    nestedSubmodule
]> : unresolvableError<s, reference, $[submodule], {}, submodulePath> : ErrorMessage<writeNonSubmoduleDotMessage<submodule>>;
/** Provide valid completions for the current token, or fallback to an
 * unresolvable error if there are none */
export type unresolvableError<s extends StaticState, token extends string, $, args, submodulePath extends string[]> = validReferenceFromToken<token, $, args, submodulePath> extends never ? ErrorMessage<writeUnresolvableMessage<qualifiedReference<token, submodulePath>>> : Completion<`${s["scanned"]}${qualifiedReference<validReferenceFromToken<token, $, args, submodulePath>, submodulePath>}`>;
type qualifiedReference<reference extends string, submodulePath extends string[]> = join<[...submodulePath, reference], ".">;
type validReferenceFromToken<token extends string, $, args, submodulePath extends string[]> = Extract<submodulePath["length"] extends 0 ? BaseCompletions<$, args> : resolvableReferenceIn<$>, `${token}${string}`>;
export declare const writeMissingOperandMessage: (s: DynamicState) => string;
export type writeMissingRightOperandMessage<token extends string, unscanned extends string = ""> = `Token '${token}' requires a right operand${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export declare const writeMissingRightOperandMessage: <token extends string, unscanned extends string>(token: token, unscanned?: unscanned) => writeMissingRightOperandMessage<token, unscanned>;
export declare const writeExpressionExpectedMessage: <unscanned extends string>(unscanned: unscanned) => writeExpressionExpectedMessage<unscanned>;
export type writeExpressionExpectedMessage<unscanned extends string> = `Expected an expression${unscanned extends "" ? "" : ` before '${unscanned}'`}`;
export {};
