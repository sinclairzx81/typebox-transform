// src/error/flatten/flatten.ts
function flatten(error) {
  return error.issues.reduce(
    (flatErrors, issue) => {
      if (issue.path) {
        const path = issue.path.map(({ key }) => key).join(".");
        flatErrors.nested[path] = [
          ...flatErrors.nested[path] || [],
          issue.message
        ];
      } else {
        flatErrors.root = [...flatErrors.root || [], issue.message];
      }
      return flatErrors;
    },
    { nested: {} }
  );
}

// src/error/ValiError/ValiError.ts
var ValiError = class extends Error {
  issues;
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};

// src/methods/coerce/coerce.ts
function coerce(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return schema.parse(action(input), info);
    }
  };
}

// src/methods/coerce/coerceAsync.ts
function coerceAsync(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      return schema.parse(await action(input), info);
    }
  };
}

// src/utils/executePipe/executePipe.ts
function executePipe(input, pipe, info) {
  return pipe.reduce((value2, action) => action(value2, info), input);
}

// src/utils/executePipe/executePipeAsync.ts
async function executePipeAsync(input, pipe, info) {
  return pipe.reduce(
    async (value2, action) => action(await value2, info),
    Promise.resolve(input)
  );
}

// src/utils/getCurrentPath/getCurrentPath.ts
function getCurrentPath(info, item) {
  return [...info?.path || [], item];
}

// src/utils/getErrorAndPipe/getErrorAndPipe.ts
function getErrorAndPipe(arg1, arg2) {
  const [error, pipe = []] = !arg1 || typeof arg1 === "string" ? [arg1, arg2] : [void 0, arg1];
  return { error, pipe };
}

// src/schemas/any/any.ts
function any(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "any",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return executePipe(input, pipe, { ...info, reason: "any" });
    }
  };
}

// src/schemas/any/anyAsync.ts
function anyAsync(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "any",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      return executePipeAsync(input, pipe, { ...info, reason: "any" });
    }
  };
}

// src/schemas/array/array.ts
function array(item, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!Array.isArray(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "array",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = [];
      const issues = [];
      input.forEach((value2, index) => {
        try {
          output.push(
            item.parse(value2, {
              ...info,
              path: getCurrentPath(info, {
                schema: "array",
                input,
                key: index,
                value: value2
              })
            })
          );
        } catch (error2) {
          issues.push(...error2.issues);
        }
      });
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(output, pipe, {
        ...info,
        reason: "array"
      });
    }
  };
}

// src/schemas/array/arrayAsync.ts
function arrayAsync(item, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!Array.isArray(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "array",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = [];
      const issues = [];
      await Promise.all(
        input.map(async (value2, index) => {
          try {
            output[index] = await item.parse(value2, {
              ...info,
              path: getCurrentPath(info, {
                schema: "array",
                input,
                key: index,
                value: value2
              })
            });
          } catch (error2) {
            issues.push(...error2.issues);
          }
        })
      );
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(output, pipe, {
        ...info,
        reason: "array"
      });
    }
  };
}

// src/schemas/bigint/bigint.ts
function bigint(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "bigint",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "bigint") {
        throw new ValiError([
          {
            reason: "type",
            validation: "bigint",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "bigint" });
    }
  };
}

// src/schemas/bigint/bigintAsync.ts
function bigintAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "bigint",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "bigint") {
        throw new ValiError([
          {
            reason: "type",
            validation: "bigint",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "bigint" });
    }
  };
}

// src/schemas/blob/blob.ts
function blob(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "blob",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!(input instanceof Blob)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "blob",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "blob" });
    }
  };
}

// src/schemas/blob/blobAsync.ts
function blobAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "blob",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!(input instanceof Blob)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "blob",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "blob" });
    }
  };
}

// src/schemas/boolean/boolean.ts
function boolean(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "boolean") {
        throw new ValiError([
          {
            reason: "type",
            validation: "boolean",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "boolean" });
    }
  };
}

// src/schemas/boolean/booleanAsync.ts
function booleanAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "boolean") {
        throw new ValiError([
          {
            reason: "type",
            validation: "boolean",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "boolean" });
    }
  };
}

// src/schemas/date/date.ts
function date(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "date",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!(input instanceof Date)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "date",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "date" });
    }
  };
}

// src/schemas/date/dateAsync.ts
function dateAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "date",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!(input instanceof Date)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "date",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "date" });
    }
  };
}

// src/schemas/enumType/enumType.ts
function enumType(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!enumValue.includes(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "enum",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/enumType/enumTypeAsync.ts
function enumTypeAsync(enumValue, error) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!enumValue.includes(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "enum",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/instance/instance.ts
function instance(of, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "instance",
    /**
     * The class of the instance.
     */
    class: of,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!(input instanceof of)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "instance",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, {
        ...info,
        reason: "instance"
      });
    }
  };
}

// src/schemas/instance/instanceAsync.ts
function instanceAsync(of, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "instance",
    /**
     * The class of the instance.
     */
    class: of,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!(input instanceof of)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "instance",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, {
        ...info,
        reason: "instance"
      });
    }
  };
}

// src/schemas/literal/literal.ts
function literal(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input !== literal2) {
        throw new ValiError([
          {
            reason: "type",
            validation: "literal",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/literal/literalAsync.ts
function literalAsync(literal2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input !== literal2) {
        throw new ValiError([
          {
            reason: "type",
            validation: "literal",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/map/map.ts
function map(key, value2, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "map",
    /**
     * The map key and value schema.
     */
    map: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!(input instanceof Map)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "map",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = /* @__PURE__ */ new Map();
      const issues = [];
      for (const [inputKey, inputValue] of input.entries()) {
        const path = getCurrentPath(info, {
          schema: "map",
          input,
          key: inputKey,
          value: inputValue
        });
        let outputKey;
        try {
          outputKey = [key.parse(inputKey, { ...info, origin: "key", path })];
        } catch (error2) {
          issues.push(...error2.issues);
        }
        let outputValue;
        try {
          outputValue = [value2.parse(inputValue, { ...info, path })];
        } catch (error2) {
          issues.push(...error2.issues);
        }
        if (outputKey && outputValue) {
          output.set(outputKey[0], outputValue[0]);
        }
      }
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(output, pipe, { ...info, reason: "map" });
    }
  };
}

// src/schemas/map/mapAsync.ts
function mapAsync(key, value2, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return {
    /**
     * The schema type.
     */
    schema: "map",
    /**
     * The map key and value schema.
     */
    map: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!(input instanceof Map)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "map",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = /* @__PURE__ */ new Map();
      const issues = [];
      await Promise.all(
        Array.from(input.entries()).map(async ([inputKey, inputValue]) => {
          const path = getCurrentPath(info, {
            schema: "map",
            input,
            key: inputKey,
            value: inputValue
          });
          const [outputKey, outputValue] = await Promise.all([
            // Parse key and get output
            (async () => {
              try {
                return [
                  await key.parse(inputKey, { ...info, origin: "key", path })
                ];
              } catch (error2) {
                issues.push(...error2.issues);
              }
            })(),
            // Parse value and get output
            (async () => {
              try {
                return [
                  await value2.parse(inputValue, { ...info, path })
                ];
              } catch (error2) {
                issues.push(...error2.issues);
              }
            })()
          ]);
          if (outputKey && outputValue) {
            output.set(outputKey[0], outputValue[0]);
          }
        })
      );
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(output, pipe, { ...info, reason: "map" });
    }
  };
}

// src/schemas/nan/nan.ts
function nan(error) {
  return {
    /**
     * The schema type.
     */
    schema: "nan",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!Number.isNaN(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "nan",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/nan/nanAsync.ts
function nanAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "nan",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!Number.isNaN(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "nan",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/nativeEnum/nativeEnum.ts
function nativeEnum(nativeEnum2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "native_enum",
    /**
     * The native enum value.
     */
    nativeEnum: nativeEnum2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!Object.values(nativeEnum2).includes(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "native_enum",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/nativeEnum/nativeEnumAsync.ts
function nativeEnumAsync(nativeEnum2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "native_enum",
    /**
     * The native enum value.
     */
    nativeEnum: nativeEnum2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!Object.values(nativeEnum2).includes(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "native_enum",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/never/never.ts
function never(error) {
  return {
    /**
     * The schema type.
     */
    schema: "never",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      throw new ValiError([
        {
          reason: "type",
          validation: "never",
          origin: "value",
          message: error || "Invalid type",
          input,
          ...info
        }
      ]);
    }
  };
}

// src/schemas/never/neverAsync.ts
function neverAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "never",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      throw new ValiError([
        {
          reason: "type",
          validation: "never",
          origin: "value",
          message: error || "Invalid type",
          input,
          ...info
        }
      ]);
    }
  };
}

// src/schemas/nonNullable/nonNullable.ts
function nonNullable(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === null) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_nullable",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nonNullable/nonNullableAsync.ts
function nonNullableAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === null) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_nullable",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nonNullish/nonNullish.ts
function nonNullish(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === null || input === void 0) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_nullish",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nonNullish/nonNullishAsync.ts
function nonNullishAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === null || input === void 0) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_nullish",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nonOptional/nonOptional.ts
function nonOptional(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === void 0) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_optional",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nonOptional/nonOptionalAsync.ts
function nonOptionalAsync(wrapped, error) {
  return {
    /**
     * The schema type.
     */
    schema: "non_optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === void 0) {
        throw new ValiError([
          {
            reason: "type",
            validation: "non_optional",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nullable/nullable.ts
function nullable(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === null) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nullable/nullableAsync.ts
function nullableAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullable",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === null) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nullish/nullish.ts
function nullish(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === null || input === void 0) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nullish/nullishAsync.ts
function nullishAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "nullish",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === null || input === void 0) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/nullType/nullType.ts
function nullType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "null",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input !== null) {
        throw new ValiError([
          {
            reason: "type",
            validation: "null",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/nullType/nullTypeAsync.ts
function nullTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "null",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input !== null) {
        throw new ValiError([
          {
            reason: "type",
            validation: "null",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/number/number.ts
function number(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "number") {
        throw new ValiError([
          {
            reason: "type",
            validation: "number",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "number" });
    }
  };
}

// src/schemas/number/numberAsync.ts
function numberAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "number") {
        throw new ValiError([
          {
            reason: "type",
            validation: "number",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "number" });
    }
  };
}

// src/schemas/object/object.ts
function object(object2, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!input || typeof input !== "object" || input.toString() !== "[object Object]") {
        throw new ValiError([
          {
            reason: "type",
            validation: "object",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = {};
      const issues = [];
      Object.entries(object2).forEach(([key, schema]) => {
        try {
          const value2 = input[key];
          output[key] = schema.parse(value2, {
            ...info,
            path: getCurrentPath(info, { schema: "object", input, key, value: value2 })
          });
        } catch (error2) {
          issues.push(...error2.issues);
        }
      });
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(output, pipe, {
        ...info,
        reason: "object"
      });
    }
  };
}

// src/schemas/object/objectAsync.ts
function objectAsync(object2, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!input || typeof input !== "object" || input.toString() !== "[object Object]") {
        throw new ValiError([
          {
            reason: "type",
            validation: "object",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = {};
      const issues = [];
      await Promise.all(
        Object.entries(object2).map(async ([key, schema]) => {
          try {
            const value2 = input[key];
            output[key] = await schema.parse(value2, {
              ...info,
              path: getCurrentPath(info, {
                schema: "object",
                input,
                key,
                value: value2
              })
            });
          } catch (error2) {
            issues.push(...error2.issues);
          }
        })
      );
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(output, pipe, {
        ...info,
        reason: "object"
      });
    }
  };
}

// src/schemas/optional/optional.ts
function optional(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (input === void 0) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/optional/optionalAsync.ts
function optionalAsync(wrapped) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (input === void 0) {
        return input;
      }
      return wrapped.parse(input, info);
    }
  };
}

// src/schemas/string/string.ts
function string(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "string") {
        throw new ValiError([
          {
            reason: "type",
            validation: "string",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "string" });
    }
  };
}

// src/schemas/string/stringAsync.ts
function stringAsync(arg1, arg2) {
  const { error, pipe } = getErrorAndPipe(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "string") {
        throw new ValiError([
          {
            reason: "type",
            validation: "string",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, { ...info, reason: "string" });
    }
  };
}

// src/schemas/record/record.ts
function record(arg1, arg2, arg3, arg4) {
  const { key, value: value2, error, pipe } = typeof arg2 === "object" && !Array.isArray(arg2) ? { key: arg1, value: arg2, ...getErrorAndPipe(arg3, arg4) } : { key: string(), value: arg1, ...getErrorAndPipe(arg2, arg3) };
  return {
    /**
     * The schema type.
     */
    schema: "record",
    /**
     * The record key and value schema.
     */
    record: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!input || typeof input !== "object" || input.toString() !== "[object Object]") {
        throw new ValiError([
          {
            reason: "type",
            validation: "record",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = {};
      const issues = [];
      Object.entries(input).forEach(([inputKey, inputValue]) => {
        const path = getCurrentPath(info, {
          schema: "record",
          input,
          key: inputKey,
          value: inputValue
        });
        let outputKey;
        try {
          outputKey = key.parse(inputKey, { ...info, origin: "key", path });
        } catch (error2) {
          issues.push(...error2.issues);
        }
        let outputValue;
        try {
          outputValue = [value2.parse(inputValue, { ...info, path })];
        } catch (error2) {
          issues.push(...error2.issues);
        }
        if (outputKey && outputValue) {
          output[outputKey] = outputValue[0];
        }
      });
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(
        output,
        pipe,
        { ...info, reason: "record" }
      );
    }
  };
}

// src/schemas/record/recordAsync.ts
function recordAsync(arg1, arg2, arg3, arg4) {
  const { key, value: value2, error, pipe } = typeof arg2 === "object" && !Array.isArray(arg2) ? { key: arg1, value: arg2, ...getErrorAndPipe(arg3, arg4) } : { key: string(), value: arg1, ...getErrorAndPipe(arg2, arg3) };
  return {
    /**
     * The schema type.
     */
    schema: "record",
    /**
     * The record key and value schema.
     */
    record: { key, value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!input || typeof input !== "object" || input.toString() !== "[object Object]") {
        throw new ValiError([
          {
            reason: "type",
            validation: "record",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = {};
      const issues = [];
      await Promise.all(
        // Note: `Object.entries(...)` converts each key to a string
        Object.entries(input).map(async ([inputKey, inputValue]) => {
          const path = getCurrentPath(info, {
            schema: "record",
            input,
            key: inputKey,
            value: inputValue
          });
          const [outputKey, outputValue] = await Promise.all([
            // Parse key and get output
            (async () => {
              try {
                return await key.parse(inputKey, {
                  ...info,
                  origin: "key",
                  path
                });
              } catch (error2) {
                issues.push(...error2.issues);
              }
            })(),
            // Parse value and get output
            (async () => {
              try {
                return [
                  await value2.parse(inputValue, { ...info, path })
                ];
              } catch (error2) {
                issues.push(...error2.issues);
              }
            })()
          ]);
          if (outputKey && outputValue) {
            output[outputKey] = outputValue[0];
          }
        })
      );
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(
        output,
        pipe,
        { ...info, reason: "record" }
      );
    }
  };
}

// src/schemas/recursive/recursive.ts
function recursive(getter) {
  return {
    /**
     * The schema type.
     */
    schema: "recursive",
    /**
     * The schema getter.
     */
    getter,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return getter().parse(input, info);
    }
  };
}

// src/schemas/recursive/recursiveAsync.ts
function recursiveAsync(getter) {
  return {
    /**
     * The schema type.
     */
    schema: "recursive",
    /**
     * The schema getter.
     */
    getter,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      return getter().parse(input, info);
    }
  };
}

// src/schemas/set/set.ts
function set(value2, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "set",
    /**
     * The set value schema.
     */
    set: { value: value2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!(input instanceof Set)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "set",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      let index = 0;
      const output = /* @__PURE__ */ new Set();
      const issues = [];
      for (const inputValue of input) {
        try {
          output.add(
            value2.parse(inputValue, {
              ...info,
              path: getCurrentPath(info, {
                schema: "set",
                input,
                key: index++,
                value: inputValue
              })
            })
          );
        } catch (error2) {
          issues.push(...error2.issues);
        }
      }
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(output, pipe, { ...info, reason: "set" });
    }
  };
}

// src/schemas/set/setAsync.ts
function setAsync(value2, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "set",
    /**
     * The set value schema.
     */
    set: { value: value2 },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!(input instanceof Set)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "set",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = /* @__PURE__ */ new Set();
      const issues = [];
      await Promise.all(
        Array.from(input.values()).map(async (inputValue, index) => {
          try {
            output.add(
              await value2.parse(inputValue, {
                ...info,
                path: getCurrentPath(info, {
                  schema: "set",
                  input,
                  key: index,
                  value: inputValue
                })
              })
            );
          } catch (error2) {
            issues.push(...error2.issues);
          }
        })
      );
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(output, pipe, { ...info, reason: "set" });
    }
  };
}

// src/schemas/special/special.ts
function special(check, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "special",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!check(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "special",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipe(input, pipe, { ...info, reason: "special" });
    }
  };
}

// src/schemas/special/specialAsync.ts
function specialAsync(check, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "special",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!await check(input)) {
        throw new ValiError([
          {
            reason: "type",
            validation: "special",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return executePipeAsync(input, pipe, {
        ...info,
        reason: "special"
      });
    }
  };
}

// src/schemas/symbol/symbol.ts
function symbol(error) {
  return {
    /**
     * The schema type.
     */
    schema: "symbol",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "symbol") {
        throw new ValiError([
          {
            reason: "type",
            validation: "symbol",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/symbol/symbolAsync.ts
function symbolAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "symbol",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "symbol") {
        throw new ValiError([
          {
            reason: "type",
            validation: "symbol",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/tuple/tuple.ts
function tuple(items, arg2, arg3, arg4) {
  const { rest, error, pipe } = typeof arg2 === "object" && !Array.isArray(arg2) ? { rest: arg2, ...getErrorAndPipe(arg3, arg4) } : getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "tuple",
    /**
     * The tuple items and rest schema.
     */
    tuple: { items, rest },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
        throw new ValiError([
          {
            reason: "type",
            validation: "tuple",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = [];
      const issues = [];
      items.forEach((schema, index) => {
        try {
          const value2 = input[index];
          output[index] = schema.parse(value2, {
            ...info,
            path: getCurrentPath(info, {
              schema: "tuple",
              input,
              key: index,
              value: value2
            })
          });
        } catch (error2) {
          issues.push(...error2.issues);
        }
      });
      if (rest) {
        input.slice(items.length).forEach((value2, index) => {
          try {
            const tupleIndex = items.length + index;
            output[tupleIndex] = rest.parse(value2, {
              ...info,
              path: getCurrentPath(info, {
                schema: "tuple",
                input,
                key: tupleIndex,
                value: value2
              })
            });
          } catch (error2) {
            issues.push(...error2.issues);
          }
        });
      }
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipe(output, pipe, {
        ...info,
        reason: "tuple"
      });
    }
  };
}

// src/schemas/tuple/tupleAsync.ts
function tupleAsync(items, arg2, arg3, arg4) {
  const { rest, error, pipe } = typeof arg2 === "object" && !Array.isArray(arg2) ? { rest: arg2, ...getErrorAndPipe(arg3, arg4) } : getErrorAndPipe(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "tuple",
    /**
     * The tuple items and rest schema.
     */
    tuple: { items, rest },
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (!Array.isArray(input) || !rest && items.length !== input.length || rest && items.length > input.length) {
        throw new ValiError([
          {
            reason: "type",
            validation: "tuple",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      const output = [];
      const issues = [];
      await Promise.all([
        // Parse schema of each tuple item
        Promise.all(
          items.map(async (schema, index) => {
            try {
              const value2 = input[index];
              output[index] = await schema.parse(value2, {
                ...info,
                path: getCurrentPath(info, {
                  schema: "tuple",
                  input,
                  key: index,
                  value: value2
                })
              });
            } catch (error2) {
              issues.push(...error2.issues);
            }
          })
        ),
        // If necessary parse schema of each rest item
        rest && Promise.all(
          input.slice(items.length).map(async (value2, index) => {
            try {
              const tupleIndex = items.length + index;
              output[tupleIndex] = await rest.parse(value2, {
                ...info,
                path: getCurrentPath(info, {
                  schema: "tuple",
                  input,
                  key: tupleIndex,
                  value: value2
                })
              });
            } catch (error2) {
              issues.push(...error2.issues);
            }
          })
        )
      ]);
      if (issues.length) {
        throw new ValiError(issues);
      }
      return executePipeAsync(
        output,
        pipe,
        {
          ...info,
          reason: "tuple"
        }
      );
    }
  };
}

// src/schemas/undefinedType/undefinedType.ts
function undefinedType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "undefined",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "undefined") {
        throw new ValiError([
          {
            reason: "type",
            validation: "undefined",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/undefinedType/undefinedTypeAsync.ts
function undefinedTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "undefined",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "undefined") {
        throw new ValiError([
          {
            reason: "type",
            validation: "undefined",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/union/union.ts
function union(union2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      let output;
      const issues = [];
      for (const schema of union2) {
        try {
          output = [schema.parse(input, info)];
          break;
        } catch (error2) {
          issues.push(...error2.issues);
        }
      }
      if (!output) {
        throw new ValiError([
          {
            reason: "type",
            validation: "union",
            origin: "value",
            message: error || "Invalid type",
            input,
            issues,
            ...info
          }
        ]);
      }
      return output[0];
    }
  };
}

// src/schemas/union/unionAsync.ts
function unionAsync(union2, error) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union2,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      let output;
      const issues = [];
      for (const schema of union2) {
        try {
          output = [await schema.parse(input, info)];
          break;
        } catch (error2) {
          issues.push(...error2.issues);
        }
      }
      if (!output) {
        throw new ValiError([
          {
            reason: "type",
            validation: "union",
            origin: "value",
            message: error || "Invalid type",
            input,
            issues,
            ...info
          }
        ]);
      }
      return output[0];
    }
  };
}

// src/schemas/unknown/unknown.ts
function unknown(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return executePipe(input, pipe, { ...info, reason: "unknown" });
    }
  };
}

// src/schemas/unknown/unknownAsync.ts
function unknownAsync(pipe = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      return executePipeAsync(input, pipe, { ...info, reason: "unknown" });
    }
  };
}

// src/schemas/voidType/voidType.ts
function voidType(error) {
  return {
    /**
     * The schema type.
     */
    schema: "void",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      if (typeof input !== "undefined") {
        throw new ValiError([
          {
            reason: "type",
            validation: "void",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/schemas/voidType/voidTypeAsync.ts
function voidTypeAsync(error) {
  return {
    /**
     * The schema type.
     */
    schema: "void",
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      if (typeof input !== "undefined") {
        throw new ValiError([
          {
            reason: "type",
            validation: "void",
            origin: "value",
            message: error || "Invalid type",
            input,
            ...info
          }
        ]);
      }
      return input;
    }
  };
}

// src/methods/keyof/keyof.ts
function keyof(schema) {
  return enumType(
    Object.keys(schema.object)
  );
}

// src/methods/merge/merge.ts
function merge(schemas, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return object(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/merge/mergeAsync.ts
function mergeAsync(schemas, arg2, arg3) {
  const { error, pipe } = getErrorAndPipe(arg2, arg3);
  return objectAsync(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/omit/omit.ts
function omit(schema, keys, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? object2 : { ...object2, [key]: schema2 },
      {}
    ),
    error,
    pipe
  );
}

// src/methods/omit/omitAsync.ts
function omitAsync(schema, keys, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? object2 : { ...object2, [key]: schema2 },
      {}
    ),
    error,
    pipe
  );
}

// src/methods/parse/parse.ts
function parse(schema, input) {
  return schema.parse(input);
}

// src/methods/parse/parseAsync.ts
async function parseAsync(schema, input) {
  return schema.parse(input);
}

// src/methods/partial/partial.ts
function partial(schema, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: optional(schema2)
      }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/partial/partialAsync.ts
function partialAsync(schema, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: optionalAsync(schema2)
      }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/pick/pick.ts
function pick(schema, keys, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? { ...object2, [key]: schema2 } : object2,
      {}
    ),
    error,
    pipe
  );
}

// src/methods/pick/pickAsync.ts
function pickAsync(schema, keys, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => keys.includes(key) ? { ...object2, [key]: schema2 } : object2,
      {}
    ),
    error,
    pipe
  );
}

// src/methods/required/required.ts
function required(schema, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return object(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: nonOptional(schema2)
      }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/required/requiredAsync.ts
function requiredAsync(schema, arg3, arg4) {
  const { error, pipe } = getErrorAndPipe(arg3, arg4);
  return objectAsync(
    Object.entries(schema.object).reduce(
      (object2, [key, schema2]) => ({
        ...object2,
        [key]: nonOptionalAsync(schema2)
      }),
      {}
    ),
    error,
    pipe
  );
}

// src/methods/safeParse/safeParse.ts
function safeParse(schema, input) {
  try {
    return {
      success: true,
      data: schema.parse(input)
    };
  } catch (error) {
    return {
      success: false,
      error
    };
  }
}

// src/methods/safeParse/safeParseAsync.ts
async function safeParseAsync(schema, input) {
  try {
    return {
      success: true,
      data: await schema.parse(input)
    };
  } catch (error) {
    return {
      success: false,
      error
    };
  }
}

// src/methods/transform/transform.ts
function transform(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return action(schema.parse(input, info));
    }
  };
}

// src/methods/transform/transformAsync.ts
function transformAsync(schema, action) {
  return {
    ...schema,
    /**
     * Whether it's async.
     */
    async: true,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    async parse(input, info) {
      return action(await schema.parse(input, info));
    }
  };
}

// src/methods/unwrap/unwrap.ts
function unwrap(schema) {
  return schema.wrapped;
}

// src/methods/useDefault/useDefault.ts
function useDefault(schema, value2) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    parse(input, info) {
      return schema.parse(input === void 0 ? value2 : input, info);
    }
  };
}

// src/transformations/toCustom/toCustom.ts
function toCustom(action) {
  return (input) => action(input);
}

// src/transformations/toCustom/toCustomAsync.ts
function toCustomAsync(action) {
  return (input) => action(input);
}

// src/transformations/toLowerCase/toLowerCase.ts
function toLowerCase() {
  return (input) => input.toLocaleLowerCase();
}

// src/transformations/toTrimmed/toTrimmed.ts
function toTrimmed() {
  return (input) => input.trim();
}

// src/transformations/toTrimmedEnd/toTrimmedEnd.ts
function toTrimmedEnd() {
  return (input) => input.trimEnd();
}

// src/transformations/toTrimmedStart/toTrimmedStart.ts
function toTrimmedStart() {
  return (input) => input.trimStart();
}

// src/transformations/toUpperCase/toUpperCase.ts
function toUpperCase() {
  return (input) => input.toUpperCase();
}

// src/validations/bytes/bytes.ts
function bytes(requirement, error) {
  return (input, info) => {
    if (new TextEncoder().encode(input).length !== requirement) {
      throw new ValiError([
        {
          validation: "bytes",
          origin: "value",
          message: error || "Invalid byte length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/custom/custom.ts
function custom(requirement, error) {
  return (input, info) => {
    if (!requirement(input)) {
      throw new ValiError([
        {
          validation: "custom",
          origin: "value",
          message: error || "Invalid input",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/custom/customAsync.ts
function customAsync(requirement, error) {
  return async (input, info) => {
    if (!await requirement(input)) {
      throw new ValiError([
        {
          validation: "custom",
          origin: "value",
          message: error || "Invalid input",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/email/email.ts
function email(error) {
  return (input, info) => {
    if (!/^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@(([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{2,})$/i.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "email",
          origin: "value",
          message: error || "Invalid email",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/emoji/emoji.ts
function emoji(error) {
  return (input, info) => {
    if (!/^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u.test(input)) {
      throw new ValiError([
        {
          validation: "emoji",
          origin: "value",
          message: error || "Invalid emoji",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/endsWith/endsWith.ts
function endsWith(requirement, error) {
  return (input, info) => {
    if (!input.endsWith(requirement)) {
      throw new ValiError([
        {
          validation: "ends_with",
          origin: "value",
          message: error || "Invalid end",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/equal/equal.ts
function equal(requirement, error) {
  return (input, info) => {
    if (input !== requirement) {
      throw new ValiError([
        {
          validation: "equal",
          origin: "value",
          message: error || "Invalid input",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/includes/includes.ts
function includes(requirement, error) {
  return (input, info) => {
    if (!input.includes(requirement)) {
      throw new ValiError([
        {
          validation: "includes",
          origin: "value",
          message: error || "Invalid content",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/ip/ip.ts
function ip(error) {
  return (input, info) => {
    if (!/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input) && !/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "ip",
          origin: "value",
          message: error || "Invalid IP",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/ipv4/ipv4.ts
function ipv4(error) {
  return (input, info) => {
    if (!/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$/.test(input)) {
      throw new ValiError([
        {
          validation: "ipv4",
          origin: "value",
          message: error || "Invalid IP v4",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/ipv6/ipv6.ts
function ipv6(error) {
  return (input, info) => {
    if (!/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "ipv6",
          origin: "value",
          message: error || "Invalid IP v6",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoDate/isoDate.ts
function isoDate(error) {
  return (input, info) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])$/.test(input)) {
      throw new ValiError([
        {
          validation: "iso_date",
          origin: "value",
          message: error || "Invalid date",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoDateTime/isoDateTime.ts
function isoDateTime(error) {
  return (input, info) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[1-9]|1\d|2[0-3]):[0-5]\d$/.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "iso_date_time",
          origin: "value",
          message: error || "Invalid datetime",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoTime/isoTime.ts
function isoTime(error) {
  return (input, info) => {
    if (!/^(0[1-9]|1\d|2[0-3]):[0-5]\d$/.test(input)) {
      throw new ValiError([
        {
          validation: "iso_time",
          origin: "value",
          message: error || "Invalid time",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoTimeSecond/isoTimeSecond.ts
function isoTimeSecond(error) {
  return (input, info) => {
    if (!/^(0[1-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(input)) {
      throw new ValiError([
        {
          validation: "iso_time_second",
          origin: "value",
          message: error || "Invalid time",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoTimestamp/isoTimestamp.ts
function isoTimestamp(error) {
  return (input, info) => {
    if (!/^\d{4}-(0[1-9]|1[0-2])-([12]\d|0[1-9]|3[01])T(0[1-9]|1\d|2[0-3]):[0-5]\d:[0-5]\d\.\d{3}Z$/.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "iso_timestamp",
          origin: "value",
          message: error || "Invalid timestamp",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/isoWeek/isoWeek.ts
function isoWeek(error) {
  return (input, info) => {
    if (!/^\d{4}-W(0[1-9]|[1-4]\d|5[0-3])$/.test(input)) {
      throw new ValiError([
        {
          validation: "iso_week",
          origin: "value",
          message: error || "Invalid week",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/length/length.ts
function length(requirement, error) {
  return (input, info) => {
    if (input.length !== requirement) {
      throw new ValiError([
        {
          validation: "length",
          origin: "value",
          message: error || "Invalid length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/maxBytes/maxBytes.ts
function maxBytes(requirement, error) {
  return (input, info) => {
    if (new TextEncoder().encode(input).length > requirement) {
      throw new ValiError([
        {
          validation: "max_bytes",
          origin: "value",
          message: error || "Invalid byte length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/maxLength/maxLength.ts
function maxLength(requirement, error) {
  return (input, info) => {
    if (input.length > requirement) {
      throw new ValiError([
        {
          validation: "max_length",
          origin: "value",
          message: error || "Invalid length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/maxSize/maxSize.ts
function maxSize(requirement, error) {
  return (input, info) => {
    if (input.size > requirement) {
      throw new ValiError([
        {
          validation: "max_size",
          origin: "value",
          message: error || "Invalid size",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/maxValue/maxValue.ts
function maxValue(requirement, error) {
  return (input, info) => {
    if (input > requirement) {
      throw new ValiError([
        {
          validation: "max_value",
          origin: "value",
          message: error || "Invalid value",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}
var maxRange = maxValue;

// src/validations/minBytes/minBytes.ts
function minBytes(requirement, error) {
  return (input, info) => {
    if (new TextEncoder().encode(input).length < requirement) {
      throw new ValiError([
        {
          validation: "min_bytes",
          origin: "value",
          message: error || "Invalid byte length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/mimeType/mimeType.ts
function mimeType(requirement, error) {
  return (input, info) => {
    if (!requirement.includes(input.type)) {
      throw new ValiError([
        {
          validation: "mime_type",
          origin: "value",
          message: error || "Invalid MIME type",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/minLength/minLength.ts
function minLength(requirement, error) {
  return (input, info) => {
    if (input.length < requirement) {
      throw new ValiError([
        {
          validation: "min_length",
          origin: "value",
          message: error || "Invalid length",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/minSize/minSize.ts
function minSize(requirement, error) {
  return (input, info) => {
    if (input.size < requirement) {
      throw new ValiError([
        {
          validation: "min_size",
          origin: "value",
          message: error || "Invalid size",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/minValue/minValue.ts
function minValue(requirement, error) {
  return (input, info) => {
    if (input < requirement) {
      throw new ValiError([
        {
          validation: "min_value",
          origin: "value",
          message: error || "Invalid value",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}
var minRange = minValue;

// src/validations/regex/regex.ts
function regex(requirement, error) {
  return (input, info) => {
    if (!requirement.test(input)) {
      throw new ValiError([
        {
          validation: "regex",
          origin: "value",
          message: error || "Invalid regex",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/size/size.ts
function size(requirement, error) {
  return (input, info) => {
    if (input.size !== requirement) {
      throw new ValiError([
        {
          validation: "size",
          origin: "value",
          message: error || "Invalid size",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/startsWith/startsWith.ts
function startsWith(requirement, error) {
  return (input, info) => {
    if (!input.startsWith(requirement)) {
      throw new ValiError([
        {
          validation: "starts_with",
          origin: "value",
          message: error || "Invalid start",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/url/url.ts
function url(error) {
  return (input, info) => {
    try {
      new URL(input);
      return input;
    } catch (_) {
      throw new ValiError([
        {
          validation: "url",
          origin: "value",
          message: error || "Invalid URL",
          input,
          ...info
        }
      ]);
    }
  };
}

// src/validations/uuid/uuid.ts
function uuid(error) {
  return (input, info) => {
    if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
      input
    )) {
      throw new ValiError([
        {
          validation: "uuid",
          origin: "value",
          message: error || "Invalid UUID",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}

// src/validations/value/value.ts
function value(requirement, error) {
  return (input, info) => {
    if (input !== requirement) {
      throw new ValiError([
        {
          validation: "value",
          origin: "value",
          message: error || "Invalid value",
          input,
          ...info
        }
      ]);
    }
    return input;
  };
}
export {
  ValiError,
  any,
  anyAsync,
  array,
  arrayAsync,
  bigint,
  bigintAsync,
  blob,
  blobAsync,
  boolean,
  booleanAsync,
  bytes,
  coerce,
  coerceAsync,
  custom,
  customAsync,
  date,
  dateAsync,
  email,
  emoji,
  endsWith,
  enumType,
  enumTypeAsync,
  equal,
  executePipe,
  executePipeAsync,
  flatten,
  getCurrentPath,
  getErrorAndPipe,
  includes,
  instance,
  instanceAsync,
  ip,
  ipv4,
  ipv6,
  isoDate,
  isoDateTime,
  isoTime,
  isoTimeSecond,
  isoTimestamp,
  isoWeek,
  keyof,
  length,
  literal,
  literalAsync,
  map,
  mapAsync,
  maxBytes,
  maxLength,
  maxRange,
  maxSize,
  maxValue,
  merge,
  mergeAsync,
  mimeType,
  minBytes,
  minLength,
  minRange,
  minSize,
  minValue,
  nan,
  nanAsync,
  nativeEnum,
  nativeEnumAsync,
  never,
  neverAsync,
  nonNullable,
  nonNullableAsync,
  nonNullish,
  nonNullishAsync,
  nonOptional,
  nonOptionalAsync,
  nullType,
  nullTypeAsync,
  nullable,
  nullableAsync,
  nullish,
  nullishAsync,
  number,
  numberAsync,
  object,
  objectAsync,
  omit,
  omitAsync,
  optional,
  optionalAsync,
  parse,
  parseAsync,
  partial,
  partialAsync,
  pick,
  pickAsync,
  record,
  recordAsync,
  recursive,
  recursiveAsync,
  regex,
  required,
  requiredAsync,
  safeParse,
  safeParseAsync,
  set,
  setAsync,
  size,
  special,
  specialAsync,
  startsWith,
  string,
  stringAsync,
  symbol,
  symbolAsync,
  toCustom,
  toCustomAsync,
  toLowerCase,
  toTrimmed,
  toTrimmedEnd,
  toTrimmedStart,
  toUpperCase,
  transform,
  transformAsync,
  tuple,
  tupleAsync,
  undefinedType,
  undefinedTypeAsync,
  union,
  unionAsync,
  unknown,
  unknownAsync,
  unwrap,
  url,
  useDefault,
  uuid,
  value,
  voidType,
  voidTypeAsync
};
