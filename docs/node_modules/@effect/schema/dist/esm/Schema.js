/**
 * @since 1.0.0
 */
import * as array_ from "effect/Array";
import * as bigDecimal_ from "effect/BigDecimal";
import * as bigInt_ from "effect/BigInt";
import * as boolean_ from "effect/Boolean";
import * as brand_ from "effect/Brand";
import * as cause_ from "effect/Cause";
import * as chunk_ from "effect/Chunk";
import * as data_ from "effect/Data";
import * as duration_ from "effect/Duration";
import * as Effect from "effect/Effect";
import * as either_ from "effect/Either";
import * as Encoding from "effect/Encoding";
import * as Equal from "effect/Equal";
import * as Equivalence from "effect/Equivalence";
import * as exit_ from "effect/Exit";
import * as fiberId_ from "effect/FiberId";
import { dual, identity } from "effect/Function";
import * as hashMap_ from "effect/HashMap";
import * as hashSet_ from "effect/HashSet";
import * as list_ from "effect/List";
import * as number_ from "effect/Number";
import * as option_ from "effect/Option";
import { pipeArguments } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Request from "effect/Request";
import * as secret_ from "effect/Secret";
import * as sortedSet_ from "effect/SortedSet";
import * as string_ from "effect/String";
import * as arbitrary_ from "./Arbitrary.js";
import * as AST from "./AST.js";
import * as equivalence_ from "./Equivalence.js";
import * as errors_ from "./internal/errors.js";
import * as filters_ from "./internal/filters.js";
import * as serializable_ from "./internal/serializable.js";
import * as util_ from "./internal/util.js";
import * as ParseResult from "./ParseResult.js";
import * as pretty_ from "./Pretty.js";
import * as TreeFormatter from "./TreeFormatter.js";
/**
 * @since 1.0.0
 * @category symbol
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/schema/Schema");
const variance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _I: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const toASTAnnotations = annotations => {
  if (!annotations) {
    return {};
  }
  const out = {};
  // symbols are reserved for custom annotations
  const custom = Object.getOwnPropertySymbols(annotations);
  for (const sym of custom) {
    out[sym] = annotations[sym];
  }
  // string keys are reserved as /schema namespace
  if (annotations.typeId !== undefined) {
    const typeId = annotations.typeId;
    if (typeof typeId === "object") {
      out[AST.TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[AST.TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations[from] !== undefined) {
      out[to] = annotations[from];
    }
  };
  move("message", AST.MessageAnnotationId);
  move("identifier", AST.IdentifierAnnotationId);
  move("title", AST.TitleAnnotationId);
  move("description", AST.DescriptionAnnotationId);
  move("examples", AST.ExamplesAnnotationId);
  move("default", AST.DefaultAnnotationId);
  move("documentation", AST.DocumentationAnnotationId);
  move("jsonSchema", AST.JSONSchemaAnnotationId);
  move("arbitrary", arbitrary_.ArbitraryHookId);
  move("pretty", pretty_.PrettyHookId);
  move("equivalence", equivalence_.EquivalenceHookId);
  move("concurrency", AST.ConcurrencyAnnotationId);
  move("batching", AST.BatchingAnnotationId);
  move("parseIssueTitle", AST.ParseIssueTitleAnnotationId);
  return out;
};
class SchemaImpl {
  ast;
  [TypeId] = variance;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations) {
    return new SchemaImpl(AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
 * @since 1.0.0
 */
export const asSchema = schema => schema;
/**
 * @category hashing
 * @since 1.0.0
 */
export const hash = schema => AST.hash(schema.ast);
/**
 * @category formatting
 * @since 1.0.0
 */
export const format = schema => String(schema.ast);
/**
 * @since 1.0.0
 */
export const encodedSchema = schema => make(AST.encodedAST(schema.ast));
/**
 * @since 1.0.0
 */
export const typeSchema = schema => make(AST.typeAST(schema.ast));
/* c8 ignore start */
export {
/**
 * @category validation
 * @since 1.0.0
 */
asserts,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeSync,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownOption,
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownSync,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeSync,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownOption,
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownSync,
/**
 * @category validation
 * @since 1.0.0
 */
is,
/**
 * @category validation
 * @since 1.0.0
 */
validateOption,
/**
 * @category validation
 * @since 1.0.0
 */
validateSync } from "./ParseResult.js";
/* c8 ignore end */
/**
 * @category encoding
 * @since 1.0.0
 */
export const encodeUnknown = (schema, options) => {
  const encodeUnknown = ParseResult.encodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
export const encodeUnknownEither = (schema, options) => {
  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
export const encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category encoding
 * @since 1.0.0
 */
export const encode = encodeUnknown;
/**
 * @category encoding
 * @since 1.0.0
 */
export const encodeEither = encodeUnknownEither;
/**
 * @category encoding
 * @since 1.0.0
 */
export const encodePromise = encodeUnknownPromise;
/**
 * @category decoding
 * @since 1.0.0
 */
export const decodeUnknown = (schema, options) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
export const decodeUnknownEither = (schema, options) => {
  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
export const decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category decoding
 * @since 1.0.0
 */
export const decode = decodeUnknown;
/**
 * @category decoding
 * @since 1.0.0
 */
export const decodeEither = decodeUnknownEither;
/**
 * @category decoding
 * @since 1.0.0
 */
export const decodePromise = decodeUnknownPromise;
/**
 * @category validation
 * @since 1.0.0
 */
export const validate = (schema, options) => {
  const validate = ParseResult.validate(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
export const validateEither = (schema, options) => {
  const validateEither = ParseResult.validateEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
export const validatePromise = (schema, options) => {
  const parser = validate(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
export const isSchema = u => Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId]);
/**
 * @category constructors
 * @since 1.0.0
 */
export const make = ast => new SchemaImpl(ast);
class LiteralImpl extends SchemaImpl {
  static ast = literals => {
    return AST.isMembers(literals) ? AST.Union.make(AST.mapMembers(literals, literal => new AST.Literal(literal))) : new AST.Literal(literals[0]);
  };
  literals;
  constructor(literals, ast = LiteralImpl.ast(literals)) {
    super(ast);
    this.literals = [...literals];
  }
  annotations(annotations) {
    return new LiteralImpl(this.literals, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
export function Literal(...literals) {
  return array_.isNonEmptyReadonlyArray(literals) ? new LiteralImpl(literals) : Never;
}
/**
 * Creates a new `Schema` from a literal schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { Either } from "effect"
 *
 * const schema = S.Literal("a", "b", "c").pipe(S.pickLiteral("a", "b"))
 *
 * assert.deepStrictEqual(S.decodeSync(schema)("a"), "a")
 * assert.deepStrictEqual(S.decodeSync(schema)("b"), "b")
 * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)("c")), true)
 *
 * @category constructors
 * @since 1.0.0
 */
export const pickLiteral = (...literals) => _schema => Literal(...literals);
/**
 * @category constructors
 * @since 1.0.0
 */
export const UniqueSymbolFromSelf = symbol => make(new AST.UniqueSymbol(symbol));
class EnumsImpl extends SchemaImpl {
  enums;
  static ast = enums => {
    return new AST.Enums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]]));
  };
  constructor(enums, ast = EnumsImpl.ast(enums)) {
    super(ast);
    this.enums = enums;
  }
  annotations(annotations) {
    return new EnumsImpl(this.enums, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const Enums = enums => new EnumsImpl(enums);
/**
 * @category constructors
 * @since 1.0.0
 */
export const TemplateLiteral = (...[head, ...tail]) => {
  let types = getTemplateLiterals(head.ast);
  for (const span of tail) {
    types = array_.flatMap(types, a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b)));
  }
  return make(AST.Union.make(types));
};
const combineTemplateLiterals = (a, b) => {
  if (AST.isLiteral(a)) {
    return AST.isLiteral(b) ? new AST.Literal(String(a.literal) + String(b.literal)) : AST.TemplateLiteral.make(String(a.literal) + b.head, b.spans);
  }
  if (AST.isLiteral(b)) {
    return AST.TemplateLiteral.make(a.head, array_.modifyNonEmptyLast(a.spans, span => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.literal))));
  }
  return AST.TemplateLiteral.make(a.head, array_.appendAll(array_.modifyNonEmptyLast(a.spans, span => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.head))), b.spans));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [ast];
    case "NumberKeyword":
    case "StringKeyword":
      return [AST.TemplateLiteral.make("", [new AST.TemplateLiteralSpan(ast, "")])];
    case "Union":
      return array_.flatMap(ast.types, getTemplateLiterals);
    default:
      throw new Error(`unsupported template literal span (${ast})`);
  }
};
const declareConstructor = (typeParameters, options, annotations) => make(new AST.Declaration(typeParameters.map(tp => tp.ast), (...typeParameters) => options.decode(...typeParameters.map(make)), (...typeParameters) => options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input));
  const encodeUnknown = decodeUnknown;
  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 1.0.0
 */
export const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations = arguments[2];
    return declareConstructor(typeParameters, options, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
 * @category type id
 * @since 1.0.0
 */
export const BrandTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Brand");
/**
 * @category constructors
 * @since 1.0.0
 */
export const fromBrand = (constructor, annotations) => self => make(new AST.Refinement(self.ast, (a, _, ast) => {
  const either = constructor.either(a);
  return either_.isLeft(either) ? option_.some(new ParseResult.Type(ast, a, either.left.map(v => v.message).join(", "))) : option_.none();
}, toASTAnnotations({
  typeId: {
    id: BrandTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations
})));
/**
 * @category type id
 * @since 1.0.0
 */
export const InstanceOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/InstanceOf");
/**
 * @category constructors
 * @since 1.0.0
 */
export const instanceOf = (constructor, annotations) => declare(u => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  typeId: {
    id: InstanceOfTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations
});
/**
 * @category primitives
 * @since 1.0.0
 */
export const Undefined = /*#__PURE__*/make(AST.undefinedKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const Void = /*#__PURE__*/make(AST.voidKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const Null = /*#__PURE__*/make(AST.null);
/**
 * @category primitives
 * @since 1.0.0
 */
export const Never = /*#__PURE__*/make(AST.neverKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const Unknown = /*#__PURE__*/make(AST.unknownKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const Any = /*#__PURE__*/make(AST.anyKeyword);
const $String = /*#__PURE__*/make(AST.stringKeyword);
const $Number = /*#__PURE__*/make(AST.numberKeyword);
const $Boolean = /*#__PURE__*/make(AST.booleanKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const BigIntFromSelf = /*#__PURE__*/make(AST.bigIntKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
export const SymbolFromSelf = /*#__PURE__*/make(AST.symbolKeyword);
const $Object = /*#__PURE__*/make(AST.objectKeyword);
export {
/**
 * @category primitives
 * @since 1.0.0
 */
$Boolean as Boolean,
/**
 * @category primitives
 * @since 1.0.0
 */
$Number as Number,
/**
 * @category primitives
 * @since 1.0.0
 */
$Object as Object,
/**
 * @category primitives
 * @since 1.0.0
 */
$String as String };
class UnionImpl extends SchemaImpl {
  static ast = members => {
    return AST.Union.members(members.map(m => m.ast));
  };
  members;
  constructor(members, ast = UnionImpl.ast(members)) {
    super(ast);
    this.members = [...members];
  }
  annotations(annotations) {
    return new UnionImpl(this.members, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
export function Union(...members) {
  return AST.isMembers(members) ? new UnionImpl(members) : array_.isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
/**
 * @category combinators
 * @since 1.0.0
 */
export const NullOr = self => Union(self, Null);
/**
 * @category combinators
 * @since 1.0.0
 */
export const UndefinedOr = self => Union(self, Undefined);
/**
 * @category combinators
 * @since 1.0.0
 */
export const NullishOr = self => Union(self, Null, Undefined);
/**
 * @category combinators
 * @since 1.0.0
 */
export const keyof = self => make(AST.keyof(self.ast));
/**
 * @since 1.0.0
 */
export const optionalElement = self => new OptionalElementImpl(self);
class OptionalElementImpl {
  optionalElement;
  [TypeId];
  constructor(optionalElement) {
    this.optionalElement = optionalElement;
  }
  toString() {
    return `${this.optionalElement.ast}?`;
  }
}
class TupleTypeImpl extends SchemaImpl {
  elements;
  rest;
  static ast = (elements, rest) => {
    return new AST.TupleType(elements.map(schema => isSchema(schema) ? new AST.Element(schema.ast, false) : new AST.Element(schema.optionalElement.ast, true)), rest.map(e => e.ast), true);
  };
  constructor(elements, rest, ast = TupleTypeImpl.ast(elements, rest)) {
    super(ast);
    this.elements = elements;
    this.rest = rest;
  }
  annotations(annotations) {
    return new TupleTypeImpl(this.elements, this.rest, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
export function Tuple(...args) {
  return Array.isArray(args[0]) ? new TupleTypeImpl(args[0], args.slice(1)) : new TupleTypeImpl(args, []);
}
class $ArrayImpl extends TupleTypeImpl {
  value;
  constructor(value, ast) {
    super([], [value], ast);
    this.value = value;
  }
  annotations(annotations) {
    return new $ArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
const $Array = value => new $ArrayImpl(value);
export {
/**
 * @category constructors
 * @since 1.0.0
 */
$Array as Array };
class NonEmptyArrayImpl extends TupleTypeImpl {
  value;
  constructor(value, ast) {
    super([value], [value], ast);
    this.value = value;
  }
  annotations(annotations) {
    return new NonEmptyArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const NonEmptyArray = value => new NonEmptyArrayImpl(value);
const formatToken = isOptional => isOptional ? "\"?:\"" : "\":\"";
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export class PropertySignatureDeclaration {
  type;
  isOptional;
  isReadonly;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    const token = formatToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export class FromPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  fromKey;
  constructor(type, isOptional, isReadonly, annotations, fromKey) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    this.fromKey = fromKey;
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export class ToPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  constructor(type, isOptional, isReadonly, annotations) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
}
const formatPropertyKey = p => {
  if (p === undefined) {
    return "never";
  }
  if (Predicate.isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  /**
   * @since 1.0.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    return `PropertySignature<${formatToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
/**
 * @since 1.0.0
 * @category symbol
 */
export const PropertySignatureTypeId = /*#__PURE__*/Symbol.for("@effect/schema/PropertySignature");
const propertySignatureAnnotations_ = (ast, annotations) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations
        });
      }
    case "PropertySignatureTransformation":
      {
        return new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }), ast.decode, ast.encode);
      }
  }
};
/** @internal */
export class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null;
  _Key;
  _EncodedToken;
  _TypeToken;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations) {
    return new PropertySignatureImpl(propertySignatureAnnotations_(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export const propertySignature = self => new PropertySignatureImpl(new PropertySignatureDeclaration(self.ast, false, true, {}));
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export const fromKey = /*#__PURE__*/dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}), identity, identity));
      }
    case "PropertySignatureTransformation":
      return new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
/**
 * - `decode`: `none` as argument means: the value is missing in the input
 * - `encode`: `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
export const optionalToRequired = (from, to, options) => new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}), o => option_.some(options.decode(o)), option_.flatMap(options.encode)));
/**
 * - `decode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 * - `encode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
export const optionalToOptional = (from, to, options) => new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}), options.decode, options.encode));
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export const optional = /*#__PURE__*/dual(args => isSchema(args[0]), (schema, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable = options?.nullable;
  const asOption = options?.as == "Option";
  if (isExact) {
    if (defaultValue) {
      if (isNullable) {
        return optionalToRequired(NullOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === null ? defaultValue() : a
          }),
          encode: option_.some
        });
      } else {
        return optionalToRequired(schema, typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: option_.some
        });
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: identity
        });
      } else {
        return optionalToRequired(schema, OptionFromSelf(typeSchema(schema)), {
          decode: identity,
          encode: identity
        });
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullOr(schema), typeSchema(schema), {
          decode: option_.filter(Predicate.isNotNull),
          encode: identity
        });
      } else {
        return new PropertySignatureImpl(new PropertySignatureDeclaration(schema.ast, true, true, {}));
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable) {
        return optionalToRequired(NullishOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a == null ? defaultValue() : a
          }),
          encode: option_.some
        });
      } else {
        return optionalToRequired(UndefinedOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === undefined ? defaultValue() : a
          }),
          encode: option_.some
        });
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullishOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(a => a != null),
          encode: identity
        });
      } else {
        return optionalToRequired(UndefinedOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotUndefined),
          encode: identity
        });
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullishOr(schema), UndefinedOr(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: identity
        });
      } else {
        return new PropertySignatureImpl(new PropertySignatureDeclaration(UndefinedOr(schema).ast, true, true, {}));
      }
    }
  }
});
const isPropertySignature = u => Predicate.hasProperty(u, PropertySignatureTypeId);
class TypeLiteralImpl extends SchemaImpl {
  static ast = (fields, records) => {
    const ownKeys = util_.ownKeys(fields);
    const pss = [];
    if (ownKeys.length > 0) {
      const from = [];
      const to = [];
      const transformations = [];
      for (let i = 0; i < ownKeys.length; i++) {
        const key = ownKeys[i];
        const field = fields[key];
        if (isPropertySignature(field)) {
          const ast = field.ast;
          switch (ast._tag) {
            case "PropertySignatureDeclaration":
              {
                const type = ast.type;
                const isOptional = ast.isOptional;
                const toAnnotations = ast.annotations;
                from.push(new AST.PropertySignature(key, type, isOptional, true));
                to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations));
                pss.push(new AST.PropertySignature(key, type, isOptional, true, toAnnotations));
                break;
              }
            case "PropertySignatureTransformation":
              {
                const fromKey = ast.from.fromKey ?? key;
                from.push(new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
                to.push(new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
                transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
                break;
              }
          }
        } else {
          from.push(new AST.PropertySignature(key, field.ast, false, true));
          to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true));
          pss.push(new AST.PropertySignature(key, field.ast, false, true));
        }
      }
      if (array_.isNonEmptyReadonlyArray(transformations)) {
        const issFrom = [];
        const issTo = [];
        for (const r of records) {
          const {
            indexSignatures,
            propertySignatures
          } = AST.record(r.key.ast, r.value.ast);
          propertySignatures.forEach(ps => {
            from.push(ps);
            to.push(new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
          });
          indexSignatures.forEach(is => {
            issFrom.push(is);
            issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly));
          });
        }
        return new AST.Transformation(new AST.TypeLiteral(from, issFrom, {
          [AST.TitleAnnotationId]: "Struct (Encoded side)"
        }), new AST.TypeLiteral(to, issTo, {
          [AST.TitleAnnotationId]: "Struct (Type side)"
        }), new AST.TypeLiteralTransformation(transformations));
      }
    }
    const iss = [];
    for (const r of records) {
      const {
        indexSignatures,
        propertySignatures
      } = AST.record(r.key.ast, r.value.ast);
      propertySignatures.forEach(ps => pss.push(ps));
      indexSignatures.forEach(is => iss.push(is));
    }
    return new AST.TypeLiteral(pss, iss);
  };
  fields;
  records;
  constructor(fields, records, ast = TypeLiteralImpl.ast(fields, records)) {
    super(ast);
    this.fields = {
      ...fields
    };
    this.records = [...records];
  }
  annotations(annotations) {
    return new TypeLiteralImpl(this.fields, this.records, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
export function Struct(fields, ...records) {
  return new TypeLiteralImpl(fields, records);
}
class $RecordImpl extends TypeLiteralImpl {
  key;
  value;
  constructor(key, value, ast) {
    super({}, [{
      key,
      value
    }], ast);
    this.key = key;
    this.value = value;
  }
  annotations(annotations) {
    return new $RecordImpl(this.key, this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
export const Record = (key, value) => new $RecordImpl(key, value);
/**
 * @category struct transformations
 * @since 1.0.0
 */
export const pick = (...keys) => self => make(AST.pick(self.ast, keys));
/**
 * @category struct transformations
 * @since 1.0.0
 */
export const omit = (...keys) => self => make(AST.omit(self.ast, keys));
/**
 * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
 * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.Struct({
 *   column1: S.NumberFromString,
 *   column2: S.Number
 * })
 *
 * // const pullOutColumn: S.Schema<number, {
 * //     readonly column1: string;
 * // }, never>
 * const pullOutColumn = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 1.0.0
 */
export const pluck = /*#__PURE__*/dual(2, (schema, key) => {
  const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key);
  const value = make(ps.isOptional ? AST.orUndefined(ps.type) : ps.type);
  return transform(schema.pipe(pick(key)), value, {
    decode: a => a[key],
    encode: ak => ps.isOptional && ak === undefined ? {} : {
      [key]: ak
    }
  });
});
const makeBrandSchema = (self, annotations) => {
  const ast = AST.annotations(self, toASTAnnotations(annotations));
  const schema = make(ast);
  const validateEither_ = validateEither(schema);
  //     v-- function
  const out = brand_.refined(unbranded => either_.match(validateEither_(unbranded), {
    onLeft: e => option_.some(brand_.error(TreeFormatter.formatErrorSync(e), e)),
    onRight: () => option_.none()
  }));
  // ----------------
  // Schema interface
  // ----------------
  Object.setPrototypeOf(Object.assign(out, schema, {
    annotations: a => makeBrandSchema(ast, a)
  }), Object.getPrototypeOf(schema));
  return out;
};
/**
 * @category branding
 * @since 1.0.0
 */
export const asBrandSchema = schema => schema;
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
 *
 * @category branding
 * @since 1.0.0
 */
export const brand = (brand, annotations) => self => {
  const brandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {
    onNone: () => [brand],
    onSome: brands => [...brands, brand]
  });
  return makeBrandSchema(self.ast, {
    // add a default title annotation containing the brand
    title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,
    ...annotations,
    [AST.BrandAnnotationId]: brandAnnotation
  });
};
/**
 * @category combinators
 * @since 1.0.0
 */
export const partial = /*#__PURE__*/dual(args => isSchema(args[0]), (self, options) => make(AST.partial(self.ast, options)));
/**
 * @category combinators
 * @since 1.0.0
 */
export const required = self => make(AST.required(self.ast));
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 1.0.0
 */
export const mutable = schema => make(AST.mutable(schema.ast));
const getExtendErrorMessage = (x, y, path) => errors_.getAPIErrorMessage("Extend", `cannot extend \`${x}\` with \`${y}\` (path [${path?.join(", ")}])`);
const intersectTypeLiterals = (x, y, path) => {
  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex(ps => ps.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        path = [...path, util_.formatUnknown(name)];
        propertySignatures[i] = new AST.PropertySignature(name, extendAST(type, ps.type, path), isOptional, true);
      }
    }
    return new AST.TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getExtendErrorMessage(x, y, path));
};
const extendAST = (x, y, path) => AST.Union.make(intersectUnionMembers([x], [y], path));
const intersectUnionMembers = (xs, ys, path) => array_.flatMap(xs, x => array_.flatMap(ys, y => {
  if (AST.isUnion(x)) {
    return intersectUnionMembers(x.types, AST.isUnion(y) ? y.types : [y], path);
  } else if (AST.isUnion(y)) {
    return intersectUnionMembers([x], y.types, path);
  }
  if (AST.isTypeLiteral(x)) {
    if (AST.isTypeLiteral(y)) {
      return [intersectTypeLiterals(x, y, path)];
    } else if (AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)) {
      return [new AST.Transformation(intersectTypeLiterals(x, y.from, path), intersectTypeLiterals(AST.typeAST(x), y.to, path), new AST.TypeLiteralTransformation(y.transformation.propertySignatureTransformations))];
    }
  } else if (AST.isTransformation(x) && AST.isTypeLiteralTransformation(x.transformation)) {
    if (AST.isTypeLiteral(y)) {
      return [new AST.Transformation(intersectTypeLiterals(x.from, y, path), intersectTypeLiterals(x.to, AST.typeAST(y), path), new AST.TypeLiteralTransformation(x.transformation.propertySignatureTransformations))];
    } else if (AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)) {
      return [new AST.Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new AST.TypeLiteralTransformation(x.transformation.propertySignatureTransformations.concat(y.transformation.propertySignatureTransformations)))];
    }
  }
  throw new Error(getExtendErrorMessage(x, y, path));
}));
/**
 * @category combinators
 * @since 1.0.0
 */
export const extend = /*#__PURE__*/dual(2, (self, that) => make(extendAST(self.ast, that.ast, [])));
/**
 * @category combinators
 * @since 1.0.0
 */
export const compose = /*#__PURE__*/dual(args => isSchema(args[1]), (from, to) => make(AST.compose(from.ast, to.ast)));
/**
 * @category constructors
 * @since 1.0.0
 */
export const suspend = f => make(new AST.Suspend(() => f().ast));
export function filter(predicate, annotations) {
  return self => make(new AST.Refinement(self.ast, (a, options, ast) => {
    const out = predicate(a, options, ast);
    if (Predicate.isBoolean(out)) {
      return out ? option_.none() : option_.some(new ParseResult.Type(ast, a));
    }
    return out;
  }, toASTAnnotations(annotations)));
}
class transformOrFailImpl extends SchemaImpl {
  from;
  to;
  constructor(from, to, ast) {
    super(ast);
    this.from = from;
    this.to = to;
  }
  annotations(annotations) {
    return new transformOrFailImpl(this.from, this.to, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export const transformOrFail = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => new transformOrFailImpl(from, to, new AST.Transformation(from.ast, to.ast, new AST.FinalTransformation(options.decode, options.encode))));
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export const transform = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => transformOrFail(from, to, {
  decode: fromA => ParseResult.succeed(options.decode(fromA)),
  encode: toI => ParseResult.succeed(options.encode(toI))
}));
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 1.0.0
 */
export const transformLiteral = (from, to) => transform(Literal(from), Literal(to), {
  decode: () => to,
  encode: () => from
});
export function transformLiterals(...pairs) {
  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.Struct({ radius: S.Number })
 * const Square = S.Struct({ sideLength: S.Number })
 * const Shape = S.Union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export const attachPropertySignature = /*#__PURE__*/dual(args => isSchema(args[0]), (schema, key, value, annotations) => {
  const attached = extend(typeSchema(schema), Struct({
    [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value)
  })).ast;
  return make(new AST.Transformation(schema.ast, annotations ? AST.annotations(attached, toASTAnnotations(annotations)) : attached, new AST.TypeLiteralTransformation([new AST.PropertySignatureTransformation(key, key, () => option_.some(value), () => option_.none())])));
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const annotations = /*#__PURE__*/dual(2, (self, annotations) => self.annotations(annotations));
/**
 * @category annotations
 * @since 1.0.0
 */
export const message = message => self => self.annotations({
  [AST.MessageAnnotationId]: message
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const identifier = identifier => self => self.annotations({
  [AST.IdentifierAnnotationId]: identifier
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const title = title => self => self.annotations({
  [AST.TitleAnnotationId]: title
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const description = description => self => self.annotations({
  [AST.DescriptionAnnotationId]: description
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const examples = examples => self => self.annotations({
  [AST.ExamplesAnnotationId]: examples
});
const $default = value => self => self.annotations({
  [AST.DefaultAnnotationId]: value
});
export {
/**
 * @category annotations
 * @since 1.0.0
 */
$default as default };
/**
 * @category annotations
 * @since 1.0.0
 */
export const documentation = documentation => self => self.annotations({
  [AST.DocumentationAnnotationId]: documentation
});
/**
 * Attaches a JSON Schema annotation to a schema that represents a refinement.
 *
 * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
 *
 * @category annotations
 * @since 1.0.0
 */
export const jsonSchema = jsonSchema => self => self.annotations({
  [AST.JSONSchemaAnnotationId]: jsonSchema
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const equivalence = equivalence => self => self.annotations({
  [equivalence_.EquivalenceHookId]: () => equivalence
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const concurrency = concurrency => self => self.annotations({
  [AST.ConcurrencyAnnotationId]: concurrency
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const batching = batching => self => self.annotations({
  [AST.BatchingAnnotationId]: batching
});
/**
 * @category annotations
 * @since 1.0.0
 */
export const parseIssueTitle = f => self => self.annotations({
  [AST.ParseIssueTitleAnnotationId]: f
});
/**
 * @category renaming
 * @since 1.0.0
 */
export const rename = /*#__PURE__*/dual(2, (self, mapping) => {
  return make(AST.rename(self.ast, mapping));
});
/**
 * @category type id
 * @since 1.0.0
 */
export const TrimmedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Trimmed");
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 1.0.0
 */
export const trimmed = annotations => self => self.pipe(filter(a => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MaxLengthTypeId = filters_.MaxLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export const maxLength = (maxLength, annotations) => self => self.pipe(filter(a => a.length <= maxLength, {
  typeId: MaxLengthTypeId,
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MinLengthTypeId = filters_.MinLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export const minLength = (minLength, annotations) => self => self.pipe(filter(a => a.length >= minLength, {
  typeId: MinLengthTypeId,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const PatternTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Pattern");
/**
 * @category string filters
 * @since 1.0.0
 */
export const pattern = (regex, annotations) => self => {
  const pattern = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    arbitrary: () => fc => fc.stringMatching(regex),
    ...annotations
  }));
};
/**
 * @category type id
 * @since 1.0.0
 */
export const StartsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/StartsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
export const startsWith = (startsWith, annotations) => self => self.pipe(filter(a => a.startsWith(startsWith), {
  typeId: {
    id: StartsWithTypeId,
    annotation: {
      startsWith
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith)}`,
  jsonSchema: {
    pattern: `^${startsWith}`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const EndsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/EndsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
export const endsWith = (endsWith, annotations) => self => self.pipe(filter(a => a.endsWith(endsWith), {
  typeId: {
    id: EndsWithTypeId,
    annotation: {
      endsWith
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith)}`,
  jsonSchema: {
    pattern: `^.*${endsWith}$`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const IncludesTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Includes");
/**
 * @category string filters
 * @since 1.0.0
 */
export const includes = (searchString, annotations) => self => self.pipe(filter(a => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    annotation: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LowercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Lowercased");
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export const lowercased = annotations => self => self.pipe(filter(a => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
export const Lowercased = /*#__PURE__*/$String.pipe( /*#__PURE__*/lowercased({
  identifier: "Lowercased",
  title: "Lowercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const UppercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Uppercased");
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export const uppercased = annotations => self => self.pipe(filter(a => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
export const Uppercased = /*#__PURE__*/$String.pipe( /*#__PURE__*/uppercased({
  identifier: "Uppercased",
  title: "Uppercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LengthTypeId = filters_.LengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export const length = (length, annotations) => self => {
  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length));
  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength;
  if (minLength !== maxLength) {
    return self.pipe(filter(a => a.length >= minLength && a.length <= maxLength, {
      typeId: LengthTypeId,
      description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
      jsonSchema: {
        minLength,
        maxLength
      },
      ...annotations
    }));
  }
  return self.pipe(filter(a => a.length === minLength, {
    typeId: LengthTypeId,
    description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
    jsonSchema: {
      minLength,
      maxLength: minLength
    },
    ...annotations
  }));
};
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 1.0.0
 */
export const Char = /*#__PURE__*/$String.pipe( /*#__PURE__*/length(1, {
  identifier: "Char"
}));
/**
 * @category string filters
 * @since 1.0.0
 */
export const nonEmpty = annotations => minLength(1, {
  description: "a non empty string",
  ...annotations
});
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export const Lowercase = /*#__PURE__*/transform($String, Lowercased, {
  decode: s => s.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
});
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export const Uppercase = /*#__PURE__*/transform($String, Uppercased, {
  decode: s => s.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
});
/**
 * @category string constructors
 * @since 1.0.0
 */
export const Trimmed = /*#__PURE__*/$String.pipe( /*#__PURE__*/trimmed({
  identifier: "Trimmed",
  title: "Trimmed"
}));
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 1.0.0
 */
export const Trim = /*#__PURE__*/transform($String, Trimmed, {
  decode: s => s.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
});
/**
 * Returns a schema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 1.0.0
 */
export const split = separator => transform($String, $Array($String), {
  decode: string_.split(separator),
  encode: array_.join(separator)
});
const JsonString = /*#__PURE__*/$String.annotations({
  [AST.IdentifierAnnotationId]: "JsonString",
  [AST.TitleAnnotationId]: "JsonString",
  [AST.DescriptionAnnotationId]: "a JSON string"
});
/**
 * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 1.0.0
 */
export const parseJson = (schema, o) => {
  if (isSchema(schema)) {
    return compose(parseJson(o), schema);
  }
  const options = schema;
  return transformOrFail(JsonString, Unknown, {
    decode: (s, _, ast) => ParseResult.try({
      try: () => JSON.parse(s, options?.reviver),
      catch: e => new ParseResult.Type(ast, s, e.message)
    }),
    encode: (u, _, ast) => ParseResult.try({
      try: () => JSON.stringify(u, options?.replacer, options?.space),
      catch: e => new ParseResult.Type(ast, u, e.message)
    })
  });
};
/**
 * @category string constructors
 * @since 1.0.0
 */
export const NonEmpty = /*#__PURE__*/$String.pipe( /*#__PURE__*/nonEmpty({
  identifier: "NonEmpty",
  title: "NonEmpty"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const UUIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/UUID");
const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export const UUID = /*#__PURE__*/$String.pipe( /*#__PURE__*/pattern(uuidRegex, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const ULIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ULID");
const ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export const ULID = /*#__PURE__*/$String.pipe( /*#__PURE__*/pattern(ulidRegex, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const FiniteTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Finite");
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 1.0.0
 */
export const finite = annotations => self => self.pipe(filter(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanTypeId = filters_.GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export const greaterThan = (min, annotations) => self => self.pipe(filter(a => a > min, {
  typeId: GreaterThanTypeId,
  description: min === 0 ? "a positive number" : `a number greater than ${min}`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToTypeId = filters_.GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export const greaterThanOrEqualTo = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: min === 0 ? "a non-negative number" : `a number greater than or equal to ${min}`,
  jsonSchema: {
    minimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MultipleOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/MultipleOf");
/**
 * @category number filters
 * @since 1.0.0
 */
export const multipleOf = (divisor, annotations) => self => self.pipe(filter(a => number_.remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  // spec requires positive divisor
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const IntTypeId = filters_.IntTypeId;
/**
 * @category number filters
 * @since 1.0.0
 */
export const int = annotations => self => self.pipe(filter(a => Number.isSafeInteger(a), {
  typeId: IntTypeId,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanTypeId = filters_.LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export const lessThan = (max, annotations) => self => self.pipe(filter(a => a < max, {
  typeId: LessThanTypeId,
  description: max === 0 ? "a negative number" : `a number less than ${max}`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToTypeId = filters_.LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export const lessThanOrEqualTo = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: max === 0 ? "a non-positive number" : `a number less than or equal to ${max}`,
  jsonSchema: {
    maximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenTypeId = filters_.BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 1.0.0
 */
export const between = (min, max, annotations) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: BetweenTypeId,
  description: `a number between ${min} and ${max}`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const NonNaNTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNaN");
/**
 * @category number filters
 * @since 1.0.0
 */
export const nonNaN = annotations => self => self.pipe(filter(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...annotations
}));
/**
 * @category number filters
 * @since 1.0.0
 */
export const positive = annotations => greaterThan(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
export const negative = annotations => lessThan(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
export const nonPositive = annotations => lessThanOrEqualTo(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
export const nonNegative = annotations => greaterThanOrEqualTo(0, annotations);
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 1.0.0
 */
export const clamp = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, between(minimum, maximum)), {
  strict: false,
  decode: self => number_.clamp(self, {
    minimum,
    maximum
  }),
  encode: identity
});
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 1.0.0
 */
export const NumberFromString = /*#__PURE__*/transformOrFail($String, $Number, {
  decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),
  encode: n => ParseResult.succeed(String(n))
}).annotations({
  identifier: "NumberFromString"
});
/**
 * @category number constructors
 * @since 1.0.0
 */
export const Finite = /*#__PURE__*/$Number.pipe( /*#__PURE__*/finite({
  identifier: "Finite",
  title: "Finite"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const Int = /*#__PURE__*/$Number.pipe( /*#__PURE__*/int({
  identifier: "Int",
  title: "Int"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const NonNaN = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonNaN({
  identifier: "NonNaN",
  title: "NonNaN"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const Positive = /*#__PURE__*/$Number.pipe( /*#__PURE__*/positive({
  identifier: "Positive",
  title: "Positive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const Negative = /*#__PURE__*/$Number.pipe( /*#__PURE__*/negative({
  identifier: "Negative",
  title: "Negative"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const NonPositive = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonPositive({
  identifier: "NonPositive",
  title: "NonPositive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
export const NonNegative = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const JsonNumberTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/JsonNumber");
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 1.0.0
 */
export const JsonNumber = /*#__PURE__*/$Number.pipe( /*#__PURE__*/filter(n => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
}));
/**
 * @category boolean transformations
 * @since 1.0.0
 */
export const Not = /*#__PURE__*/transform($Boolean, $Boolean, {
  decode: boolean_.not,
  encode: boolean_.not
});
const $Symbol = /*#__PURE__*/transform($String, SymbolFromSelf, {
  strict: false,
  decode: s => Symbol.for(s),
  encode: sym => sym.description
}).annotations({
  identifier: "symbol"
});
export {
/**
 * This schema transforms a `string` into a `symbol`.
 *
 * @category symbol transformations
 * @since 1.0.0
 */
$Symbol as Symbol };
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanBigIntTypeId = filters_.GreaterThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const greaterThanBigInt = (min, annotations) => self => self.pipe(filter(a => a > min, {
  typeId: {
    id: GreaterThanBigIntTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToBigIntTypeId = filters_.GreaterThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const greaterThanOrEqualToBigInt = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  typeId: {
    id: GreaterThanOrEqualToBigIntTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanBigIntTypeId = filters_.LessThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const lessThanBigInt = (max, annotations) => self => self.pipe(filter(a => a < max, {
  typeId: {
    id: LessThanBigIntTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToBigIntTypeId = filters_.LessThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const lessThanOrEqualToBigInt = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  typeId: {
    id: LessThanOrEqualToBigIntTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenBigIntTypeId = filters_.BetweenBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const betweenBigInt = (min, max, annotations) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: {
    id: BetweenBigIntTypeId,
    annotation: {
      max,
      min
    }
  },
  description: `a bigint between ${min}n and ${max}n`,
  ...annotations
}));
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const positiveBigInt = annotations => greaterThanBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const negativeBigInt = annotations => lessThanBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const nonNegativeBigInt = annotations => greaterThanOrEqualToBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
export const nonPositiveBigInt = annotations => lessThanOrEqualToBigInt(0n, annotations);
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export const clampBigInt = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: self => bigInt_.clamp(self, {
    minimum,
    maximum
  }),
  encode: identity
});
const bigint = /*#__PURE__*/transformOrFail($String, BigIntFromSelf, {
  decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),
  encode: n => ParseResult.succeed(String(n))
}).annotations({
  identifier: "bigint"
});
export {
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 1.0.0
 */
bigint as BigInt };
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const PositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigintFromSelf",
  title: "PositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const PositiveBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigint",
  title: "PositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigintFromSelf",
  title: "NegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NegativeBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigint",
  title: "NegativeBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NonPositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf",
  title: "NonPositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NonPositiveBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigint",
  title: "NonPositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NonNegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf",
  title: "NonNegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export const NonNegativeBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigint",
  title: "NonNegativeBigint"
}));
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export const BigIntFromNumber = /*#__PURE__*/transformOrFail($Number, BigIntFromSelf, {
  decode: (n, _, ast) => ParseResult.fromOption(bigInt_.fromNumber(n), () => new ParseResult.Type(ast, n)),
  encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))
}).annotations({
  identifier: "BigintFromNumber"
});
/**
 * @category Secret constructors
 * @since 1.0.0
 */
export const SecretFromSelf = /*#__PURE__*/declare(secret_.isSecret, {
  identifier: "SecretFromSelf",
  pretty: () => secret => String(secret),
  arbitrary: () => fc => fc.string().map(_ => secret_.fromString(_))
});
/**
 * A schema that transforms a `string` into a `Secret`.
 *
 * @category Secret transformations
 * @since 1.0.0
 */
export const Secret = /*#__PURE__*/transform($String, SecretFromSelf, {
  strict: false,
  decode: str => secret_.fromString(str),
  encode: secret => secret_.value(secret)
}).annotations({
  identifier: "Secret"
});
/**
 * @category Duration constructors
 * @since 1.0.0
 */
export const DurationFromSelf = /*#__PURE__*/declare(duration_.isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(duration_.infinity), fc.bigUint().map(_ => duration_.nanos(_)), fc.bigUint().map(_ => duration_.micros(_)), fc.maxSafeNat().map(_ => duration_.millis(_)), fc.maxSafeNat().map(_ => duration_.seconds(_)), fc.maxSafeNat().map(_ => duration_.minutes(_)), fc.maxSafeNat().map(_ => duration_.hours(_)), fc.maxSafeNat().map(_ => duration_.days(_)), fc.maxSafeNat().map(_ => duration_.weeks(_))),
  equivalence: () => duration_.Equivalence
});
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export const DurationFromNanos = /*#__PURE__*/transformOrFail(BigIntFromSelf, DurationFromSelf, {
  decode: nanos => ParseResult.succeed(duration_.nanos(nanos)),
  encode: (duration, _, ast) => option_.match(duration_.toNanos(duration), {
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),
    onSome: val => ParseResult.succeed(val)
  })
}).annotations({
  identifier: "DurationFromNanos"
});
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export const DurationFromMillis = /*#__PURE__*/transform($Number, DurationFromSelf, {
  decode: ms => duration_.millis(ms),
  encode: n => duration_.toMillis(n)
}).annotations({
  identifier: "DurationFromMillis"
});
const hrTime = /*#__PURE__*/Tuple( /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "seconds",
  [AST.DescriptionAnnotationId]: "seconds"
})), /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "nanos",
  [AST.DescriptionAnnotationId]: "nanos"
})));
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export const Duration = /*#__PURE__*/transform(hrTime, DurationFromSelf, {
  decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),
  encode: duration => duration_.toHrTime(duration)
}).annotations({
  identifier: "Duration"
});
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export const clampDuration = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: self => duration_.clamp(self, {
    minimum,
    maximum
  }),
  encode: identity
});
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
export const lessThanDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThan(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than ${duration_.decode(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
export const lessThanOrEqualToDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than or equal to ${duration_.decode(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
export const greaterThanDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThan(a, min), {
  typeId: {
    id: GreaterThanDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than ${duration_.decode(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
export const greaterThanOrEqualToDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than or equal to ${duration_.decode(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
export const betweenDuration = (minimum, maximum, annotations) => self => self.pipe(filter(a => duration_.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenDurationTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,
  ...annotations
}));
/**
 * @category Uint8Array constructors
 * @since 1.0.0
 */
export const Uint8ArrayFromSelf = /*#__PURE__*/declare(Predicate.isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => array_.getEquivalence(Equal.equals)
});
const $Uint8Array = /*#__PURE__*/transform($Array($Number.pipe(between(0, 255, {
  title: "8-bit unsigned integer",
  description: "a 8-bit unsigned integer"
}))).annotations({
  description: "an array of 8-bit unsigned integers"
}), Uint8ArrayFromSelf, {
  decode: numbers => Uint8Array.from(numbers),
  encode: uint8Array => Array.from(uint8Array)
}).annotations({
  identifier: "Uint8Array"
});
export {
/**
 * A schema that transforms a `number` array into a `Uint8Array`.
 *
 * @category Uint8Array transformations
 * @since 1.0.0
 */
$Uint8Array as Uint8Array };
const makeEncodingTransformation = (id, decode, encode) => transformOrFail($String, Uint8ArrayFromSelf, {
  strict: false,
  decode: (s, _, ast) => either_.mapLeft(decode(s), decodeException => new ParseResult.Type(ast, s, decodeException.message)),
  encode: u => ParseResult.succeed(encode(u))
}).annotations({
  identifier: id
});
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export const Base64 = /*#__PURE__*/makeEncodingTransformation("Base64", Encoding.decodeBase64, Encoding.encodeBase64);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export const Base64Url = /*#__PURE__*/makeEncodingTransformation("Base64Url", Encoding.decodeBase64Url, Encoding.encodeBase64Url);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export const Hex = /*#__PURE__*/makeEncodingTransformation("Hex", Encoding.decodeHex, Encoding.encodeHex);
/**
 * @category type id
 * @since 1.0.0
 */
export const MinItemsTypeId = filters_.MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export const minItems = (n, annotations) => self => self.pipe(filter(a => a.length >= n, {
  typeId: MinItemsTypeId,
  description: `an array of at least ${n} items`,
  jsonSchema: {
    minItems: n
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const MaxItemsTypeId = filters_.MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export const maxItems = (n, annotations) => self => self.pipe(filter(a => a.length <= n, {
  typeId: MaxItemsTypeId,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const ItemsCountTypeId = filters_.ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export const itemsCount = (n, annotations) => self => self.pipe(filter(a => a.length === n, {
  typeId: ItemsCountTypeId,
  description: `an array of exactly ${n} item(s)`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  ...annotations
}));
/**
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export const getNumberIndexedAccess = self => make(AST.getNumberIndexedAccess(self.ast));
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export const head = self => transform(self, OptionFromSelf(getNumberIndexedAccess(typeSchema(self))), {
  decode: array_.head,
  encode: option_.match({
    onNone: () => [],
    onSome: array_.of
  })
});
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export const headOrElse = /*#__PURE__*/dual(args => isSchema(args[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess(typeSchema(self)), {
  decode: (as, _, ast) => as.length > 0 ? ParseResult.succeed(as[0]) : fallback ? ParseResult.succeed(fallback()) : ParseResult.fail(new ParseResult.Type(ast, as)),
  encode: a => ParseResult.succeed(array_.of(a))
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const ValidDateTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ValidDate");
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 1.0.0
 */
export const validDate = annotations => self => self.pipe(filter(a => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...annotations
}));
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 1.0.0
 */
export const DateFromSelf = /*#__PURE__*/declare(Predicate.isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => date => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => fc => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Equivalence.Date
});
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 1.0.0
 */
export const ValidDateFromSelf = /*#__PURE__*/DateFromSelf.pipe( /*#__PURE__*/validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}));
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 1.0.0
 */
export const DateFromString = /*#__PURE__*/transform($String, DateFromSelf, {
  decode: s => new Date(s),
  encode: n => n.toISOString()
}).annotations({
  identifier: "DateFromString"
});
const $Date = /*#__PURE__*/DateFromString.pipe( /*#__PURE__*/validDate({
  identifier: "Date"
}));
export {
/**
 * A schema that transforms a `string` into a **valid** `Date`, ensuring that invalid dates, such as `new Date("Invalid Date")`, are rejected.
 *
 * @category Date transformations
 * @since 1.0.0
 */
$Date as Date };
const OptionNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  description: "NoneEncoded"
});
const optionSomeEncoded = value => Struct({
  _tag: Literal("Some"),
  value
}).annotations({
  description: `SomeEncoded<${format(value)}>`
});
const optionEncoded = value => Union(OptionNoneEncoded, optionSomeEncoded(value)).annotations({
  description: `OptionEncoded<${format(value)}>`
});
const optionDecode = input => input._tag === "None" ? option_.none() : option_.some(input.value);
const optionArbitrary = value => fc => fc.oneof(fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value(fc)
})).map(optionDecode);
const optionPretty = value => option_.match({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionParse = decodeUnknown => (u, options, ast) => option_.isOption(u) ? option_.isNone(u) ? ParseResult.succeed(option_.none()) : ParseResult.map(decodeUnknown(u.value, options), option_.some) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Option transformations
 * @since 1.0.0
 */
export const OptionFromSelf = value => {
  return declare([value], {
    decode: value => optionParse(ParseResult.decodeUnknown(value)),
    encode: value => optionParse(ParseResult.encodeUnknown(value))
  }, {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: option_.getEquivalence
  });
};
const makeNoneEncoded = {
  _tag: "None"
};
const makeSomeEncoded = value => ({
  _tag: "Some",
  value
});
/**
 * @category Option transformations
 * @since 1.0.0
 */
export const Option = value => {
  const value_ = asSchema(value);
  return transform(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    decode: optionDecode,
    encode: option_.match({
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
export const OptionFromNullOr = value => {
  const value_ = asSchema(value);
  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: option_.getOrNull
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
export const OptionFromNullishOr = (value, onNoneEncoding) => {
  const value_ = asSchema(value);
  return transform(NullishOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
export const OptionFromUndefinedOr = value => {
  const value_ = asSchema(value);
  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: option_.getOrUndefined
  });
};
const rightEncoded = right => Struct({
  _tag: Literal("Right"),
  right
}).annotations({
  description: `RightEncoded<${format(right)}>`
});
const leftEncoded = left => Struct({
  _tag: Literal("Left"),
  left
}).annotations({
  description: `LeftEncoded<${format(left)}>`
});
const eitherEncoded = (right, left) => Union(rightEncoded(right), leftEncoded(left)).annotations({
  description: `EitherEncoded<${format(left)}, ${format(right)}>`
});
const eitherDecode = input => input._tag === "Left" ? either_.left(input.left) : either_.right(input.right);
const eitherArbitrary = (right, left) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right(fc)
})).map(eitherDecode);
const eitherPretty = (right, left) => either_.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => either_.isEither(u) ? either_.match(u, {
  onLeft: left => ParseResult.map(decodeUnknownLeft(left, options), either_.left),
  onRight: right => ParseResult.map(parseRight(right, options), either_.right)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Either transformations
 * @since 1.0.0
 */
export const EitherFromSelf = ({
  left,
  right
}) => {
  return declare([right, left], {
    decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),
    encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))
  }, {
    description: `Either<${format(right)}, ${format(left)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right, left) => either_.getEquivalence({
      left,
      right
    })
  });
};
const makeLeftEncoded = left => ({
  _tag: "Left",
  left
});
const makeRightEncoded = right => ({
  _tag: "Right",
  right
});
/**
 * @category Either transformations
 * @since 1.0.0
 */
export const Either = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  return transform(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    decode: eitherDecode,
    encode: either_.match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
 *
 * @category Either transformations
 * @since 1.0.0
 */
export const EitherFromUnion = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform(right_, rightEncoded(toright), {
    decode: makeRightEncoded,
    encode: r => r.right
  });
  const fromLeft = transform(left_, leftEncoded(toleft), {
    decode: makeLeftEncoded,
    encode: l => l.left
  });
  return transform(Union(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    decode: from => from._tag === "Left" ? either_.left(from.left) : either_.right(from.right),
    encode: either_.match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
const mapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const readonlyMapEquivalence = (key, value) => {
  const arrayEquivalence = array_.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
const readonlyMapParse = decodeUnknown => (u, options, ast) => Predicate.isMap(u) ? ParseResult.map(decodeUnknown(Array.from(u.entries()), options), as => new Map(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
const mapFromSelf_ = (key, value, description) => declare([key, value], {
  decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown($Array(Tuple(Key, Value)))),
  encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown($Array(Tuple(Key, Value))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
/**
 * @category ReadonlyMap
 * @since 1.0.0
 */
export const ReadonlyMapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`);
/**
 * @category Map
 * @since 1.0.0
 */
export const MapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`);
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
export const ReadonlyMap = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), ReadonlyMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => new Map(as),
    encode: map => Array.from(map.entries())
  });
};
const map = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), MapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => new Map(as),
    encode: map => Array.from(map.entries())
  });
};
export {
/**
 * @category Map transformations
 * @since 1.0.0
 */
map as Map };
const setArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
const readonlySetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
const readonlySetParse = decodeUnknown => (u, options, ast) => Predicate.isSet(u) ? ParseResult.map(decodeUnknown(Array.from(u.values()), options), as => new Set(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
const setFromSelf_ = (value, description) => declare([value], {
  decode: item => readonlySetParse(ParseResult.decodeUnknown($Array(item))),
  encode: item => readonlySetParse(ParseResult.encodeUnknown($Array(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
/**
 * @category ReadonlySet
 * @since 1.0.0
 */
export const ReadonlySetFromSelf = value => setFromSelf_(value, `ReadonlySet<${format(value)}>`);
/**
 * @category Set
 * @since 1.0.0
 */
export const SetFromSelf = value => setFromSelf_(value, `Set<${format(value)}>`);
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
export const ReadonlySet = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ReadonlySetFromSelf(typeSchema(value_)), {
    decode: as => new Set(as),
    encode: set => Array.from(set)
  });
};
const set = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), SetFromSelf(typeSchema(value_)), {
    decode: as => new Set(as),
    encode: set => Array.from(set)
  });
};
export {
/**
 * @category Set transformations
 * @since 1.0.0
 */
set as Set };
const bigDecimalPretty = () => val => `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => bigDecimal_.make(value, scale));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export const BigDecimalFromSelf = /*#__PURE__*/declare(bigDecimal_.isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => bigDecimal_.Equivalence
});
/**
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export const BigDecimal = /*#__PURE__*/transformOrFail($String, BigDecimalFromSelf, {
  decode: (num, _, ast) => bigDecimal_.fromString(num).pipe(option_.match({
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),
    onSome: val => ParseResult.succeed(bigDecimal_.normalize(val))
  })),
  encode: val => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))
}).annotations({
  identifier: "BigDecimal"
});
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export const BigDecimalFromNumber = /*#__PURE__*/transformOrFail($Number, BigDecimalFromSelf, {
  decode: num => ParseResult.succeed(bigDecimal_.fromNumber(num)),
  encode: val => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))
}).annotations({
  identifier: "BigDecimalFromNumber"
});
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const greaterThanBigDecimal = (min, annotations) => self => self.pipe(filter(a => bigDecimal_.greaterThan(a, min), {
  typeId: {
    id: GreaterThanBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const GreaterThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const greaterThanOrEqualToBigDecimal = (min, annotations) => self => self.pipe(filter(a => bigDecimal_.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const lessThanBigDecimal = (max, annotations) => self => self.pipe(filter(a => bigDecimal_.lessThan(a, max), {
  typeId: {
    id: LessThanBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than ${bigDecimal_.format(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const LessThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const lessThanOrEqualToBigDecimal = (max, annotations) => self => self.pipe(filter(a => bigDecimal_.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanOrEqualToBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const PositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/PositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const positiveBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isPositive(a), {
  typeId: {
    id: PositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a positive BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export const PositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf",
  title: "PositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const NonNegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const nonNegativeBigDecimal = annotations => self => self.pipe(filter(a => a.value >= 0n, {
  typeId: {
    id: NonNegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-negative BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export const NonNegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf",
  title: "NonNegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const NegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const negativeBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isNegative(a), {
  typeId: {
    id: NegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a negative BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export const NegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf",
  title: "NegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const NonPositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonPositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const nonPositiveBigDecimal = annotations => self => self.pipe(filter(a => a.value <= 0n, {
  typeId: {
    id: NonPositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-positive BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export const NonPositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf",
  title: "NonPositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
export const BetweenBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export const betweenBigDecimal = (minimum, maximum, annotations) => self => self.pipe(filter(a => bigDecimal_.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenBigDecimalTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,
  ...annotations
}));
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export const clampBigDecimal = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: self => bigDecimal_.clamp(self, {
    minimum,
    maximum
  }),
  encode: identity
});
const chunkArbitrary = item => fc => fc.array(item(fc)).map(chunk_.fromIterable);
const chunkPretty = item => c => `Chunk(${chunk_.toReadonlyArray(c).map(item).join(", ")})`;
const chunkParse = decodeUnknown => (u, options, ast) => chunk_.isChunk(u) ? chunk_.isEmpty(u) ? ParseResult.succeed(chunk_.empty()) : ParseResult.map(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export const ChunkFromSelf = value => {
  return declare([value], {
    decode: item => chunkParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => chunkParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `Chunk<${format(value)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export const Chunk = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ChunkFromSelf(typeSchema(value_)), {
    decode: as => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),
    encode: chunk_.toReadonlyArray
  });
};
const toData = a => Array.isArray(a) ? data_.array(a) : data_.struct(a);
const dataArbitrary = item => fc => item(fc).map(toData);
const dataPretty = item => d => `Data(${item(d)})`;
const dataParse = decodeUnknown => (u, options, ast) => Equal.isEqual(u) ? ParseResult.map(decodeUnknown(u, options), toData) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Data transformations
 * @since 1.0.0
 */
export const DataFromSelf = item => {
  return declare([item], {
    decode: item => dataParse(ParseResult.decodeUnknown(item)),
    encode: item => dataParse(ParseResult.encodeUnknown(item))
  }, {
    description: `Data<${format(item)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
/**
 * @category Data transformations
 * @since 1.0.0
 */
export const Data = item => transform(item, DataFromSelf(typeSchema(item)), {
  strict: false,
  decode: toData,
  encode: a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
});
/**
 * @category classes
 * @since 1.0.0
 */
export const Class = identifier => (fields, annotations) => makeClass({
  kind: "Class",
  identifier,
  fields,
  Base: data_.Class,
  annotations
});
/**
 * @category classes
 * @since 1.0.0
 */
export const TaggedClass = identifier => (tag, fields, annotations) => makeClass({
  kind: "TaggedClass",
  identifier: identifier ?? tag,
  fields: extendFields({
    _tag: Literal(tag)
  }, fields),
  Base: data_.Class,
  tag: {
    _tag: tag
  },
  annotations
});
/**
 * @category classes
 * @since 1.0.0
 */
export const TaggedError = identifier => (tag, fields, annotations) => {
  class Base extends data_.Error {}
  ;
  Base.prototype.name = tag;
  return makeClass({
    kind: "TaggedError",
    identifier: identifier ?? tag,
    fields: extendFields({
      _tag: Literal(tag)
    }, fields),
    Base,
    tag: {
      _tag: tag
    },
    annotations,
    toStringOverride(self) {
      if (Predicate.isString(self.message) && self.message.length > 0) {
        let message = `${self._tag}: ${self.message}`;
        if (Predicate.isString(self.stack)) {
          message = `${message}\n${self.stack.split("\n").slice(1).join("\n")}`;
        }
        return message;
      }
    }
  });
};
/**
 * @category classes
 * @since 1.0.0
 */
export const TaggedRequest = identifier => (tag, Failure, Success, fields, annotations) => {
  class SerializableRequest extends Request.Class {
    get [serializable_.symbol]() {
      return this.constructor;
    }
    get [serializable_.symbolResult]() {
      return {
        Failure,
        Success
      };
    }
  }
  return makeClass({
    kind: "TaggedRequest",
    identifier: identifier ?? tag,
    fields: extendFields({
      _tag: Literal(tag)
    }, fields),
    Base: SerializableRequest,
    tag: {
      _tag: tag
    },
    annotations
  });
};
const extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const name of util_.ownKeys(b)) {
    if (name in a) {
      throw new Error(errors_.getDuplicatePropertySignatureErrorMessage(name));
    }
    out[name] = b[name];
  }
  return out;
};
const makeClass = ({
  Base,
  annotations,
  fields,
  fromSchema,
  identifier,
  kind,
  tag,
  toStringOverride
}) => {
  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier}`);
  const schema = fromSchema ?? Struct(fields);
  const validate = ParseResult.validateSync(schema);
  const from = option_.match(AST.getTitleAnnotation(schema.ast), {
    onNone: () => schema.annotations({
      title: `${identifier} (Encoded side)`
    }),
    onSome: () => schema
  });
  return class extends Base {
    constructor(props = {}, disableValidation = false) {
      if (tag !== undefined) {
        props = {
          ...props,
          ...tag
        };
      }
      if (disableValidation !== true) {
        props = validate(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId] = variance;
    static get ast() {
      const toSchema = typeSchema(schema);
      const guard = ParseResult.is(toSchema);
      const fallbackInstanceOf = u => Predicate.hasProperty(u, classSymbol) && guard(u);
      const encode = ParseResult.encodeUnknown(toSchema);
      const declaration = declare([toSchema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input)),
        encode: () => (input, options) => input instanceof this ? ParseResult.succeed(input) : ParseResult.map(encode(input, options), props => new this(props, true))
      }, {
        identifier,
        title: identifier,
        description: `an instance of ${identifier}`,
        pretty: pretty => self => `${identifier}(${pretty(self)})`,
        arbitrary: arb => fc => arb(fc).map(props => new this(props)),
        equivalence: identity,
        [AST.SurrogateAnnotationId]: toSchema.ast,
        ...annotations
      });
      const transformation = transform(from, declaration, {
        decode: input => new this(input, true),
        encode: identity
      }).annotations({
        [AST.SurrogateAnnotationId]: schema.ast
      });
      return transformation.ast;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations) {
      return make(this.ast).annotations(annotations);
    }
    static toString() {
      return `(${String(from)} <-> ${identifier})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static fields = {
      ...fields
    };
    static identifier = identifier;
    static extend(identifier) {
      return (newFields, annotations) => {
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fields: extendedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    static transformOrFail(identifier) {
      return (newFields, options, annotations) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fromSchema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    static transformOrFailFrom(identifier) {
      return (newFields, options, annotations) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fromSchema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
    toString() {
      if (toStringOverride !== undefined) {
        const out = toStringOverride(this);
        if (out !== undefined) {
          return out;
        }
      }
      return `${identifier}({ ${util_.ownKeys(fields).map(p => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`).join(", ")} })`;
    }
  };
};
const FiberIdNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
const FiberIdRuntimeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Runtime"),
  id: Int.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
const FiberIdCompositeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Composite"),
  left: suspend(() => FiberIdEncoded),
  right: suspend(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
const FiberIdEncoded = /*#__PURE__*/Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
const fiberIdArbitrary = fc => fc.letrec(tie => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
const fiberIdPretty = fiberId => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
  }
};
/**
 * @category FiberId constructors
 * @since 1.0.0
 */
export const FiberIdFromSelf = /*#__PURE__*/declare(fiberId_.isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
});
const fiberIdDecode = input => {
  switch (input._tag) {
    case "None":
      return fiberId_.none;
    case "Runtime":
      return fiberId_.runtime(input.id, input.startTimeMillis);
    case "Composite":
      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
/**
 * @category FiberId transformations
 * @since 1.0.0
 */
export const FiberId = /*#__PURE__*/transform(FiberIdEncoded, FiberIdFromSelf, {
  decode: fiberIdDecode,
  encode: fiberIdEncode
}).annotations({
  identifier: "FiberId"
});
const causeDieEncoded = defect => Struct({
  _tag: Literal("Die"),
  defect
});
const CauseEmptyEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Empty")
});
const causeFailEncoded = error => Struct({
  _tag: Literal("Fail"),
  error
});
const CauseInterruptEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Interrupt"),
  fiberId: FiberIdEncoded
});
const causeParallelEncoded = causeEncoded => Struct({
  _tag: Literal("Parallel"),
  left: causeEncoded,
  right: causeEncoded
});
const causeSequentialEncoded = causeEncoded => Struct({
  _tag: Literal("Sequential"),
  left: causeEncoded,
  right: causeEncoded
});
const causeEncoded = (error, defect) => {
  const recur = suspend(() => out);
  const out = Union(CauseEmptyEncoded, causeFailEncoded(error), causeDieEncoded(defect), CauseInterruptEncoded, causeSequentialEncoded(recur), causeParallelEncoded(recur)).annotations({
    description: `CauseEncoded<${format(error)}>`
  });
  return out;
};
const causeArbitrary = (error, defect) => fc => fc.letrec(tie => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
const causePretty = error => cause => {
  const f = cause => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error(cause.error)})`;
      case "Die":
        return `Cause.die(${cause_.pretty(cause)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
    }
  };
  return f(cause);
};
const causeParse = decodeUnknown => (u, options, ast) => cause_.isCause(u) ? ParseResult.map(decodeUnknown(causeEncode(u), options), causeDecode) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export const CauseFromSelf = ({
  defect = Unknown,
  error
}) => {
  return declare([error, defect], {
    decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),
    encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))
  }, {
    description: `Cause<${format(error)}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause) {
  switch (cause._tag) {
    case "Empty":
      return cause_.empty;
    case "Fail":
      return cause_.fail(cause.error);
    case "Die":
      return cause_.die(cause.defect);
    case "Interrupt":
      return cause_.interrupt(fiberIdDecode(cause.fiberId));
    case "Sequential":
      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right));
    case "Parallel":
      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right));
  }
}
function causeEncode(cause) {
  switch (cause._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
  }
}
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export const CauseDefectUnknown = /*#__PURE__*/transform(Unknown, Unknown, {
  decode: u => {
    if (Predicate.isObject(u) && "message" in u && typeof u.message === "string") {
      const err = new Error(u.message, {
        cause: u
      });
      if ("name" in u && typeof u.name === "string") {
        err.name = u.name;
      }
      err.stack = "stack" in u && typeof u.stack === "string" ? u.stack : "";
      return err;
    }
    return String(u);
  },
  encode: defect => {
    if (defect instanceof Error) {
      return {
        name: defect.name,
        message: defect.message
      };
    }
    return String(defect);
  }
});
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export const Cause = ({
  defect = CauseDefectUnknown,
  error
}) => {
  const error_ = asSchema(error);
  return transform(causeEncoded(error_, defect), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect)
  }), {
    decode: causeDecode,
    encode: causeEncode
  });
};
const exitFailureEncoded = (error, defect) => Struct({
  _tag: Literal("Failure"),
  cause: causeEncoded(error, defect)
}).annotations({
  description: `FailureEncoded<${format(error)}>`
});
const exitSuccessEncoded = value => Struct({
  _tag: Literal("Success"),
  value
}).annotations({
  description: `SuccessEncoded<${format(value)}>`
});
const exitEncoded = (value, error, defect) => Union(exitFailureEncoded(error, defect), exitSuccessEncoded(value)).annotations({
  description: `ExitEncoded<${format(value)}, ${format(error)}>`
});
const exitDecode = input => {
  switch (input._tag) {
    case "Failure":
      return exit_.failCause(causeDecode(input.cause));
    case "Success":
      return exit_.succeed(input.value);
  }
};
const exitArbitrary = (value, error, defect) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value(fc)
})).map(exitDecode);
const exitPretty = (value, error) => exit => exit._tag === "Failure" ? `Exit.failCause(${causePretty(error)(exit.cause)})` : `Exit.succeed(${value(exit.value)})`;
const exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => exit_.isExit(u) ? exit_.match(u, {
  onFailure: cause => ParseResult.map(decodeUnknownCause(cause, options), exit_.failCause),
  onSuccess: value => ParseResult.map(decodeUnknownValue(value, options), exit_.succeed)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export const ExitFromSelf = ({
  defect = Unknown,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success, failure, defect) => exitParse(ParseResult.decodeUnknown(success), ParseResult.decodeUnknown(CauseFromSelf({
    error: failure,
    defect
  }))),
  encode: (success, failure, defect) => exitParse(ParseResult.encodeUnknown(success), ParseResult.encodeUnknown(CauseFromSelf({
    error: failure,
    defect
  })))
}, {
  description: `Exit<${format(success)}, ${format(failure)}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export const Exit = ({
  defect = CauseDefectUnknown,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  return transform(exitEncoded(success_, failure_, defect), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect)
  }), {
    decode: exitDecode,
    encode: exit => exit._tag === "Failure" ? {
      _tag: "Failure",
      cause: exit.cause
    } : {
      _tag: "Success",
      value: exit.value
    }
  });
};
const hashSetArbitrary = item => fc => fc.array(item(fc)).map(as => hashSet_.fromIterable(as));
const hashSetPretty = item => set => `HashSet(${Array.from(set).map(a => item(a)).join(", ")})`;
const hashSetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashSetParse = decodeUnknown => (u, options, ast) => hashSet_.isHashSet(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => hashSet_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export const HashSetFromSelf = value => {
  return declare([value], {
    decode: item => hashSetParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => hashSetParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `HashSet<${format(value)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export const HashSet = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), HashSetFromSelf(typeSchema(value_)), {
    decode: as => hashSet_.fromIterable(as),
    encode: set => Array.from(set)
  });
};
const hashMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => hashMap_.fromIterable(as));
const hashMapPretty = (key, value) => map => `HashMap([${Array.from(map).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const hashMapEquivalence = (key, value) => {
  const arrayEquivalence = array_.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashMapParse = decodeUnknown => (u, options, ast) => hashMap_.isHashMap(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => hashMap_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export const HashMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], {
    decode: (key, value) => hashMapParse(ParseResult.decodeUnknown($Array(Tuple(key, value)))),
    encode: (key, value) => hashMapParse(ParseResult.encodeUnknown($Array(Tuple(key, value))))
  }, {
    description: `HashMap<${format(key)}, ${format(value)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export const HashMap = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), HashMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => hashMap_.fromIterable(as),
    encode: map => Array.from(map)
  });
};
const listArbitrary = item => fc => fc.array(item(fc)).map(as => list_.fromIterable(as));
const listPretty = item => set => `List(${Array.from(set).map(a => item(a)).join(", ")})`;
const listEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const listParse = decodeUnknown => (u, options, ast) => list_.isList(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => list_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category List transformations
 * @since 1.0.0
 */
export const ListFromSelf = value => {
  return declare([value], {
    decode: item => listParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => listParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `List<${format(value)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
/**
 * @category List transformations
 * @since 1.0.0
 */
export const List = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ListFromSelf(typeSchema(value_)), {
    decode: as => list_.fromIterable(as),
    encode: set => Array.from(set)
  });
};
const sortedSetArbitrary = (item, ord) => fc => fc.array(item(fc)).map(as => sortedSet_.fromIterable(as, ord));
const sortedSetPretty = item => set => `new SortedSet([${Array.from(sortedSet_.values(set)).map(a => item(a)).join(", ")}])`;
const sortedSetParse = (decodeUnknown, ord) => (u, options, ast) => sortedSet_.isSortedSet(u) ? ParseResult.map(decodeUnknown(Array.from(sortedSet_.values(u)), options), as => sortedSet_.fromIterable(as, ord)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
export const SortedSetFromSelf = (value, ordA, ordI) => {
  return declare([value], {
    decode: item => sortedSetParse(ParseResult.decodeUnknown($Array(item)), ordA),
    encode: item => sortedSetParse(ParseResult.encodeUnknown($Array(item)), ordI)
  }, {
    description: `SortedSet<${format(value)}>`,
    pretty: sortedSetPretty,
    arbitrary: arb => sortedSetArbitrary(arb, ordA),
    equivalence: () => sortedSet_.getEquivalence()
  });
};
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
export const SortedSet = (value, ordA) => {
  const value_ = asSchema(value);
  const to = typeSchema(value_);
  return transform($Array(value_), SortedSetFromSelf(to, ordA, ordA), {
    decode: as => sortedSet_.fromIterable(as, ordA),
    encode: set => Array.from(sortedSet_.values(set))
  });
};
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 * @category boolean constructors
 * @since 1.0.0
 */
export const BooleanFromUnknown = /*#__PURE__*/transform(Unknown, $Boolean, {
  decode: Predicate.isTruthy,
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
});
//# sourceMappingURL=Schema.js.map