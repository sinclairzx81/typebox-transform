"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.DEFINITION_PREFIX = void 0;
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Option"));
var Predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Predicate"));
var Record = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Record"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./AST.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/**
 * @since 1.0.0
 */

/**
 * @category encoding
 * @since 1.0.0
 */
const make = schema => {
  const $defs = {};
  const jsonSchema = go(schema.ast, $defs);
  const out = {
    $schema,
    ...jsonSchema
  };
  // clean up self-referencing entries
  for (const id in $defs) {
    if ($defs[id]["$ref"] === get$ref(id)) {
      delete $defs[id];
    }
  }
  if (!Record.isEmptyRecord($defs)) {
    out.$defs = $defs;
  }
  return out;
};
exports.make = make;
const anyJsonSchema = {
  $id: "/schemas/any"
};
const unknownJsonSchema = {
  $id: "/schemas/unknown"
};
const objectJsonSchema = {
  "$id": "/schemas/object",
  "oneOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
const empty = () => ({
  "$id": "/schemas/{}",
  "oneOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
});
const $schema = "http://json-schema.org/draft-07/schema#";
const getMeta = annotated => Record.getSomes({
  description: AST.getDescriptionAnnotation(annotated),
  title: AST.getTitleAnnotation(annotated),
  examples: AST.getExamplesAnnotation(annotated),
  default: AST.getDefaultAnnotation(annotated)
});
const pruneUndefinedKeyword = ps => {
  const type = ps.type;
  if (ps.isOptional && AST.isUnion(type) && Option.isNone(AST.getJSONSchemaAnnotation(type))) {
    return AST.Union.make(type.types.filter(type => !AST.isUndefinedKeyword(type)), type.annotations);
  }
  return type;
};
const getMissingAnnotationError = name => {
  const out = new Error(`cannot build a JSON Schema for ${name} without a JSON Schema annotation`);
  out.name = "MissingAnnotation";
  return out;
};
const getUnsupportedIndexSignatureParameterErrorMessage = parameter => `Unsupported index signature parameter (${parameter})`;
/** @internal */
const DEFINITION_PREFIX = exports.DEFINITION_PREFIX = "#/$defs/";
const get$ref = id => `${DEFINITION_PREFIX}${id}`;
const go = (ast, $defs, handleIdentifier = true) => {
  const hook = AST.getJSONSchemaAnnotation(ast);
  if (Option.isSome(hook)) {
    const handler = hook.value;
    switch (ast._tag) {
      case "Refinement":
        try {
          return {
            ...go(ast.from, $defs),
            ...getMeta(ast),
            ...handler
          };
        } catch (e) {
          if (e instanceof Error && e.name === "MissingAnnotation") {
            return {
              ...getMeta(ast),
              ...handler
            };
          }
          throw e;
        }
    }
    return handler;
  }
  const surrogate = AST.getSurrogateAnnotation(ast);
  if (Option.isSome(surrogate)) {
    return go(surrogate.value, $defs, handleIdentifier);
  }
  if (handleIdentifier) {
    const identifier = AST.getJSONIdentifier(ast);
    if (Option.isSome(identifier)) {
      const id = identifier.value;
      const out = {
        $ref: get$ref(id)
      };
      if (!Record.has($defs, id)) {
        $defs[id] = out;
        $defs[id] = go(ast, $defs, false);
      }
      return out;
    }
  }
  switch (ast._tag) {
    case "Declaration":
      throw getMissingAnnotationError("a declaration");
    case "Literal":
      {
        const literal = ast.literal;
        if (literal === null) {
          return {
            const: null,
            ...getMeta(ast)
          };
        } else if (Predicate.isString(literal)) {
          return {
            const: literal,
            ...getMeta(ast)
          };
        } else if (Predicate.isNumber(literal)) {
          return {
            const: literal,
            ...getMeta(ast)
          };
        } else if (Predicate.isBoolean(literal)) {
          return {
            const: literal,
            ...getMeta(ast)
          };
        }
        throw getMissingAnnotationError("a bigint literal");
      }
    case "UniqueSymbol":
      throw getMissingAnnotationError("a unique symbol");
    case "UndefinedKeyword":
      throw getMissingAnnotationError("`undefined`");
    case "VoidKeyword":
      throw getMissingAnnotationError("`void`");
    case "NeverKeyword":
      throw getMissingAnnotationError("`never`");
    case "UnknownKeyword":
      return {
        ...unknownJsonSchema,
        ...getMeta(ast)
      };
    case "AnyKeyword":
      return {
        ...anyJsonSchema,
        ...getMeta(ast)
      };
    case "ObjectKeyword":
      return {
        ...objectJsonSchema,
        ...getMeta(ast)
      };
    case "StringKeyword":
      return {
        type: "string",
        ...getMeta(ast)
      };
    case "NumberKeyword":
      return {
        type: "number",
        ...getMeta(ast)
      };
    case "BooleanKeyword":
      return {
        type: "boolean",
        ...getMeta(ast)
      };
    case "BigIntKeyword":
      throw getMissingAnnotationError("`bigint`");
    case "SymbolKeyword":
      throw getMissingAnnotationError("`symbol`");
    case "TupleType":
      {
        const elements = ast.elements.map(e => go(e.type, $defs));
        const rest = ast.rest.map(ast => go(ast, $defs));
        const output = {
          type: "array"
        };
        // ---------------------------------------------
        // handle elements
        // ---------------------------------------------
        const len = elements.length;
        if (len > 0) {
          output.minItems = len - ast.elements.filter(element => element.isOptional).length;
          output.items = elements;
        }
        // ---------------------------------------------
        // handle rest element
        // ---------------------------------------------
        if (rest.length > 0) {
          const head = rest[0];
          if (len > 0) {
            output.additionalItems = head;
          } else {
            output.items = head;
          }
          // ---------------------------------------------
          // handle post rest elements
          // ---------------------------------------------
          if (rest.length > 1) {
            throw new Error("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request.");
          }
        } else {
          if (len > 0) {
            output.additionalItems = false;
          } else {
            output.maxItems = 0;
          }
        }
        return {
          ...output,
          ...getMeta(ast)
        };
      }
    case "TypeLiteral":
      {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return {
            ...empty(),
            ...getMeta(ast)
          };
        }
        let additionalProperties = undefined;
        let patternProperties = undefined;
        for (const is of ast.indexSignatures) {
          const parameter = is.parameter;
          switch (parameter._tag) {
            case "StringKeyword":
              {
                additionalProperties = go(is.type, $defs);
                break;
              }
            case "TemplateLiteral":
              {
                patternProperties = {
                  [AST.getTemplateLiteralRegExp(parameter).source]: go(is.type, $defs)
                };
                break;
              }
            case "Refinement":
              {
                const hook = AST.getJSONSchemaAnnotation(parameter);
                if (Option.isSome(hook) && "pattern" in hook.value && Predicate.isString(hook.value.pattern)) {
                  patternProperties = {
                    [hook.value.pattern]: go(is.type, $defs)
                  };
                  break;
                }
                throw new Error(getUnsupportedIndexSignatureParameterErrorMessage(parameter));
              }
            case "SymbolKeyword":
              throw new Error(getUnsupportedIndexSignatureParameterErrorMessage(parameter));
          }
        }
        const propertySignatures = ast.propertySignatures.map(ps => {
          return {
            ...go(pruneUndefinedKeyword(ps), $defs),
            ...getMeta(ps)
          };
        });
        const output = {
          type: "object",
          required: [],
          properties: {},
          additionalProperties: false
        };
        // ---------------------------------------------
        // handle property signatures
        // ---------------------------------------------
        for (let i = 0; i < propertySignatures.length; i++) {
          const name = ast.propertySignatures[i].name;
          if (Predicate.isString(name)) {
            output.properties[name] = propertySignatures[i];
            // ---------------------------------------------
            // handle optional property signatures
            // ---------------------------------------------
            if (!ast.propertySignatures[i].isOptional) {
              output.required.push(name);
            }
          } else {
            throw new Error(`cannot encode ${String(name)} key to JSON Schema`);
          }
        }
        // ---------------------------------------------
        // handle index signatures
        // ---------------------------------------------
        if (additionalProperties !== undefined) {
          output.additionalProperties = additionalProperties;
        }
        if (patternProperties !== undefined) {
          output.patternProperties = patternProperties;
        }
        return {
          ...output,
          ...getMeta(ast)
        };
      }
    case "Union":
      {
        const enums = [];
        const anyOf = [];
        for (const type of ast.types) {
          const schema = go(type, $defs);
          if ("const" in schema) {
            if (Object.keys(schema).length > 1) {
              anyOf.push(schema);
            } else {
              enums.push(schema.const);
            }
          } else {
            anyOf.push(schema);
          }
        }
        if (anyOf.length === 0) {
          if (enums.length === 1) {
            return {
              const: enums[0],
              ...getMeta(ast)
            };
          } else {
            return {
              enum: enums,
              ...getMeta(ast)
            };
          }
        } else {
          if (enums.length === 1) {
            anyOf.push({
              const: enums[0]
            });
          } else if (enums.length > 1) {
            anyOf.push({
              enum: enums
            });
          }
          return {
            anyOf,
            ...getMeta(ast)
          };
        }
      }
    case "Enums":
      {
        return {
          $comment: "/schemas/enums",
          oneOf: ast.enums.map(e => ({
            title: e[0],
            const: e[1]
          })),
          ...getMeta(ast)
        };
      }
    case "Refinement":
      {
        throw new Error("cannot build a JSON Schema for a refinement without a JSON Schema annotation");
      }
    case "TemplateLiteral":
      {
        const regex = AST.getTemplateLiteralRegExp(ast);
        return {
          type: "string",
          description: "a template literal",
          pattern: regex.source,
          ...getMeta(ast)
        };
      }
    case "Suspend":
      {
        const identifier = Option.orElse(AST.getJSONIdentifier(ast), () => AST.getJSONIdentifier(ast.f()));
        if (Option.isNone(identifier)) {
          throw new Error("Generating a JSON Schema for suspended schemas requires an identifier annotation");
        }
        return go(ast.f(), $defs);
      }
    case "Transformation":
      return go(ast.to, $defs);
  }
};
//# sourceMappingURL=JSONSchema.js.map