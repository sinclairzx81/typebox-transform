"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ListFromSelf = exports.List = exports.LessThanTypeId = exports.LessThanOrEqualToTypeId = exports.LessThanOrEqualToDurationTypeId = exports.LessThanOrEqualToBigIntTypeId = exports.LessThanOrEqualToBigDecimalTypeId = exports.LessThanDurationTypeId = exports.LessThanBigIntTypeId = exports.LessThanBigDecimalTypeId = exports.LengthTypeId = exports.JsonNumberTypeId = exports.JsonNumber = exports.ItemsCountTypeId = exports.IntTypeId = exports.Int = exports.InstanceOfTypeId = exports.IncludesTypeId = exports.Hex = exports.HashSetFromSelf = exports.HashSet = exports.HashMapFromSelf = exports.HashMap = exports.GreaterThanTypeId = exports.GreaterThanOrEqualToTypeId = exports.GreaterThanOrEqualToDurationTypeId = exports.GreaterThanOrEqualToBigIntTypeId = exports.GreaterThanOrEqualToBigDecimalTypeId = exports.GreaterThanDurationTypeId = exports.GreaterThanBigIntTypeId = exports.GreaterThanBigDecimalTypeId = exports.FromPropertySignature = exports.FiniteTypeId = exports.Finite = exports.FiberIdFromSelf = exports.FiberId = exports.ExitFromSelf = exports.Exit = exports.Enums = exports.EndsWithTypeId = exports.EitherFromUnion = exports.EitherFromSelf = exports.Either = exports.DurationFromSelf = exports.DurationFromNanos = exports.DurationFromMillis = exports.Duration = exports.DateFromString = exports.DateFromSelf = exports.Date = exports.DataFromSelf = exports.Data = exports.Class = exports.ChunkFromSelf = exports.Chunk = exports.Char = exports.CauseFromSelf = exports.CauseDefectUnknown = exports.Cause = exports.BrandTypeId = exports.BooleanFromUnknown = exports.Boolean = exports.BigIntFromSelf = exports.BigIntFromNumber = exports.BigInt = exports.BigDecimalFromSelf = exports.BigDecimalFromNumber = exports.BigDecimal = exports.BetweenTypeId = exports.BetweenDurationTypeId = exports.BetweenBigIntTypeId = exports.BetweenBigDecimalTypeId = exports.Base64Url = exports.Base64 = exports.Array = exports.Any = void 0;
exports.Literal = Literal;
exports.NonNegativeBigDecimalTypeId = exports.NonNegativeBigDecimalFromSelf = exports.NonNegative = exports.NonNaNTypeId = exports.NonNaN = exports.NonEmptyArray = exports.NonEmpty = exports.Never = exports.NegativeBigIntFromSelf = exports.NegativeBigInt = exports.NegativeBigDecimalTypeId = exports.NegativeBigDecimalFromSelf = exports.Negative = exports.MultipleOfTypeId = exports.MinLengthTypeId = exports.MinItemsTypeId = exports.MaxLengthTypeId = exports.MaxItemsTypeId = exports.MapFromSelf = exports.Map = exports.LowercasedTypeId = exports.Lowercased = exports.Lowercase = void 0;
exports.String = exports.StartsWithTypeId = exports.SortedSetFromSelf = exports.SortedSet = exports.SetFromSelf = exports.Set = exports.SecretFromSelf = exports.Secret = exports.Record = exports.ReadonlySetFromSelf = exports.ReadonlySet = exports.ReadonlyMapFromSelf = exports.ReadonlyMap = exports.PropertySignatureTypeId = exports.PropertySignatureTransformation = exports.PropertySignatureImpl = exports.PropertySignatureDeclaration = exports.PositiveBigIntFromSelf = exports.PositiveBigInt = exports.PositiveBigDecimalTypeId = exports.PositiveBigDecimalFromSelf = exports.Positive = exports.PatternTypeId = exports.OptionFromUndefinedOr = exports.OptionFromSelf = exports.OptionFromNullishOr = exports.OptionFromNullOr = exports.Option = exports.Object = exports.NumberFromString = exports.Number = exports.NullishOr = exports.NullOr = exports.Null = exports.Not = exports.NonPositiveBigIntFromSelf = exports.NonPositiveBigInt = exports.NonPositiveBigDecimalTypeId = exports.NonPositiveBigDecimalFromSelf = exports.NonPositive = exports.NonNegativeBigIntFromSelf = exports.NonNegativeBigInt = void 0;
exports.Struct = Struct;
exports.TrimmedTypeId = exports.Trimmed = exports.Trim = exports.ToPropertySignature = exports.TemplateLiteral = exports.TaggedRequest = exports.TaggedError = exports.TaggedClass = exports.SymbolFromSelf = exports.Symbol = void 0;
exports.Tuple = Tuple;
exports.UndefinedOr = exports.Undefined = exports.Uint8ArrayFromSelf = exports.Uint8Array = exports.UUIDTypeId = exports.UUID = exports.ULIDTypeId = exports.ULID = exports.TypeId = void 0;
exports.Union = Union;
exports.asSchema = exports.asBrandSchema = exports.annotations = exports.Void = exports.ValidDateTypeId = exports.ValidDateFromSelf = exports.UppercasedTypeId = exports.Uppercased = exports.Uppercase = exports.Unknown = exports.UniqueSymbolFromSelf = void 0;
Object.defineProperty(exports, "asserts", {
  enumerable: true,
  get: function () {
    return ParseResult.asserts;
  }
});
exports.decodeEither = exports.decode = exports.declare = exports.concurrency = exports.compose = exports.clampDuration = exports.clampBigInt = exports.clampBigDecimal = exports.clamp = exports.brand = exports.betweenDuration = exports.betweenBigInt = exports.betweenBigDecimal = exports.between = exports.batching = exports.attachPropertySignature = void 0;
Object.defineProperty(exports, "decodeOption", {
  enumerable: true,
  get: function () {
    return ParseResult.decodeOption;
  }
});
exports.decodePromise = void 0;
Object.defineProperty(exports, "decodeSync", {
  enumerable: true,
  get: function () {
    return ParseResult.decodeSync;
  }
});
exports.decodeUnknownEither = exports.decodeUnknown = void 0;
Object.defineProperty(exports, "decodeUnknownOption", {
  enumerable: true,
  get: function () {
    return ParseResult.decodeUnknownOption;
  }
});
exports.decodeUnknownPromise = void 0;
Object.defineProperty(exports, "decodeUnknownSync", {
  enumerable: true,
  get: function () {
    return ParseResult.decodeUnknownSync;
  }
});
exports.encodeEither = exports.encode = exports.documentation = exports.description = exports.default = void 0;
Object.defineProperty(exports, "encodeOption", {
  enumerable: true,
  get: function () {
    return ParseResult.encodeOption;
  }
});
exports.encodePromise = void 0;
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return ParseResult.encodeSync;
  }
});
exports.encodeUnknownEither = exports.encodeUnknown = void 0;
Object.defineProperty(exports, "encodeUnknownOption", {
  enumerable: true,
  get: function () {
    return ParseResult.encodeUnknownOption;
  }
});
exports.encodeUnknownPromise = void 0;
Object.defineProperty(exports, "encodeUnknownSync", {
  enumerable: true,
  get: function () {
    return ParseResult.encodeUnknownSync;
  }
});
exports.extend = exports.examples = exports.equivalence = exports.endsWith = exports.encodedSchema = void 0;
exports.filter = filter;
exports.int = exports.instanceOf = exports.includes = exports.identifier = exports.headOrElse = exports.head = exports.hash = exports.greaterThanOrEqualToDuration = exports.greaterThanOrEqualToBigInt = exports.greaterThanOrEqualToBigDecimal = exports.greaterThanOrEqualTo = exports.greaterThanDuration = exports.greaterThanBigInt = exports.greaterThanBigDecimal = exports.greaterThan = exports.getNumberIndexedAccess = exports.fromKey = exports.fromBrand = exports.format = exports.finite = void 0;
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return ParseResult.is;
  }
});
exports.transformLiteral = exports.transform = exports.title = exports.suspend = exports.startsWith = exports.split = exports.required = exports.rename = exports.propertySignature = exports.positiveBigInt = exports.positiveBigDecimal = exports.positive = exports.pluck = exports.pickLiteral = exports.pick = exports.pattern = exports.partial = exports.parseJson = exports.parseIssueTitle = exports.optionalToRequired = exports.optionalToOptional = exports.optionalElement = exports.optional = exports.omit = exports.nonPositiveBigInt = exports.nonPositiveBigDecimal = exports.nonPositive = exports.nonNegativeBigInt = exports.nonNegativeBigDecimal = exports.nonNegative = exports.nonNaN = exports.nonEmpty = exports.negativeBigInt = exports.negativeBigDecimal = exports.negative = exports.mutable = exports.multipleOf = exports.minLength = exports.minItems = exports.message = exports.maxLength = exports.maxItems = exports.make = exports.lowercased = exports.lessThanOrEqualToDuration = exports.lessThanOrEqualToBigInt = exports.lessThanOrEqualToBigDecimal = exports.lessThanOrEqualTo = exports.lessThanDuration = exports.lessThanBigInt = exports.lessThanBigDecimal = exports.lessThan = exports.length = exports.keyof = exports.jsonSchema = exports.itemsCount = exports.isSchema = void 0;
exports.transformLiterals = transformLiterals;
exports.trimmed = exports.transformOrFail = void 0;
exports.validateEither = exports.validate = exports.validDate = exports.uppercased = exports.typeSchema = void 0;
Object.defineProperty(exports, "validateOption", {
  enumerable: true,
  get: function () {
    return ParseResult.validateOption;
  }
});
exports.validatePromise = void 0;
Object.defineProperty(exports, "validateSync", {
  enumerable: true,
  get: function () {
    return ParseResult.validateSync;
  }
});
var array_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Array"));
var bigDecimal_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/BigDecimal"));
var bigInt_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/BigInt"));
var boolean_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Boolean"));
var brand_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Brand"));
var cause_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Cause"));
var chunk_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Chunk"));
var data_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Data"));
var duration_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Duration"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Effect"));
var either_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Either"));
var Encoding = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Encoding"));
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Equal"));
var Equivalence = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Equivalence"));
var exit_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Exit"));
var fiberId_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/FiberId"));
var _Function = /*#__PURE__*/require("effect/Function");
var hashMap_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/HashMap"));
var hashSet_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/HashSet"));
var list_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/List"));
var number_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Number"));
var option_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Option"));
var _Pipeable = /*#__PURE__*/require("effect/Pipeable");
var Predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Predicate"));
var Request = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Request"));
var secret_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Secret"));
var sortedSet_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/SortedSet"));
var string_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/String"));
var arbitrary_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Arbitrary.js"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./AST.js"));
var equivalence_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Equivalence.js"));
var errors_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/errors.js"));
var filters_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/filters.js"));
var serializable_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/serializable.js"));
var util_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/util.js"));
var ParseResult = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./ParseResult.js"));
var pretty_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./Pretty.js"));
var TreeFormatter = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./TreeFormatter.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category symbol
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/schema/Schema");
const variance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _I: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const toASTAnnotations = annotations => {
  if (!annotations) {
    return {};
  }
  const out = {};
  // symbols are reserved for custom annotations
  const custom = Object.getOwnPropertySymbols(annotations);
  for (const sym of custom) {
    out[sym] = annotations[sym];
  }
  // string keys are reserved as /schema namespace
  if (annotations.typeId !== undefined) {
    const typeId = annotations.typeId;
    if (typeof typeId === "object") {
      out[AST.TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[AST.TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations[from] !== undefined) {
      out[to] = annotations[from];
    }
  };
  move("message", AST.MessageAnnotationId);
  move("identifier", AST.IdentifierAnnotationId);
  move("title", AST.TitleAnnotationId);
  move("description", AST.DescriptionAnnotationId);
  move("examples", AST.ExamplesAnnotationId);
  move("default", AST.DefaultAnnotationId);
  move("documentation", AST.DocumentationAnnotationId);
  move("jsonSchema", AST.JSONSchemaAnnotationId);
  move("arbitrary", arbitrary_.ArbitraryHookId);
  move("pretty", pretty_.PrettyHookId);
  move("equivalence", equivalence_.EquivalenceHookId);
  move("concurrency", AST.ConcurrencyAnnotationId);
  move("batching", AST.BatchingAnnotationId);
  move("parseIssueTitle", AST.ParseIssueTitleAnnotationId);
  return out;
};
class SchemaImpl {
  ast;
  [TypeId] = variance;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  annotations(annotations) {
    return new SchemaImpl(AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
 * @since 1.0.0
 */
const asSchema = schema => schema;
/**
 * @category hashing
 * @since 1.0.0
 */
exports.asSchema = asSchema;
const hash = schema => AST.hash(schema.ast);
/**
 * @category formatting
 * @since 1.0.0
 */
exports.hash = hash;
const format = schema => String(schema.ast);
/**
 * @since 1.0.0
 */
exports.format = format;
const encodedSchema = schema => make(AST.encodedAST(schema.ast));
/**
 * @since 1.0.0
 */
exports.encodedSchema = encodedSchema;
const typeSchema = schema => make(AST.typeAST(schema.ast));
/* c8 ignore start */
exports.typeSchema = typeSchema;
/* c8 ignore end */
/**
 * @category encoding
 * @since 1.0.0
 */
const encodeUnknown = (schema, options) => {
  const encodeUnknown = ParseResult.encodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknown = encodeUnknown;
const encodeUnknownEither = (schema, options) => {
  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknownEither = encodeUnknownEither;
const encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category encoding
 * @since 1.0.0
 */
exports.encodeUnknownPromise = encodeUnknownPromise;
const encode = exports.encode = encodeUnknown;
/**
 * @category encoding
 * @since 1.0.0
 */
const encodeEither = exports.encodeEither = encodeUnknownEither;
/**
 * @category encoding
 * @since 1.0.0
 */
const encodePromise = exports.encodePromise = encodeUnknownPromise;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodeUnknown = (schema, options) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknown = decodeUnknown;
const decodeUnknownEither = (schema, options) => {
  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknownEither = decodeUnknownEither;
const decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * @category decoding
 * @since 1.0.0
 */
exports.decodeUnknownPromise = decodeUnknownPromise;
const decode = exports.decode = decodeUnknown;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodeEither = exports.decodeEither = decodeUnknownEither;
/**
 * @category decoding
 * @since 1.0.0
 */
const decodePromise = exports.decodePromise = decodeUnknownPromise;
/**
 * @category validation
 * @since 1.0.0
 */
const validate = (schema, options) => {
  const validate = ParseResult.validate(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
exports.validate = validate;
const validateEither = (schema, options) => {
  const validateEither = ParseResult.validateEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError);
};
/**
 * @category validation
 * @since 1.0.0
 */
exports.validateEither = validateEither;
const validatePromise = (schema, options) => {
  const parser = validate(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
exports.validatePromise = validatePromise;
const isSchema = u => Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId]);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.isSchema = isSchema;
const make = ast => new SchemaImpl(ast);
exports.make = make;
class LiteralImpl extends SchemaImpl {
  static ast = literals => {
    return AST.isMembers(literals) ? AST.Union.make(AST.mapMembers(literals, literal => new AST.Literal(literal))) : new AST.Literal(literals[0]);
  };
  literals;
  constructor(literals, ast = LiteralImpl.ast(literals)) {
    super(ast);
    this.literals = [...literals];
  }
  annotations(annotations) {
    return new LiteralImpl(this.literals, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
function Literal(...literals) {
  return array_.isNonEmptyReadonlyArray(literals) ? new LiteralImpl(literals) : Never;
}
/**
 * Creates a new `Schema` from a literal schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { Either } from "effect"
 *
 * const schema = S.Literal("a", "b", "c").pipe(S.pickLiteral("a", "b"))
 *
 * assert.deepStrictEqual(S.decodeSync(schema)("a"), "a")
 * assert.deepStrictEqual(S.decodeSync(schema)("b"), "b")
 * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)("c")), true)
 *
 * @category constructors
 * @since 1.0.0
 */
const pickLiteral = (...literals) => _schema => Literal(...literals);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.pickLiteral = pickLiteral;
const UniqueSymbolFromSelf = symbol => make(new AST.UniqueSymbol(symbol));
exports.UniqueSymbolFromSelf = UniqueSymbolFromSelf;
class EnumsImpl extends SchemaImpl {
  enums;
  static ast = enums => {
    return new AST.Enums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]]));
  };
  constructor(enums, ast = EnumsImpl.ast(enums)) {
    super(ast);
    this.enums = enums;
  }
  annotations(annotations) {
    return new EnumsImpl(this.enums, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
const Enums = enums => new EnumsImpl(enums);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.Enums = Enums;
const TemplateLiteral = (...[head, ...tail]) => {
  let types = getTemplateLiterals(head.ast);
  for (const span of tail) {
    types = array_.flatMap(types, a => getTemplateLiterals(span.ast).map(b => combineTemplateLiterals(a, b)));
  }
  return make(AST.Union.make(types));
};
exports.TemplateLiteral = TemplateLiteral;
const combineTemplateLiterals = (a, b) => {
  if (AST.isLiteral(a)) {
    return AST.isLiteral(b) ? new AST.Literal(String(a.literal) + String(b.literal)) : AST.TemplateLiteral.make(String(a.literal) + b.head, b.spans);
  }
  if (AST.isLiteral(b)) {
    return AST.TemplateLiteral.make(a.head, array_.modifyNonEmptyLast(a.spans, span => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.literal))));
  }
  return AST.TemplateLiteral.make(a.head, array_.appendAll(array_.modifyNonEmptyLast(a.spans, span => new AST.TemplateLiteralSpan(span.type, span.literal + String(b.head))), b.spans));
};
const getTemplateLiterals = ast => {
  switch (ast._tag) {
    case "Literal":
      return [ast];
    case "NumberKeyword":
    case "StringKeyword":
      return [AST.TemplateLiteral.make("", [new AST.TemplateLiteralSpan(ast, "")])];
    case "Union":
      return array_.flatMap(ast.types, getTemplateLiterals);
    default:
      throw new Error(`unsupported template literal span (${ast})`);
  }
};
const declareConstructor = (typeParameters, options, annotations) => make(new AST.Declaration(typeParameters.map(tp => tp.ast), (...typeParameters) => options.decode(...typeParameters.map(make)), (...typeParameters) => options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input));
  const encodeUnknown = decodeUnknown;
  return make(new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 1.0.0
 */
const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations = arguments[2];
    return declareConstructor(typeParameters, options, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.declare = declare;
const BrandTypeId = exports.BrandTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Brand");
/**
 * @category constructors
 * @since 1.0.0
 */
const fromBrand = (constructor, annotations) => self => make(new AST.Refinement(self.ast, (a, _, ast) => {
  const either = constructor.either(a);
  return either_.isLeft(either) ? option_.some(new ParseResult.Type(ast, a, either.left.map(v => v.message).join(", "))) : option_.none();
}, toASTAnnotations({
  typeId: {
    id: BrandTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations
})));
/**
 * @category type id
 * @since 1.0.0
 */
exports.fromBrand = fromBrand;
const InstanceOfTypeId = exports.InstanceOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/InstanceOf");
/**
 * @category constructors
 * @since 1.0.0
 */
const instanceOf = (constructor, annotations) => declare(u => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  typeId: {
    id: InstanceOfTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations
});
/**
 * @category primitives
 * @since 1.0.0
 */
exports.instanceOf = instanceOf;
const Undefined = exports.Undefined = /*#__PURE__*/make(AST.undefinedKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const Void = exports.Void = /*#__PURE__*/make(AST.voidKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const Null = exports.Null = /*#__PURE__*/make(AST.null);
/**
 * @category primitives
 * @since 1.0.0
 */
const Never = exports.Never = /*#__PURE__*/make(AST.neverKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const Unknown = exports.Unknown = /*#__PURE__*/make(AST.unknownKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const Any = exports.Any = /*#__PURE__*/make(AST.anyKeyword);
const $String = exports.String = /*#__PURE__*/make(AST.stringKeyword);
const $Number = exports.Number = /*#__PURE__*/make(AST.numberKeyword);
const $Boolean = exports.Boolean = /*#__PURE__*/make(AST.booleanKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const BigIntFromSelf = exports.BigIntFromSelf = /*#__PURE__*/make(AST.bigIntKeyword);
/**
 * @category primitives
 * @since 1.0.0
 */
const SymbolFromSelf = exports.SymbolFromSelf = /*#__PURE__*/make(AST.symbolKeyword);
const $Object = exports.Object = /*#__PURE__*/make(AST.objectKeyword);
class UnionImpl extends SchemaImpl {
  static ast = members => {
    return AST.Union.members(members.map(m => m.ast));
  };
  members;
  constructor(members, ast = UnionImpl.ast(members)) {
    super(ast);
    this.members = [...members];
  }
  annotations(annotations) {
    return new UnionImpl(this.members, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
function Union(...members) {
  return AST.isMembers(members) ? new UnionImpl(members) : array_.isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
/**
 * @category combinators
 * @since 1.0.0
 */
const NullOr = self => Union(self, Null);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.NullOr = NullOr;
const UndefinedOr = self => Union(self, Undefined);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.UndefinedOr = UndefinedOr;
const NullishOr = self => Union(self, Null, Undefined);
/**
 * @category combinators
 * @since 1.0.0
 */
exports.NullishOr = NullishOr;
const keyof = self => make(AST.keyof(self.ast));
/**
 * @since 1.0.0
 */
exports.keyof = keyof;
const optionalElement = self => new OptionalElementImpl(self);
exports.optionalElement = optionalElement;
class OptionalElementImpl {
  optionalElement;
  [TypeId];
  constructor(optionalElement) {
    this.optionalElement = optionalElement;
  }
  toString() {
    return `${this.optionalElement.ast}?`;
  }
}
class TupleTypeImpl extends SchemaImpl {
  elements;
  rest;
  static ast = (elements, rest) => {
    return new AST.TupleType(elements.map(schema => isSchema(schema) ? new AST.Element(schema.ast, false) : new AST.Element(schema.optionalElement.ast, true)), rest.map(e => e.ast), true);
  };
  constructor(elements, rest, ast = TupleTypeImpl.ast(elements, rest)) {
    super(ast);
    this.elements = elements;
    this.rest = rest;
  }
  annotations(annotations) {
    return new TupleTypeImpl(this.elements, this.rest, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
function Tuple(...args) {
  return Array.isArray(args[0]) ? new TupleTypeImpl(args[0], args.slice(1)) : new TupleTypeImpl(args, []);
}
class $ArrayImpl extends TupleTypeImpl {
  value;
  constructor(value, ast) {
    super([], [value], ast);
    this.value = value;
  }
  annotations(annotations) {
    return new $ArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
const $Array = value => new $ArrayImpl(value);
exports.Array = $Array;
class NonEmptyArrayImpl extends TupleTypeImpl {
  value;
  constructor(value, ast) {
    super([value], [value], ast);
    this.value = value;
  }
  annotations(annotations) {
    return new NonEmptyArrayImpl(this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
const NonEmptyArray = value => new NonEmptyArrayImpl(value);
exports.NonEmptyArray = NonEmptyArray;
const formatToken = isOptional => isOptional ? "\"?:\"" : "\":\"";
/**
 * @category PropertySignature
 * @since 1.0.0
 */
class PropertySignatureDeclaration {
  type;
  isOptional;
  isReadonly;
  annotations;
  /**
   * @since 1.0.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    const token = formatToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
exports.PropertySignatureDeclaration = PropertySignatureDeclaration;
class FromPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  fromKey;
  constructor(type, isOptional, isReadonly, annotations, fromKey) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    this.fromKey = fromKey;
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
exports.FromPropertySignature = FromPropertySignature;
class ToPropertySignature {
  type;
  isOptional;
  isReadonly;
  annotations;
  constructor(type, isOptional, isReadonly, annotations) {
    this.type = type;
    this.isOptional = isOptional;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
  }
}
exports.ToPropertySignature = ToPropertySignature;
const formatPropertyKey = p => {
  if (p === undefined) {
    return "never";
  }
  if (Predicate.isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
/**
 * @category PropertySignature
 * @since 1.0.0
 */
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  /**
   * @since 1.0.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    return `PropertySignature<${formatToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
/**
 * @since 1.0.0
 * @category symbol
 */
exports.PropertySignatureTransformation = PropertySignatureTransformation;
const PropertySignatureTypeId = exports.PropertySignatureTypeId = /*#__PURE__*/Symbol.for("@effect/schema/PropertySignature");
const propertySignatureAnnotations_ = (ast, annotations) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations
        });
      }
    case "PropertySignatureTransformation":
      {
        return new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }), ast.decode, ast.encode);
      }
  }
};
/** @internal */
class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null;
  _Key;
  _EncodedToken;
  _TypeToken;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  annotations(annotations) {
    return new PropertySignatureImpl(propertySignatureAnnotations_(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
exports.PropertySignatureImpl = PropertySignatureImpl;
const propertySignature = self => new PropertySignatureImpl(new PropertySignatureDeclaration(self.ast, false, true, {}));
/**
 * @category PropertySignature
 * @since 1.0.0
 */
exports.propertySignature = propertySignature;
const fromKey = exports.fromKey = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}), _Function.identity, _Function.identity));
      }
    case "PropertySignatureTransformation":
      return new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
/**
 * - `decode`: `none` as argument means: the value is missing in the input
 * - `encode`: `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
const optionalToRequired = (from, to, options) => new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}), o => option_.some(options.decode(o)), option_.flatMap(options.encode)));
/**
 * - `decode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 * - `encode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
exports.optionalToRequired = optionalToRequired;
const optionalToOptional = (from, to, options) => new PropertySignatureImpl(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}), options.decode, options.encode));
/**
 * @category PropertySignature
 * @since 1.0.0
 */
exports.optionalToOptional = optionalToOptional;
const optional = exports.optional = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (schema, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable = options?.nullable;
  const asOption = options?.as == "Option";
  if (isExact) {
    if (defaultValue) {
      if (isNullable) {
        return optionalToRequired(NullOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === null ? defaultValue() : a
          }),
          encode: option_.some
        });
      } else {
        return optionalToRequired(schema, typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: _Function.identity
          }),
          encode: option_.some
        });
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: _Function.identity
        });
      } else {
        return optionalToRequired(schema, OptionFromSelf(typeSchema(schema)), {
          decode: _Function.identity,
          encode: _Function.identity
        });
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullOr(schema), typeSchema(schema), {
          decode: option_.filter(Predicate.isNotNull),
          encode: _Function.identity
        });
      } else {
        return new PropertySignatureImpl(new PropertySignatureDeclaration(schema.ast, true, true, {}));
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable) {
        return optionalToRequired(NullishOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a == null ? defaultValue() : a
          }),
          encode: option_.some
        });
      } else {
        return optionalToRequired(UndefinedOr(schema), typeSchema(schema), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === undefined ? defaultValue() : a
          }),
          encode: option_.some
        });
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullishOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(a => a != null),
          encode: _Function.identity
        });
      } else {
        return optionalToRequired(UndefinedOr(schema), OptionFromSelf(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotUndefined),
          encode: _Function.identity
        });
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullishOr(schema), UndefinedOr(typeSchema(schema)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: _Function.identity
        });
      } else {
        return new PropertySignatureImpl(new PropertySignatureDeclaration(UndefinedOr(schema).ast, true, true, {}));
      }
    }
  }
});
const isPropertySignature = u => Predicate.hasProperty(u, PropertySignatureTypeId);
class TypeLiteralImpl extends SchemaImpl {
  static ast = (fields, records) => {
    const ownKeys = util_.ownKeys(fields);
    const pss = [];
    if (ownKeys.length > 0) {
      const from = [];
      const to = [];
      const transformations = [];
      for (let i = 0; i < ownKeys.length; i++) {
        const key = ownKeys[i];
        const field = fields[key];
        if (isPropertySignature(field)) {
          const ast = field.ast;
          switch (ast._tag) {
            case "PropertySignatureDeclaration":
              {
                const type = ast.type;
                const isOptional = ast.isOptional;
                const toAnnotations = ast.annotations;
                from.push(new AST.PropertySignature(key, type, isOptional, true));
                to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations));
                pss.push(new AST.PropertySignature(key, type, isOptional, true, toAnnotations));
                break;
              }
            case "PropertySignatureTransformation":
              {
                const fromKey = ast.from.fromKey ?? key;
                from.push(new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
                to.push(new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
                transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
                break;
              }
          }
        } else {
          from.push(new AST.PropertySignature(key, field.ast, false, true));
          to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true));
          pss.push(new AST.PropertySignature(key, field.ast, false, true));
        }
      }
      if (array_.isNonEmptyReadonlyArray(transformations)) {
        const issFrom = [];
        const issTo = [];
        for (const r of records) {
          const {
            indexSignatures,
            propertySignatures
          } = AST.record(r.key.ast, r.value.ast);
          propertySignatures.forEach(ps => {
            from.push(ps);
            to.push(new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
          });
          indexSignatures.forEach(is => {
            issFrom.push(is);
            issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly));
          });
        }
        return new AST.Transformation(new AST.TypeLiteral(from, issFrom, {
          [AST.TitleAnnotationId]: "Struct (Encoded side)"
        }), new AST.TypeLiteral(to, issTo, {
          [AST.TitleAnnotationId]: "Struct (Type side)"
        }), new AST.TypeLiteralTransformation(transformations));
      }
    }
    const iss = [];
    for (const r of records) {
      const {
        indexSignatures,
        propertySignatures
      } = AST.record(r.key.ast, r.value.ast);
      propertySignatures.forEach(ps => pss.push(ps));
      indexSignatures.forEach(is => iss.push(is));
    }
    return new AST.TypeLiteral(pss, iss);
  };
  fields;
  records;
  constructor(fields, records, ast = TypeLiteralImpl.ast(fields, records)) {
    super(ast);
    this.fields = {
      ...fields
    };
    this.records = [...records];
  }
  annotations(annotations) {
    return new TypeLiteralImpl(this.fields, this.records, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
function Struct(fields, ...records) {
  return new TypeLiteralImpl(fields, records);
}
class $RecordImpl extends TypeLiteralImpl {
  key;
  value;
  constructor(key, value, ast) {
    super({}, [{
      key,
      value
    }], ast);
    this.key = key;
    this.value = value;
  }
  annotations(annotations) {
    return new $RecordImpl(this.key, this.value, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * @category constructors
 * @since 1.0.0
 */
const Record = (key, value) => new $RecordImpl(key, value);
/**
 * @category struct transformations
 * @since 1.0.0
 */
exports.Record = Record;
const pick = (...keys) => self => make(AST.pick(self.ast, keys));
/**
 * @category struct transformations
 * @since 1.0.0
 */
exports.pick = pick;
const omit = (...keys) => self => make(AST.omit(self.ast, keys));
/**
 * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
 * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.Struct({
 *   column1: S.NumberFromString,
 *   column2: S.Number
 * })
 *
 * // const pullOutColumn: S.Schema<number, {
 * //     readonly column1: string;
 * // }, never>
 * const pullOutColumn = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 1.0.0
 */
exports.omit = omit;
const pluck = exports.pluck = /*#__PURE__*/(0, _Function.dual)(2, (schema, key) => {
  const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key);
  const value = make(ps.isOptional ? AST.orUndefined(ps.type) : ps.type);
  return transform(schema.pipe(pick(key)), value, {
    decode: a => a[key],
    encode: ak => ps.isOptional && ak === undefined ? {} : {
      [key]: ak
    }
  });
});
const makeBrandSchema = (self, annotations) => {
  const ast = AST.annotations(self, toASTAnnotations(annotations));
  const schema = make(ast);
  const validateEither_ = validateEither(schema);
  //     v-- function
  const out = brand_.refined(unbranded => either_.match(validateEither_(unbranded), {
    onLeft: e => option_.some(brand_.error(TreeFormatter.formatErrorSync(e), e)),
    onRight: () => option_.none()
  }));
  // ----------------
  // Schema interface
  // ----------------
  Object.setPrototypeOf(Object.assign(out, schema, {
    annotations: a => makeBrandSchema(ast, a)
  }), Object.getPrototypeOf(schema));
  return out;
};
/**
 * @category branding
 * @since 1.0.0
 */
const asBrandSchema = schema => schema;
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
 *
 * @category branding
 * @since 1.0.0
 */
exports.asBrandSchema = asBrandSchema;
const brand = (brand, annotations) => self => {
  const brandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {
    onNone: () => [brand],
    onSome: brands => [...brands, brand]
  });
  return makeBrandSchema(self.ast, {
    // add a default title annotation containing the brand
    title: String(self.ast) + ` & Brand<${util_.formatUnknown(brand)}>`,
    ...annotations,
    [AST.BrandAnnotationId]: brandAnnotation
  });
};
/**
 * @category combinators
 * @since 1.0.0
 */
exports.brand = brand;
const partial = exports.partial = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (self, options) => make(AST.partial(self.ast, options)));
/**
 * @category combinators
 * @since 1.0.0
 */
const required = self => make(AST.required(self.ast));
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 1.0.0
 */
exports.required = required;
const mutable = schema => make(AST.mutable(schema.ast));
exports.mutable = mutable;
const getExtendErrorMessage = (x, y, path) => errors_.getAPIErrorMessage("Extend", `cannot extend \`${x}\` with \`${y}\` (path [${path?.join(", ")}])`);
const intersectTypeLiterals = (x, y, path) => {
  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex(ps => ps.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        path = [...path, util_.formatUnknown(name)];
        propertySignatures[i] = new AST.PropertySignature(name, extendAST(type, ps.type, path), isOptional, true);
      }
    }
    return new AST.TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getExtendErrorMessage(x, y, path));
};
const extendAST = (x, y, path) => AST.Union.make(intersectUnionMembers([x], [y], path));
const intersectUnionMembers = (xs, ys, path) => array_.flatMap(xs, x => array_.flatMap(ys, y => {
  if (AST.isUnion(x)) {
    return intersectUnionMembers(x.types, AST.isUnion(y) ? y.types : [y], path);
  } else if (AST.isUnion(y)) {
    return intersectUnionMembers([x], y.types, path);
  }
  if (AST.isTypeLiteral(x)) {
    if (AST.isTypeLiteral(y)) {
      return [intersectTypeLiterals(x, y, path)];
    } else if (AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)) {
      return [new AST.Transformation(intersectTypeLiterals(x, y.from, path), intersectTypeLiterals(AST.typeAST(x), y.to, path), new AST.TypeLiteralTransformation(y.transformation.propertySignatureTransformations))];
    }
  } else if (AST.isTransformation(x) && AST.isTypeLiteralTransformation(x.transformation)) {
    if (AST.isTypeLiteral(y)) {
      return [new AST.Transformation(intersectTypeLiterals(x.from, y, path), intersectTypeLiterals(x.to, AST.typeAST(y), path), new AST.TypeLiteralTransformation(x.transformation.propertySignatureTransformations))];
    } else if (AST.isTransformation(y) && AST.isTypeLiteralTransformation(y.transformation)) {
      return [new AST.Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new AST.TypeLiteralTransformation(x.transformation.propertySignatureTransformations.concat(y.transformation.propertySignatureTransformations)))];
    }
  }
  throw new Error(getExtendErrorMessage(x, y, path));
}));
/**
 * @category combinators
 * @since 1.0.0
 */
const extend = exports.extend = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(extendAST(self.ast, that.ast, [])));
/**
 * @category combinators
 * @since 1.0.0
 */
const compose = exports.compose = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[1]), (from, to) => make(AST.compose(from.ast, to.ast)));
/**
 * @category constructors
 * @since 1.0.0
 */
const suspend = f => make(new AST.Suspend(() => f().ast));
exports.suspend = suspend;
function filter(predicate, annotations) {
  return self => make(new AST.Refinement(self.ast, (a, options, ast) => {
    const out = predicate(a, options, ast);
    if (Predicate.isBoolean(out)) {
      return out ? option_.none() : option_.some(new ParseResult.Type(ast, a));
    }
    return out;
  }, toASTAnnotations(annotations)));
}
class transformOrFailImpl extends SchemaImpl {
  from;
  to;
  constructor(from, to, ast) {
    super(ast);
    this.from = from;
    this.to = to;
  }
  annotations(annotations) {
    return new transformOrFailImpl(this.from, this.to, AST.annotations(this.ast, toASTAnnotations(annotations)));
  }
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 1.0.0
 */
const transformOrFail = exports.transformOrFail = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => new transformOrFailImpl(from, to, new AST.Transformation(from.ast, to.ast, new AST.FinalTransformation(options.decode, options.encode))));
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 1.0.0
 */
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => transformOrFail(from, to, {
  decode: fromA => ParseResult.succeed(options.decode(fromA)),
  encode: toI => ParseResult.succeed(options.encode(toI))
}));
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 1.0.0
 */
const transformLiteral = (from, to) => transform(Literal(from), Literal(to), {
  decode: () => to,
  encode: () => from
});
exports.transformLiteral = transformLiteral;
function transformLiterals(...pairs) {
  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.Struct({ radius: S.Number })
 * const Square = S.Struct({ sideLength: S.Number })
 * const Shape = S.Union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
const attachPropertySignature = exports.attachPropertySignature = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (schema, key, value, annotations) => {
  const attached = extend(typeSchema(schema), Struct({
    [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value)
  })).ast;
  return make(new AST.Transformation(schema.ast, annotations ? AST.annotations(attached, toASTAnnotations(annotations)) : attached, new AST.TypeLiteralTransformation([new AST.PropertySignatureTransformation(key, key, () => option_.some(value), () => option_.none())])));
});
/**
 * @category annotations
 * @since 1.0.0
 */
const annotations = exports.annotations = /*#__PURE__*/(0, _Function.dual)(2, (self, annotations) => self.annotations(annotations));
/**
 * @category annotations
 * @since 1.0.0
 */
const message = message => self => self.annotations({
  [AST.MessageAnnotationId]: message
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.message = message;
const identifier = identifier => self => self.annotations({
  [AST.IdentifierAnnotationId]: identifier
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.identifier = identifier;
const title = title => self => self.annotations({
  [AST.TitleAnnotationId]: title
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.title = title;
const description = description => self => self.annotations({
  [AST.DescriptionAnnotationId]: description
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.description = description;
const examples = examples => self => self.annotations({
  [AST.ExamplesAnnotationId]: examples
});
exports.examples = examples;
const $default = value => self => self.annotations({
  [AST.DefaultAnnotationId]: value
});
exports.default = $default;
/**
 * @category annotations
 * @since 1.0.0
 */
const documentation = documentation => self => self.annotations({
  [AST.DocumentationAnnotationId]: documentation
});
/**
 * Attaches a JSON Schema annotation to a schema that represents a refinement.
 *
 * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
 *
 * @category annotations
 * @since 1.0.0
 */
exports.documentation = documentation;
const jsonSchema = jsonSchema => self => self.annotations({
  [AST.JSONSchemaAnnotationId]: jsonSchema
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.jsonSchema = jsonSchema;
const equivalence = equivalence => self => self.annotations({
  [equivalence_.EquivalenceHookId]: () => equivalence
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.equivalence = equivalence;
const concurrency = concurrency => self => self.annotations({
  [AST.ConcurrencyAnnotationId]: concurrency
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.concurrency = concurrency;
const batching = batching => self => self.annotations({
  [AST.BatchingAnnotationId]: batching
});
/**
 * @category annotations
 * @since 1.0.0
 */
exports.batching = batching;
const parseIssueTitle = f => self => self.annotations({
  [AST.ParseIssueTitleAnnotationId]: f
});
/**
 * @category renaming
 * @since 1.0.0
 */
exports.parseIssueTitle = parseIssueTitle;
const rename = exports.rename = /*#__PURE__*/(0, _Function.dual)(2, (self, mapping) => {
  return make(AST.rename(self.ast, mapping));
});
/**
 * @category type id
 * @since 1.0.0
 */
const TrimmedTypeId = exports.TrimmedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Trimmed");
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 1.0.0
 */
const trimmed = annotations => self => self.pipe(filter(a => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.trimmed = trimmed;
const MaxLengthTypeId = exports.MaxLengthTypeId = filters_.MaxLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const maxLength = (maxLength, annotations) => self => self.pipe(filter(a => a.length <= maxLength, {
  typeId: MaxLengthTypeId,
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxLength = maxLength;
const MinLengthTypeId = exports.MinLengthTypeId = filters_.MinLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const minLength = (minLength, annotations) => self => self.pipe(filter(a => a.length >= minLength, {
  typeId: MinLengthTypeId,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minLength = minLength;
const PatternTypeId = exports.PatternTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Pattern");
/**
 * @category string filters
 * @since 1.0.0
 */
const pattern = (regex, annotations) => self => {
  const pattern = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern}`,
    jsonSchema: {
      pattern
    },
    arbitrary: () => fc => fc.stringMatching(regex),
    ...annotations
  }));
};
/**
 * @category type id
 * @since 1.0.0
 */
exports.pattern = pattern;
const StartsWithTypeId = exports.StartsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/StartsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
const startsWith = (startsWith, annotations) => self => self.pipe(filter(a => a.startsWith(startsWith), {
  typeId: {
    id: StartsWithTypeId,
    annotation: {
      startsWith
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith)}`,
  jsonSchema: {
    pattern: `^${startsWith}`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.startsWith = startsWith;
const EndsWithTypeId = exports.EndsWithTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/EndsWith");
/**
 * @category string filters
 * @since 1.0.0
 */
const endsWith = (endsWith, annotations) => self => self.pipe(filter(a => a.endsWith(endsWith), {
  typeId: {
    id: EndsWithTypeId,
    annotation: {
      endsWith
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith)}`,
  jsonSchema: {
    pattern: `^.*${endsWith}$`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.endsWith = endsWith;
const IncludesTypeId = exports.IncludesTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Includes");
/**
 * @category string filters
 * @since 1.0.0
 */
const includes = (searchString, annotations) => self => self.pipe(filter(a => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    annotation: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.includes = includes;
const LowercasedTypeId = exports.LowercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Lowercased");
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 1.0.0
 */
const lowercased = annotations => self => self.pipe(filter(a => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.lowercased = lowercased;
const Lowercased = exports.Lowercased = /*#__PURE__*/$String.pipe( /*#__PURE__*/lowercased({
  identifier: "Lowercased",
  title: "Lowercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const UppercasedTypeId = exports.UppercasedTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Uppercased");
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 1.0.0
 */
const uppercased = annotations => self => self.pipe(filter(a => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...annotations
}));
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.uppercased = uppercased;
const Uppercased = exports.Uppercased = /*#__PURE__*/$String.pipe( /*#__PURE__*/uppercased({
  identifier: "Uppercased",
  title: "Uppercased"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const LengthTypeId = exports.LengthTypeId = filters_.LengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
const length = (length, annotations) => self => {
  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length));
  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength;
  if (minLength !== maxLength) {
    return self.pipe(filter(a => a.length >= minLength && a.length <= maxLength, {
      typeId: LengthTypeId,
      description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
      jsonSchema: {
        minLength,
        maxLength
      },
      ...annotations
    }));
  }
  return self.pipe(filter(a => a.length === minLength, {
    typeId: LengthTypeId,
    description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
    jsonSchema: {
      minLength,
      maxLength: minLength
    },
    ...annotations
  }));
};
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 1.0.0
 */
exports.length = length;
const Char = exports.Char = /*#__PURE__*/$String.pipe( /*#__PURE__*/length(1, {
  identifier: "Char"
}));
/**
 * @category string filters
 * @since 1.0.0
 */
const nonEmpty = annotations => minLength(1, {
  description: "a non empty string",
  ...annotations
});
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
exports.nonEmpty = nonEmpty;
const Lowercase = exports.Lowercase = /*#__PURE__*/transform($String, Lowercased, {
  decode: s => s.toLowerCase(),
  encode: _Function.identity
}).annotations({
  identifier: "Lowercase"
});
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
const Uppercase = exports.Uppercase = /*#__PURE__*/transform($String, Uppercased, {
  decode: s => s.toUpperCase(),
  encode: _Function.identity
}).annotations({
  identifier: "Uppercase"
});
/**
 * @category string constructors
 * @since 1.0.0
 */
const Trimmed = exports.Trimmed = /*#__PURE__*/$String.pipe( /*#__PURE__*/trimmed({
  identifier: "Trimmed",
  title: "Trimmed"
}));
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 1.0.0
 */
const Trim = exports.Trim = /*#__PURE__*/transform($String, Trimmed, {
  decode: s => s.trim(),
  encode: _Function.identity
}).annotations({
  identifier: "Trim"
});
/**
 * Returns a schema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 1.0.0
 */
const split = separator => transform($String, $Array($String), {
  decode: string_.split(separator),
  encode: array_.join(separator)
});
exports.split = split;
const JsonString = /*#__PURE__*/$String.annotations({
  [AST.IdentifierAnnotationId]: "JsonString",
  [AST.TitleAnnotationId]: "JsonString",
  [AST.DescriptionAnnotationId]: "a JSON string"
});
/**
 * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 1.0.0
 */
const parseJson = (schema, o) => {
  if (isSchema(schema)) {
    return compose(parseJson(o), schema);
  }
  const options = schema;
  return transformOrFail(JsonString, Unknown, {
    decode: (s, _, ast) => ParseResult.try({
      try: () => JSON.parse(s, options?.reviver),
      catch: e => new ParseResult.Type(ast, s, e.message)
    }),
    encode: (u, _, ast) => ParseResult.try({
      try: () => JSON.stringify(u, options?.replacer, options?.space),
      catch: e => new ParseResult.Type(ast, u, e.message)
    })
  });
};
/**
 * @category string constructors
 * @since 1.0.0
 */
exports.parseJson = parseJson;
const NonEmpty = exports.NonEmpty = /*#__PURE__*/$String.pipe( /*#__PURE__*/nonEmpty({
  identifier: "NonEmpty",
  title: "NonEmpty"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const UUIDTypeId = exports.UUIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/UUID");
const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
const UUID = exports.UUID = /*#__PURE__*/$String.pipe( /*#__PURE__*/pattern(uuidRegex, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
const ULIDTypeId = exports.ULIDTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ULID");
const ulidRegex = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
const ULID = exports.ULID = /*#__PURE__*/$String.pipe( /*#__PURE__*/pattern(ulidRegex, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
}));
/**
 * @category type id
 * @since 1.0.0
 */
const FiniteTypeId = exports.FiniteTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/Finite");
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 1.0.0
 */
const finite = annotations => self => self.pipe(filter(a => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.finite = finite;
const GreaterThanTypeId = exports.GreaterThanTypeId = filters_.GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
const greaterThan = (min, annotations) => self => self.pipe(filter(a => a > min, {
  typeId: GreaterThanTypeId,
  description: min === 0 ? "a positive number" : `a number greater than ${min}`,
  jsonSchema: {
    exclusiveMinimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThan = greaterThan;
const GreaterThanOrEqualToTypeId = exports.GreaterThanOrEqualToTypeId = filters_.GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
const greaterThanOrEqualTo = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  typeId: GreaterThanOrEqualToTypeId,
  description: min === 0 ? "a non-negative number" : `a number greater than or equal to ${min}`,
  jsonSchema: {
    minimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
const MultipleOfTypeId = exports.MultipleOfTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/MultipleOf");
/**
 * @category number filters
 * @since 1.0.0
 */
const multipleOf = (divisor, annotations) => self => self.pipe(filter(a => number_.remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  // spec requires positive divisor
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.multipleOf = multipleOf;
const IntTypeId = exports.IntTypeId = filters_.IntTypeId;
/**
 * @category number filters
 * @since 1.0.0
 */
const int = annotations => self => self.pipe(filter(a => Number.isSafeInteger(a), {
  typeId: IntTypeId,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.int = int;
const LessThanTypeId = exports.LessThanTypeId = filters_.LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
const lessThan = (max, annotations) => self => self.pipe(filter(a => a < max, {
  typeId: LessThanTypeId,
  description: max === 0 ? "a negative number" : `a number less than ${max}`,
  jsonSchema: {
    exclusiveMaximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThan = lessThan;
const LessThanOrEqualToTypeId = exports.LessThanOrEqualToTypeId = filters_.LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
const lessThanOrEqualTo = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  typeId: LessThanOrEqualToTypeId,
  description: max === 0 ? "a non-positive number" : `a number less than or equal to ${max}`,
  jsonSchema: {
    maximum: max
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualTo = lessThanOrEqualTo;
const BetweenTypeId = exports.BetweenTypeId = filters_.BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 1.0.0
 */
const between = (min, max, annotations) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: BetweenTypeId,
  description: `a number between ${min} and ${max}`,
  jsonSchema: {
    maximum: max,
    minimum: min
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.between = between;
const NonNaNTypeId = exports.NonNaNTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNaN");
/**
 * @category number filters
 * @since 1.0.0
 */
const nonNaN = annotations => self => self.pipe(filter(a => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...annotations
}));
/**
 * @category number filters
 * @since 1.0.0
 */
exports.nonNaN = nonNaN;
const positive = annotations => greaterThan(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.positive = positive;
const negative = annotations => lessThan(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.negative = negative;
const nonPositive = annotations => lessThanOrEqualTo(0, annotations);
/**
 * @category number filters
 * @since 1.0.0
 */
exports.nonPositive = nonPositive;
const nonNegative = annotations => greaterThanOrEqualTo(0, annotations);
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 1.0.0
 */
exports.nonNegative = nonNegative;
const clamp = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, between(minimum, maximum)), {
  strict: false,
  decode: self => number_.clamp(self, {
    minimum,
    maximum
  }),
  encode: _Function.identity
});
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 1.0.0
 */
exports.clamp = clamp;
const NumberFromString = exports.NumberFromString = /*#__PURE__*/transformOrFail($String, $Number, {
  decode: (s, _, ast) => ParseResult.fromOption(number_.parse(s), () => new ParseResult.Type(ast, s)),
  encode: n => ParseResult.succeed(String(n))
}).annotations({
  identifier: "NumberFromString"
});
/**
 * @category number constructors
 * @since 1.0.0
 */
const Finite = exports.Finite = /*#__PURE__*/$Number.pipe( /*#__PURE__*/finite({
  identifier: "Finite",
  title: "Finite"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Int = exports.Int = /*#__PURE__*/$Number.pipe( /*#__PURE__*/int({
  identifier: "Int",
  title: "Int"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonNaN = exports.NonNaN = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonNaN({
  identifier: "NonNaN",
  title: "NonNaN"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Positive = exports.Positive = /*#__PURE__*/$Number.pipe( /*#__PURE__*/positive({
  identifier: "Positive",
  title: "Positive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const Negative = exports.Negative = /*#__PURE__*/$Number.pipe( /*#__PURE__*/negative({
  identifier: "Negative",
  title: "Negative"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonPositive = exports.NonPositive = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonPositive({
  identifier: "NonPositive",
  title: "NonPositive"
}));
/**
 * @category number constructors
 * @since 1.0.0
 */
const NonNegative = exports.NonNegative = /*#__PURE__*/$Number.pipe( /*#__PURE__*/nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const JsonNumberTypeId = exports.JsonNumberTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/JsonNumber");
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 1.0.0
 */
const JsonNumber = exports.JsonNumber = /*#__PURE__*/$Number.pipe( /*#__PURE__*/filter(n => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
}));
/**
 * @category boolean transformations
 * @since 1.0.0
 */
const Not = exports.Not = /*#__PURE__*/transform($Boolean, $Boolean, {
  decode: boolean_.not,
  encode: boolean_.not
});
const $Symbol = exports.Symbol = /*#__PURE__*/transform($String, SymbolFromSelf, {
  strict: false,
  decode: s => Symbol.for(s),
  encode: sym => sym.description
}).annotations({
  identifier: "symbol"
});
/**
 * @category type id
 * @since 1.0.0
 */
const GreaterThanBigIntTypeId = exports.GreaterThanBigIntTypeId = filters_.GreaterThanBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const greaterThanBigInt = (min, annotations) => self => self.pipe(filter(a => a > min, {
  typeId: {
    id: GreaterThanBigIntTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanBigInt = greaterThanBigInt;
const GreaterThanOrEqualToBigIntTypeId = exports.GreaterThanOrEqualToBigIntTypeId = filters_.GreaterThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const greaterThanOrEqualToBigInt = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  typeId: {
    id: GreaterThanOrEqualToBigIntTypeId,
    annotation: {
      min
    }
  },
  description: min === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToBigInt = greaterThanOrEqualToBigInt;
const LessThanBigIntTypeId = exports.LessThanBigIntTypeId = filters_.LessThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const lessThanBigInt = (max, annotations) => self => self.pipe(filter(a => a < max, {
  typeId: {
    id: LessThanBigIntTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanBigInt = lessThanBigInt;
const LessThanOrEqualToBigIntTypeId = exports.LessThanOrEqualToBigIntTypeId = filters_.LessThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const lessThanOrEqualToBigInt = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  typeId: {
    id: LessThanOrEqualToBigIntTypeId,
    annotation: {
      max
    }
  },
  description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToBigInt = lessThanOrEqualToBigInt;
const BetweenBigIntTypeId = exports.BetweenBigIntTypeId = filters_.BetweenBigintTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
const betweenBigInt = (min, max, annotations) => self => self.pipe(filter(a => a >= min && a <= max, {
  typeId: {
    id: BetweenBigIntTypeId,
    annotation: {
      max,
      min
    }
  },
  description: `a bigint between ${min}n and ${max}n`,
  ...annotations
}));
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.betweenBigInt = betweenBigInt;
const positiveBigInt = annotations => greaterThanBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.positiveBigInt = positiveBigInt;
const negativeBigInt = annotations => lessThanBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.negativeBigInt = negativeBigInt;
const nonNegativeBigInt = annotations => greaterThanOrEqualToBigInt(0n, annotations);
/**
 * @category bigint filters
 * @since 1.0.0
 */
exports.nonNegativeBigInt = nonNegativeBigInt;
const nonPositiveBigInt = annotations => lessThanOrEqualToBigInt(0n, annotations);
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
exports.nonPositiveBigInt = nonPositiveBigInt;
const clampBigInt = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: self => bigInt_.clamp(self, {
    minimum,
    maximum
  }),
  encode: _Function.identity
});
exports.clampBigInt = clampBigInt;
const bigint = exports.BigInt = /*#__PURE__*/transformOrFail($String, BigIntFromSelf, {
  decode: (s, _, ast) => ParseResult.fromOption(bigInt_.fromString(s), () => new ParseResult.Type(ast, s)),
  encode: n => ParseResult.succeed(String(n))
}).annotations({
  identifier: "bigint"
});
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const PositiveBigIntFromSelf = exports.PositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigintFromSelf",
  title: "PositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const PositiveBigInt = exports.PositiveBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigint",
  title: "PositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NegativeBigIntFromSelf = exports.NegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigintFromSelf",
  title: "NegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NegativeBigInt = exports.NegativeBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigint",
  title: "NegativeBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonPositiveBigIntFromSelf = exports.NonPositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf",
  title: "NonPositiveBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonPositiveBigInt = exports.NonPositiveBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigint",
  title: "NonPositiveBigint"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonNegativeBigIntFromSelf = exports.NonNegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe( /*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf",
  title: "NonNegativeBigintFromSelf"
}));
/**
 * @category bigint constructors
 * @since 1.0.0
 */
const NonNegativeBigInt = exports.NonNegativeBigInt = /*#__PURE__*/bigint.pipe( /*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigint",
  title: "NonNegativeBigint"
}));
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
const BigIntFromNumber = exports.BigIntFromNumber = /*#__PURE__*/transformOrFail($Number, BigIntFromSelf, {
  decode: (n, _, ast) => ParseResult.fromOption(bigInt_.fromNumber(n), () => new ParseResult.Type(ast, n)),
  encode: (b, _, ast) => ParseResult.fromOption(bigInt_.toNumber(b), () => new ParseResult.Type(ast, b))
}).annotations({
  identifier: "BigintFromNumber"
});
/**
 * @category Secret constructors
 * @since 1.0.0
 */
const SecretFromSelf = exports.SecretFromSelf = /*#__PURE__*/declare(secret_.isSecret, {
  identifier: "SecretFromSelf",
  pretty: () => secret => String(secret),
  arbitrary: () => fc => fc.string().map(_ => secret_.fromString(_))
});
/**
 * A schema that transforms a `string` into a `Secret`.
 *
 * @category Secret transformations
 * @since 1.0.0
 */
const Secret = exports.Secret = /*#__PURE__*/transform($String, SecretFromSelf, {
  strict: false,
  decode: str => secret_.fromString(str),
  encode: secret => secret_.value(secret)
}).annotations({
  identifier: "Secret"
});
/**
 * @category Duration constructors
 * @since 1.0.0
 */
const DurationFromSelf = exports.DurationFromSelf = /*#__PURE__*/declare(duration_.isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(duration_.infinity), fc.bigUint().map(_ => duration_.nanos(_)), fc.bigUint().map(_ => duration_.micros(_)), fc.maxSafeNat().map(_ => duration_.millis(_)), fc.maxSafeNat().map(_ => duration_.seconds(_)), fc.maxSafeNat().map(_ => duration_.minutes(_)), fc.maxSafeNat().map(_ => duration_.hours(_)), fc.maxSafeNat().map(_ => duration_.days(_)), fc.maxSafeNat().map(_ => duration_.weeks(_))),
  equivalence: () => duration_.Equivalence
});
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const DurationFromNanos = exports.DurationFromNanos = /*#__PURE__*/transformOrFail(BigIntFromSelf, DurationFromSelf, {
  decode: nanos => ParseResult.succeed(duration_.nanos(nanos)),
  encode: (duration, _, ast) => option_.match(duration_.toNanos(duration), {
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, duration)),
    onSome: val => ParseResult.succeed(val)
  })
}).annotations({
  identifier: "DurationFromNanos"
});
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const DurationFromMillis = exports.DurationFromMillis = /*#__PURE__*/transform($Number, DurationFromSelf, {
  decode: ms => duration_.millis(ms),
  encode: n => duration_.toMillis(n)
}).annotations({
  identifier: "DurationFromMillis"
});
const hrTime = /*#__PURE__*/Tuple( /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "seconds",
  [AST.DescriptionAnnotationId]: "seconds"
})), /*#__PURE__*/NonNegative.pipe( /*#__PURE__*/finite({
  [AST.TitleAnnotationId]: "nanos",
  [AST.DescriptionAnnotationId]: "nanos"
})));
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const Duration = exports.Duration = /*#__PURE__*/transform(hrTime, DurationFromSelf, {
  decode: ([seconds, nanos]) => duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos)),
  encode: duration => duration_.toHrTime(duration)
}).annotations({
  identifier: "Duration"
});
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
const clampDuration = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: self => duration_.clamp(self, {
    minimum,
    maximum
  }),
  encode: _Function.identity
});
/**
 * @category type id
 * @since 1.0.0
 */
exports.clampDuration = clampDuration;
const LessThanDurationTypeId = exports.LessThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const lessThanDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThan(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than ${duration_.decode(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanDuration = lessThanDuration;
const LessThanOrEqualToDurationTypeId = exports.LessThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const lessThanOrEqualToDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max
    }
  },
  description: `a Duration less than or equal to ${duration_.decode(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToDuration = lessThanOrEqualToDuration;
const GreaterThanDurationTypeId = exports.GreaterThanDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const greaterThanDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThan(a, min), {
  typeId: {
    id: GreaterThanDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than ${duration_.decode(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanDuration = greaterThanDuration;
const GreaterThanOrEqualToDurationTypeId = exports.GreaterThanOrEqualToDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const greaterThanOrEqualToDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToDurationTypeId,
    annotation: {
      min
    }
  },
  description: `a Duration greater than or equal to ${duration_.decode(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToDuration = greaterThanOrEqualToDuration;
const BetweenDurationTypeId = exports.BetweenDurationTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenDuration");
/**
 * @category Duration filters
 * @since 1.0.0
 */
const betweenDuration = (minimum, maximum, annotations) => self => self.pipe(filter(a => duration_.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenDurationTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,
  ...annotations
}));
/**
 * @category Uint8Array constructors
 * @since 1.0.0
 */
exports.betweenDuration = betweenDuration;
const Uint8ArrayFromSelf = exports.Uint8ArrayFromSelf = /*#__PURE__*/declare(Predicate.isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => array_.getEquivalence(Equal.equals)
});
const $Uint8Array = exports.Uint8Array = /*#__PURE__*/transform($Array($Number.pipe(between(0, 255, {
  title: "8-bit unsigned integer",
  description: "a 8-bit unsigned integer"
}))).annotations({
  description: "an array of 8-bit unsigned integers"
}), Uint8ArrayFromSelf, {
  decode: numbers => Uint8Array.from(numbers),
  encode: uint8Array => Array.from(uint8Array)
}).annotations({
  identifier: "Uint8Array"
});
const makeEncodingTransformation = (id, decode, encode) => transformOrFail($String, Uint8ArrayFromSelf, {
  strict: false,
  decode: (s, _, ast) => either_.mapLeft(decode(s), decodeException => new ParseResult.Type(ast, s, decodeException.message)),
  encode: u => ParseResult.succeed(encode(u))
}).annotations({
  identifier: id
});
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Base64 = exports.Base64 = /*#__PURE__*/makeEncodingTransformation("Base64", Encoding.decodeBase64, Encoding.encodeBase64);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Base64Url = exports.Base64Url = /*#__PURE__*/makeEncodingTransformation("Base64Url", Encoding.decodeBase64Url, Encoding.encodeBase64Url);
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
const Hex = exports.Hex = /*#__PURE__*/makeEncodingTransformation("Hex", Encoding.decodeHex, Encoding.encodeHex);
/**
 * @category type id
 * @since 1.0.0
 */
const MinItemsTypeId = exports.MinItemsTypeId = filters_.MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const minItems = (n, annotations) => self => self.pipe(filter(a => a.length >= n, {
  typeId: MinItemsTypeId,
  description: `an array of at least ${n} items`,
  jsonSchema: {
    minItems: n
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.minItems = minItems;
const MaxItemsTypeId = exports.MaxItemsTypeId = filters_.MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const maxItems = (n, annotations) => self => self.pipe(filter(a => a.length <= n, {
  typeId: MaxItemsTypeId,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.maxItems = maxItems;
const ItemsCountTypeId = exports.ItemsCountTypeId = filters_.ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
const itemsCount = (n, annotations) => self => self.pipe(filter(a => a.length === n, {
  typeId: ItemsCountTypeId,
  description: `an array of exactly ${n} item(s)`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  ...annotations
}));
/**
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.itemsCount = itemsCount;
const getNumberIndexedAccess = self => make(AST.getNumberIndexedAccess(self.ast));
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.getNumberIndexedAccess = getNumberIndexedAccess;
const head = self => transform(self, OptionFromSelf(getNumberIndexedAccess(typeSchema(self))), {
  decode: array_.head,
  encode: option_.match({
    onNone: () => [],
    onSome: array_.of
  })
});
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
exports.head = head;
const headOrElse = exports.headOrElse = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess(typeSchema(self)), {
  decode: (as, _, ast) => as.length > 0 ? ParseResult.succeed(as[0]) : fallback ? ParseResult.succeed(fallback()) : ParseResult.fail(new ParseResult.Type(ast, as)),
  encode: a => ParseResult.succeed(array_.of(a))
}));
/**
 * @category type id
 * @since 1.0.0
 */
const ValidDateTypeId = exports.ValidDateTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/ValidDate");
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 1.0.0
 */
const validDate = annotations => self => self.pipe(filter(a => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...annotations
}));
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 1.0.0
 */
exports.validDate = validDate;
const DateFromSelf = exports.DateFromSelf = /*#__PURE__*/declare(Predicate.isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => date => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => fc => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Equivalence.Date
});
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 1.0.0
 */
const ValidDateFromSelf = exports.ValidDateFromSelf = /*#__PURE__*/DateFromSelf.pipe( /*#__PURE__*/validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}));
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 1.0.0
 */
const DateFromString = exports.DateFromString = /*#__PURE__*/transform($String, DateFromSelf, {
  decode: s => new Date(s),
  encode: n => n.toISOString()
}).annotations({
  identifier: "DateFromString"
});
const $Date = exports.Date = /*#__PURE__*/DateFromString.pipe( /*#__PURE__*/validDate({
  identifier: "Date"
}));
const OptionNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  description: "NoneEncoded"
});
const optionSomeEncoded = value => Struct({
  _tag: Literal("Some"),
  value
}).annotations({
  description: `SomeEncoded<${format(value)}>`
});
const optionEncoded = value => Union(OptionNoneEncoded, optionSomeEncoded(value)).annotations({
  description: `OptionEncoded<${format(value)}>`
});
const optionDecode = input => input._tag === "None" ? option_.none() : option_.some(input.value);
const optionArbitrary = value => fc => fc.oneof(fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value(fc)
})).map(optionDecode);
const optionPretty = value => option_.match({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionParse = decodeUnknown => (u, options, ast) => option_.isOption(u) ? option_.isNone(u) ? ParseResult.succeed(option_.none()) : ParseResult.map(decodeUnknown(u.value, options), option_.some) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Option transformations
 * @since 1.0.0
 */
const OptionFromSelf = value => {
  return declare([value], {
    decode: value => optionParse(ParseResult.decodeUnknown(value)),
    encode: value => optionParse(ParseResult.encodeUnknown(value))
  }, {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: option_.getEquivalence
  });
};
exports.OptionFromSelf = OptionFromSelf;
const makeNoneEncoded = {
  _tag: "None"
};
const makeSomeEncoded = value => ({
  _tag: "Some",
  value
});
/**
 * @category Option transformations
 * @since 1.0.0
 */
const Option = value => {
  const value_ = asSchema(value);
  return transform(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    decode: optionDecode,
    encode: option_.match({
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.Option = Option;
const OptionFromNullOr = value => {
  const value_ = asSchema(value);
  return transform(NullOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: option_.getOrNull
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.OptionFromNullOr = OptionFromNullOr;
const OptionFromNullishOr = (value, onNoneEncoding) => {
  const value_ = asSchema(value);
  return transform(NullishOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: onNoneEncoding === null ? option_.getOrNull : option_.getOrUndefined
  });
};
/**
 * @category Option transformations
 * @since 1.0.0
 */
exports.OptionFromNullishOr = OptionFromNullishOr;
const OptionFromUndefinedOr = value => {
  const value_ = asSchema(value);
  return transform(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {
    decode: option_.fromNullable,
    encode: option_.getOrUndefined
  });
};
exports.OptionFromUndefinedOr = OptionFromUndefinedOr;
const rightEncoded = right => Struct({
  _tag: Literal("Right"),
  right
}).annotations({
  description: `RightEncoded<${format(right)}>`
});
const leftEncoded = left => Struct({
  _tag: Literal("Left"),
  left
}).annotations({
  description: `LeftEncoded<${format(left)}>`
});
const eitherEncoded = (right, left) => Union(rightEncoded(right), leftEncoded(left)).annotations({
  description: `EitherEncoded<${format(left)}, ${format(right)}>`
});
const eitherDecode = input => input._tag === "Left" ? either_.left(input.left) : either_.right(input.right);
const eitherArbitrary = (right, left) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right(fc)
})).map(eitherDecode);
const eitherPretty = (right, left) => either_.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => either_.isEither(u) ? either_.match(u, {
  onLeft: left => ParseResult.map(decodeUnknownLeft(left, options), either_.left),
  onRight: right => ParseResult.map(parseRight(right, options), either_.right)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Either transformations
 * @since 1.0.0
 */
const EitherFromSelf = ({
  left,
  right
}) => {
  return declare([right, left], {
    decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),
    encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))
  }, {
    description: `Either<${format(right)}, ${format(left)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right, left) => either_.getEquivalence({
      left,
      right
    })
  });
};
exports.EitherFromSelf = EitherFromSelf;
const makeLeftEncoded = left => ({
  _tag: "Left",
  left
});
const makeRightEncoded = right => ({
  _tag: "Right",
  right
});
/**
 * @category Either transformations
 * @since 1.0.0
 */
const Either = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  return transform(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    decode: eitherDecode,
    encode: either_.match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
 *
 * @category Either transformations
 * @since 1.0.0
 */
exports.Either = Either;
const EitherFromUnion = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform(right_, rightEncoded(toright), {
    decode: makeRightEncoded,
    encode: r => r.right
  });
  const fromLeft = transform(left_, leftEncoded(toleft), {
    decode: makeLeftEncoded,
    encode: l => l.left
  });
  return transform(Union(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    decode: from => from._tag === "Left" ? either_.left(from.left) : either_.right(from.right),
    encode: either_.match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
exports.EitherFromUnion = EitherFromUnion;
const mapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => new Map(as));
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const readonlyMapEquivalence = (key, value) => {
  const arrayEquivalence = array_.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
const readonlyMapParse = decodeUnknown => (u, options, ast) => Predicate.isMap(u) ? ParseResult.map(decodeUnknown(Array.from(u.entries()), options), as => new Map(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
const mapFromSelf_ = (key, value, description) => declare([key, value], {
  decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown($Array(Tuple(Key, Value)))),
  encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown($Array(Tuple(Key, Value))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
/**
 * @category ReadonlyMap
 * @since 1.0.0
 */
const ReadonlyMapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`);
/**
 * @category Map
 * @since 1.0.0
 */
exports.ReadonlyMapFromSelf = ReadonlyMapFromSelf;
const MapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`);
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
exports.MapFromSelf = MapFromSelf;
const ReadonlyMap = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), ReadonlyMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => new Map(as),
    encode: map => Array.from(map.entries())
  });
};
exports.ReadonlyMap = ReadonlyMap;
const map = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), MapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => new Map(as),
    encode: map => Array.from(map.entries())
  });
};
exports.Map = map;
const setArbitrary = item => fc => fc.array(item(fc)).map(as => new Set(as));
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
const readonlySetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
const readonlySetParse = decodeUnknown => (u, options, ast) => Predicate.isSet(u) ? ParseResult.map(decodeUnknown(Array.from(u.values()), options), as => new Set(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
const setFromSelf_ = (value, description) => declare([value], {
  decode: item => readonlySetParse(ParseResult.decodeUnknown($Array(item))),
  encode: item => readonlySetParse(ParseResult.encodeUnknown($Array(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
/**
 * @category ReadonlySet
 * @since 1.0.0
 */
const ReadonlySetFromSelf = value => setFromSelf_(value, `ReadonlySet<${format(value)}>`);
/**
 * @category Set
 * @since 1.0.0
 */
exports.ReadonlySetFromSelf = ReadonlySetFromSelf;
const SetFromSelf = value => setFromSelf_(value, `Set<${format(value)}>`);
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
exports.SetFromSelf = SetFromSelf;
const ReadonlySet = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ReadonlySetFromSelf(typeSchema(value_)), {
    decode: as => new Set(as),
    encode: set => Array.from(set)
  });
};
exports.ReadonlySet = ReadonlySet;
const set = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), SetFromSelf(typeSchema(value_)), {
    decode: as => new Set(as),
    encode: set => Array.from(set)
  });
};
exports.Set = set;
const bigDecimalPretty = () => val => `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer()).map(([value, scale]) => bigDecimal_.make(value, scale));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
const BigDecimalFromSelf = exports.BigDecimalFromSelf = /*#__PURE__*/declare(bigDecimal_.isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => bigDecimal_.Equivalence
});
/**
 * @category BigDecimal transformations
 * @since 1.0.0
 */
const BigDecimal = exports.BigDecimal = /*#__PURE__*/transformOrFail($String, BigDecimalFromSelf, {
  decode: (num, _, ast) => bigDecimal_.fromString(num).pipe(option_.match({
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, num)),
    onSome: val => ParseResult.succeed(bigDecimal_.normalize(val))
  })),
  encode: val => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(val)))
}).annotations({
  identifier: "BigDecimal"
});
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
const BigDecimalFromNumber = exports.BigDecimalFromNumber = /*#__PURE__*/transformOrFail($Number, BigDecimalFromSelf, {
  decode: num => ParseResult.succeed(bigDecimal_.fromNumber(num)),
  encode: val => ParseResult.succeed(bigDecimal_.unsafeToNumber(val))
}).annotations({
  identifier: "BigDecimalFromNumber"
});
/**
 * @category type id
 * @since 1.0.0
 */
const GreaterThanBigDecimalTypeId = exports.GreaterThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const greaterThanBigDecimal = (min, annotations) => self => self.pipe(filter(a => bigDecimal_.greaterThan(a, min), {
  typeId: {
    id: GreaterThanBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than ${bigDecimal_.format(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanBigDecimal = greaterThanBigDecimal;
const GreaterThanOrEqualToBigDecimalTypeId = exports.GreaterThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const greaterThanOrEqualToBigDecimal = (min, annotations) => self => self.pipe(filter(a => bigDecimal_.greaterThanOrEqualTo(a, min), {
  typeId: {
    id: GreaterThanOrEqualToBigDecimalTypeId,
    annotation: {
      min
    }
  },
  description: `a BigDecimal greater than or equal to ${bigDecimal_.format(min)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.greaterThanOrEqualToBigDecimal = greaterThanOrEqualToBigDecimal;
const LessThanBigDecimalTypeId = exports.LessThanBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const lessThanBigDecimal = (max, annotations) => self => self.pipe(filter(a => bigDecimal_.lessThan(a, max), {
  typeId: {
    id: LessThanBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than ${bigDecimal_.format(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanBigDecimal = lessThanBigDecimal;
const LessThanOrEqualToBigDecimalTypeId = exports.LessThanOrEqualToBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const lessThanOrEqualToBigDecimal = (max, annotations) => self => self.pipe(filter(a => bigDecimal_.lessThanOrEqualTo(a, max), {
  typeId: {
    id: LessThanOrEqualToBigDecimalTypeId,
    annotation: {
      max
    }
  },
  description: `a BigDecimal less than or equal to ${bigDecimal_.format(max)}`,
  ...annotations
}));
/**
 * @category type id
 * @since 1.0.0
 */
exports.lessThanOrEqualToBigDecimal = lessThanOrEqualToBigDecimal;
const PositiveBigDecimalTypeId = exports.PositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/PositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const positiveBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isPositive(a), {
  typeId: {
    id: PositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a positive BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.positiveBigDecimal = positiveBigDecimal;
const PositiveBigDecimalFromSelf = exports.PositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf",
  title: "PositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NonNegativeBigDecimalTypeId = exports.NonNegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonNegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const nonNegativeBigDecimal = annotations => self => self.pipe(filter(a => a.value >= 0n, {
  typeId: {
    id: NonNegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-negative BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.nonNegativeBigDecimal = nonNegativeBigDecimal;
const NonNegativeBigDecimalFromSelf = exports.NonNegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf",
  title: "NonNegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NegativeBigDecimalTypeId = exports.NegativeBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NegativeBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const negativeBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isNegative(a), {
  typeId: {
    id: NegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a negative BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.negativeBigDecimal = negativeBigDecimal;
const NegativeBigDecimalFromSelf = exports.NegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf",
  title: "NegativeBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const NonPositiveBigDecimalTypeId = exports.NonPositiveBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/NonPositiveBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const nonPositiveBigDecimal = annotations => self => self.pipe(filter(a => a.value <= 0n, {
  typeId: {
    id: NonPositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-positive BigDecimal`,
  ...annotations
}));
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
exports.nonPositiveBigDecimal = nonPositiveBigDecimal;
const NonPositiveBigDecimalFromSelf = exports.NonPositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe( /*#__PURE__*/nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf",
  title: "NonPositiveBigDecimalFromSelf"
}));
/**
 * @category type id
 * @since 1.0.0
 */
const BetweenBigDecimalTypeId = exports.BetweenBigDecimalTypeId = /*#__PURE__*/Symbol.for("@effect/schema/TypeId/BetweenBigDecimal");
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
const betweenBigDecimal = (minimum, maximum, annotations) => self => self.pipe(filter(a => bigDecimal_.between(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenBigDecimalTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a BigDecimal between ${bigDecimal_.format(minimum)} and ${bigDecimal_.format(maximum)}`,
  ...annotations
}));
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
exports.betweenBigDecimal = betweenBigDecimal;
const clampBigDecimal = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: self => bigDecimal_.clamp(self, {
    minimum,
    maximum
  }),
  encode: _Function.identity
});
exports.clampBigDecimal = clampBigDecimal;
const chunkArbitrary = item => fc => fc.array(item(fc)).map(chunk_.fromIterable);
const chunkPretty = item => c => `Chunk(${chunk_.toReadonlyArray(c).map(item).join(", ")})`;
const chunkParse = decodeUnknown => (u, options, ast) => chunk_.isChunk(u) ? chunk_.isEmpty(u) ? ParseResult.succeed(chunk_.empty()) : ParseResult.map(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
const ChunkFromSelf = value => {
  return declare([value], {
    decode: item => chunkParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => chunkParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `Chunk<${format(value)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
exports.ChunkFromSelf = ChunkFromSelf;
const Chunk = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ChunkFromSelf(typeSchema(value_)), {
    decode: as => as.length === 0 ? chunk_.empty() : chunk_.fromIterable(as),
    encode: chunk_.toReadonlyArray
  });
};
exports.Chunk = Chunk;
const toData = a => Array.isArray(a) ? data_.array(a) : data_.struct(a);
const dataArbitrary = item => fc => item(fc).map(toData);
const dataPretty = item => d => `Data(${item(d)})`;
const dataParse = decodeUnknown => (u, options, ast) => Equal.isEqual(u) ? ParseResult.map(decodeUnknown(u, options), toData) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Data transformations
 * @since 1.0.0
 */
const DataFromSelf = item => {
  return declare([item], {
    decode: item => dataParse(ParseResult.decodeUnknown(item)),
    encode: item => dataParse(ParseResult.encodeUnknown(item))
  }, {
    description: `Data<${format(item)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
/**
 * @category Data transformations
 * @since 1.0.0
 */
exports.DataFromSelf = DataFromSelf;
const Data = item => transform(item, DataFromSelf(typeSchema(item)), {
  strict: false,
  decode: toData,
  encode: a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
});
/**
 * @category classes
 * @since 1.0.0
 */
exports.Data = Data;
const Class = identifier => (fields, annotations) => makeClass({
  kind: "Class",
  identifier,
  fields,
  Base: data_.Class,
  annotations
});
/**
 * @category classes
 * @since 1.0.0
 */
exports.Class = Class;
const TaggedClass = identifier => (tag, fields, annotations) => makeClass({
  kind: "TaggedClass",
  identifier: identifier ?? tag,
  fields: extendFields({
    _tag: Literal(tag)
  }, fields),
  Base: data_.Class,
  tag: {
    _tag: tag
  },
  annotations
});
/**
 * @category classes
 * @since 1.0.0
 */
exports.TaggedClass = TaggedClass;
const TaggedError = identifier => (tag, fields, annotations) => {
  class Base extends data_.Error {}
  ;
  Base.prototype.name = tag;
  return makeClass({
    kind: "TaggedError",
    identifier: identifier ?? tag,
    fields: extendFields({
      _tag: Literal(tag)
    }, fields),
    Base,
    tag: {
      _tag: tag
    },
    annotations,
    toStringOverride(self) {
      if (Predicate.isString(self.message) && self.message.length > 0) {
        let message = `${self._tag}: ${self.message}`;
        if (Predicate.isString(self.stack)) {
          message = `${message}\n${self.stack.split("\n").slice(1).join("\n")}`;
        }
        return message;
      }
    }
  });
};
/**
 * @category classes
 * @since 1.0.0
 */
exports.TaggedError = TaggedError;
const TaggedRequest = identifier => (tag, Failure, Success, fields, annotations) => {
  class SerializableRequest extends Request.Class {
    get [serializable_.symbol]() {
      return this.constructor;
    }
    get [serializable_.symbolResult]() {
      return {
        Failure,
        Success
      };
    }
  }
  return makeClass({
    kind: "TaggedRequest",
    identifier: identifier ?? tag,
    fields: extendFields({
      _tag: Literal(tag)
    }, fields),
    Base: SerializableRequest,
    tag: {
      _tag: tag
    },
    annotations
  });
};
exports.TaggedRequest = TaggedRequest;
const extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const name of util_.ownKeys(b)) {
    if (name in a) {
      throw new Error(errors_.getDuplicatePropertySignatureErrorMessage(name));
    }
    out[name] = b[name];
  }
  return out;
};
const makeClass = ({
  Base,
  annotations,
  fields,
  fromSchema,
  identifier,
  kind,
  tag,
  toStringOverride
}) => {
  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier}`);
  const schema = fromSchema ?? Struct(fields);
  const validate = ParseResult.validateSync(schema);
  const from = option_.match(AST.getTitleAnnotation(schema.ast), {
    onNone: () => schema.annotations({
      title: `${identifier} (Encoded side)`
    }),
    onSome: () => schema
  });
  return class extends Base {
    constructor(props = {}, disableValidation = false) {
      if (tag !== undefined) {
        props = {
          ...props,
          ...tag
        };
      }
      if (disableValidation !== true) {
        props = validate(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId] = variance;
    static get ast() {
      const toSchema = typeSchema(schema);
      const guard = ParseResult.is(toSchema);
      const fallbackInstanceOf = u => Predicate.hasProperty(u, classSymbol) && guard(u);
      const encode = ParseResult.encodeUnknown(toSchema);
      const declaration = declare([toSchema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input)),
        encode: () => (input, options) => input instanceof this ? ParseResult.succeed(input) : ParseResult.map(encode(input, options), props => new this(props, true))
      }, {
        identifier,
        title: identifier,
        description: `an instance of ${identifier}`,
        pretty: pretty => self => `${identifier}(${pretty(self)})`,
        arbitrary: arb => fc => arb(fc).map(props => new this(props)),
        equivalence: _Function.identity,
        [AST.SurrogateAnnotationId]: toSchema.ast,
        ...annotations
      });
      const transformation = transform(from, declaration, {
        decode: input => new this(input, true),
        encode: _Function.identity
      }).annotations({
        [AST.SurrogateAnnotationId]: schema.ast
      });
      return transformation.ast;
    }
    static pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
    static annotations(annotations) {
      return make(this.ast).annotations(annotations);
    }
    static toString() {
      return `(${String(from)} <-> ${identifier})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static fields = {
      ...fields
    };
    static identifier = identifier;
    static extend(identifier) {
      return (newFields, annotations) => {
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fields: extendedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    static transformOrFail(identifier) {
      return (newFields, options, annotations) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fromSchema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    static transformOrFailFrom(identifier) {
      return (newFields, options, annotations) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          fromSchema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          tag,
          annotations
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
    toString() {
      if (toStringOverride !== undefined) {
        const out = toStringOverride(this);
        if (out !== undefined) {
          return out;
        }
      }
      return `${identifier}({ ${util_.ownKeys(fields).map(p => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`).join(", ")} })`;
    }
  };
};
const FiberIdNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
const FiberIdRuntimeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Runtime"),
  id: Int.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
const FiberIdCompositeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Composite"),
  left: suspend(() => FiberIdEncoded),
  right: suspend(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
const FiberIdEncoded = /*#__PURE__*/Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
const fiberIdArbitrary = fc => fc.letrec(tie => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
const fiberIdPretty = fiberId => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
  }
};
/**
 * @category FiberId constructors
 * @since 1.0.0
 */
const FiberIdFromSelf = exports.FiberIdFromSelf = /*#__PURE__*/declare(fiberId_.isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
});
const fiberIdDecode = input => {
  switch (input._tag) {
    case "None":
      return fiberId_.none;
    case "Runtime":
      return fiberId_.runtime(input.id, input.startTimeMillis);
    case "Composite":
      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
/**
 * @category FiberId transformations
 * @since 1.0.0
 */
const FiberId = exports.FiberId = /*#__PURE__*/transform(FiberIdEncoded, FiberIdFromSelf, {
  decode: fiberIdDecode,
  encode: fiberIdEncode
}).annotations({
  identifier: "FiberId"
});
const causeDieEncoded = defect => Struct({
  _tag: Literal("Die"),
  defect
});
const CauseEmptyEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Empty")
});
const causeFailEncoded = error => Struct({
  _tag: Literal("Fail"),
  error
});
const CauseInterruptEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Interrupt"),
  fiberId: FiberIdEncoded
});
const causeParallelEncoded = causeEncoded => Struct({
  _tag: Literal("Parallel"),
  left: causeEncoded,
  right: causeEncoded
});
const causeSequentialEncoded = causeEncoded => Struct({
  _tag: Literal("Sequential"),
  left: causeEncoded,
  right: causeEncoded
});
const causeEncoded = (error, defect) => {
  const recur = suspend(() => out);
  const out = Union(CauseEmptyEncoded, causeFailEncoded(error), causeDieEncoded(defect), CauseInterruptEncoded, causeSequentialEncoded(recur), causeParallelEncoded(recur)).annotations({
    description: `CauseEncoded<${format(error)}>`
  });
  return out;
};
const causeArbitrary = (error, defect) => fc => fc.letrec(tie => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
const causePretty = error => cause => {
  const f = cause => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error(cause.error)})`;
      case "Die":
        return `Cause.die(${cause_.pretty(cause)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
    }
  };
  return f(cause);
};
const causeParse = decodeUnknown => (u, options, ast) => cause_.isCause(u) ? ParseResult.map(decodeUnknown(causeEncode(u), options), causeDecode) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Cause transformations
 * @since 1.0.0
 */
const CauseFromSelf = ({
  defect = Unknown,
  error
}) => {
  return declare([error, defect], {
    decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),
    encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))
  }, {
    description: `Cause<${format(error)}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
exports.CauseFromSelf = CauseFromSelf;
function causeDecode(cause) {
  switch (cause._tag) {
    case "Empty":
      return cause_.empty;
    case "Fail":
      return cause_.fail(cause.error);
    case "Die":
      return cause_.die(cause.defect);
    case "Interrupt":
      return cause_.interrupt(fiberIdDecode(cause.fiberId));
    case "Sequential":
      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right));
    case "Parallel":
      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right));
  }
}
function causeEncode(cause) {
  switch (cause._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
  }
}
/**
 * @category Cause transformations
 * @since 1.0.0
 */
const CauseDefectUnknown = exports.CauseDefectUnknown = /*#__PURE__*/transform(Unknown, Unknown, {
  decode: u => {
    if (Predicate.isObject(u) && "message" in u && typeof u.message === "string") {
      const err = new Error(u.message, {
        cause: u
      });
      if ("name" in u && typeof u.name === "string") {
        err.name = u.name;
      }
      err.stack = "stack" in u && typeof u.stack === "string" ? u.stack : "";
      return err;
    }
    return String(u);
  },
  encode: defect => {
    if (defect instanceof Error) {
      return {
        name: defect.name,
        message: defect.message
      };
    }
    return String(defect);
  }
});
/**
 * @category Cause transformations
 * @since 1.0.0
 */
const Cause = ({
  defect = CauseDefectUnknown,
  error
}) => {
  const error_ = asSchema(error);
  return transform(causeEncoded(error_, defect), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect)
  }), {
    decode: causeDecode,
    encode: causeEncode
  });
};
exports.Cause = Cause;
const exitFailureEncoded = (error, defect) => Struct({
  _tag: Literal("Failure"),
  cause: causeEncoded(error, defect)
}).annotations({
  description: `FailureEncoded<${format(error)}>`
});
const exitSuccessEncoded = value => Struct({
  _tag: Literal("Success"),
  value
}).annotations({
  description: `SuccessEncoded<${format(value)}>`
});
const exitEncoded = (value, error, defect) => Union(exitFailureEncoded(error, defect), exitSuccessEncoded(value)).annotations({
  description: `ExitEncoded<${format(value)}, ${format(error)}>`
});
const exitDecode = input => {
  switch (input._tag) {
    case "Failure":
      return exit_.failCause(causeDecode(input.cause));
    case "Success":
      return exit_.succeed(input.value);
  }
};
const exitArbitrary = (value, error, defect) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value(fc)
})).map(exitDecode);
const exitPretty = (value, error) => exit => exit._tag === "Failure" ? `Exit.failCause(${causePretty(error)(exit.cause)})` : `Exit.succeed(${value(exit.value)})`;
const exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => exit_.isExit(u) ? exit_.match(u, {
  onFailure: cause => ParseResult.map(decodeUnknownCause(cause, options), exit_.failCause),
  onSuccess: value => ParseResult.map(decodeUnknownValue(value, options), exit_.succeed)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category Exit transformations
 * @since 1.0.0
 */
const ExitFromSelf = ({
  defect = Unknown,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success, failure, defect) => exitParse(ParseResult.decodeUnknown(success), ParseResult.decodeUnknown(CauseFromSelf({
    error: failure,
    defect
  }))),
  encode: (success, failure, defect) => exitParse(ParseResult.encodeUnknown(success), ParseResult.encodeUnknown(CauseFromSelf({
    error: failure,
    defect
  })))
}, {
  description: `Exit<${format(success)}, ${format(failure)}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
/**
 * @category Exit transformations
 * @since 1.0.0
 */
exports.ExitFromSelf = ExitFromSelf;
const Exit = ({
  defect = CauseDefectUnknown,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  return transform(exitEncoded(success_, failure_, defect), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect)
  }), {
    decode: exitDecode,
    encode: exit => exit._tag === "Failure" ? {
      _tag: "Failure",
      cause: exit.cause
    } : {
      _tag: "Success",
      value: exit.value
    }
  });
};
exports.Exit = Exit;
const hashSetArbitrary = item => fc => fc.array(item(fc)).map(as => hashSet_.fromIterable(as));
const hashSetPretty = item => set => `HashSet(${Array.from(set).map(a => item(a)).join(", ")})`;
const hashSetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashSetParse = decodeUnknown => (u, options, ast) => hashSet_.isHashSet(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => hashSet_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
const HashSetFromSelf = value => {
  return declare([value], {
    decode: item => hashSetParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => hashSetParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `HashSet<${format(value)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
exports.HashSetFromSelf = HashSetFromSelf;
const HashSet = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), HashSetFromSelf(typeSchema(value_)), {
    decode: as => hashSet_.fromIterable(as),
    encode: set => Array.from(set)
  });
};
exports.HashSet = HashSet;
const hashMapArbitrary = (key, value) => fc => fc.array(fc.tuple(key(fc), value(fc))).map(as => hashMap_.fromIterable(as));
const hashMapPretty = (key, value) => map => `HashMap([${Array.from(map).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const hashMapEquivalence = (key, value) => {
  const arrayEquivalence = array_.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashMapParse = decodeUnknown => (u, options, ast) => hashMap_.isHashMap(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => hashMap_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
const HashMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], {
    decode: (key, value) => hashMapParse(ParseResult.decodeUnknown($Array(Tuple(key, value)))),
    encode: (key, value) => hashMapParse(ParseResult.encodeUnknown($Array(Tuple(key, value))))
  }, {
    description: `HashMap<${format(key)}, ${format(value)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
exports.HashMapFromSelf = HashMapFromSelf;
const HashMap = ({
  key,
  value
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value);
  return transform($Array(Tuple(key_, value_)), HashMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    decode: as => hashMap_.fromIterable(as),
    encode: map => Array.from(map)
  });
};
exports.HashMap = HashMap;
const listArbitrary = item => fc => fc.array(item(fc)).map(as => list_.fromIterable(as));
const listPretty = item => set => `List(${Array.from(set).map(a => item(a)).join(", ")})`;
const listEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const listParse = decodeUnknown => (u, options, ast) => list_.isList(u) ? ParseResult.map(decodeUnknown(Array.from(u), options), as => list_.fromIterable(as)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category List transformations
 * @since 1.0.0
 */
const ListFromSelf = value => {
  return declare([value], {
    decode: item => listParse(ParseResult.decodeUnknown($Array(item))),
    encode: item => listParse(ParseResult.encodeUnknown($Array(item)))
  }, {
    description: `List<${format(value)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
/**
 * @category List transformations
 * @since 1.0.0
 */
exports.ListFromSelf = ListFromSelf;
const List = value => {
  const value_ = asSchema(value);
  return transform($Array(value_), ListFromSelf(typeSchema(value_)), {
    decode: as => list_.fromIterable(as),
    encode: set => Array.from(set)
  });
};
exports.List = List;
const sortedSetArbitrary = (item, ord) => fc => fc.array(item(fc)).map(as => sortedSet_.fromIterable(as, ord));
const sortedSetPretty = item => set => `new SortedSet([${Array.from(sortedSet_.values(set)).map(a => item(a)).join(", ")}])`;
const sortedSetParse = (decodeUnknown, ord) => (u, options, ast) => sortedSet_.isSortedSet(u) ? ParseResult.map(decodeUnknown(Array.from(sortedSet_.values(u)), options), as => sortedSet_.fromIterable(as, ord)) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
const SortedSetFromSelf = (value, ordA, ordI) => {
  return declare([value], {
    decode: item => sortedSetParse(ParseResult.decodeUnknown($Array(item)), ordA),
    encode: item => sortedSetParse(ParseResult.encodeUnknown($Array(item)), ordI)
  }, {
    description: `SortedSet<${format(value)}>`,
    pretty: sortedSetPretty,
    arbitrary: arb => sortedSetArbitrary(arb, ordA),
    equivalence: () => sortedSet_.getEquivalence()
  });
};
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
exports.SortedSetFromSelf = SortedSetFromSelf;
const SortedSet = (value, ordA) => {
  const value_ = asSchema(value);
  const to = typeSchema(value_);
  return transform($Array(value_), SortedSetFromSelf(to, ordA, ordA), {
    decode: as => sortedSet_.fromIterable(as, ordA),
    encode: set => Array.from(sortedSet_.values(set))
  });
};
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 * @category boolean constructors
 * @since 1.0.0
 */
exports.SortedSet = SortedSet;
const BooleanFromUnknown = exports.BooleanFromUnknown = /*#__PURE__*/transform(Unknown, $Boolean, {
  decode: Predicate.isTruthy,
  encode: _Function.identity
}).annotations({
  identifier: "BooleanFromUnknown"
});
//# sourceMappingURL=Schema.js.map