"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMessage = exports.formatTypeMessage = exports.formatIssueSync = exports.formatIssue = exports.formatForbiddenMessage = exports.formatErrorSync = exports.formatError = void 0;
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Effect"));
var Option = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Option"));
var Predicate = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("effect/Predicate"));
var AST = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./AST.js"));
var util_ = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("./internal/util.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/**
 * @since 1.0.0
 */

const make = (value, forest = []) => ({
  value,
  forest
});
/**
 * @category formatting
 * @since 1.0.0
 */
const formatIssue = issue => Effect.map(go(issue), tree => drawTree(tree));
/**
 * @category formatting
 * @since 1.0.0
 */
exports.formatIssue = formatIssue;
const formatIssueSync = issue => Effect.runSync(formatIssue(issue));
/**
 * @category formatting
 * @since 1.0.0
 */
exports.formatIssueSync = formatIssueSync;
const formatError = error => formatIssue(error.error);
/**
 * @category formatting
 * @since 1.0.0
 */
exports.formatError = formatError;
const formatErrorSync = error => formatIssueSync(error.error);
exports.formatErrorSync = formatErrorSync;
const drawTree = tree => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
  }
  return r;
};
const formatTransformationKind = kind => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
const formatRefinementKind = kind => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
const getPrevMessage = issue => {
  switch (issue._tag) {
    case "Refinement":
      {
        if (issue.kind === "From") {
          return getMessage(issue.error);
        }
        break;
      }
    case "Transformation":
      return getMessage(issue.error);
  }
  return Option.none();
};
const getCurrentMessage = issue => AST.getMessageAnnotation(issue.ast).pipe(Effect.flatMap(annotation => {
  const out = annotation(issue);
  return Predicate.isString(out) ? Effect.succeed(out) : out;
}));
/** @internal */
const getMessage = issue => Effect.catchAll(getPrevMessage(issue), () => getCurrentMessage(issue));
exports.getMessage = getMessage;
const getParseIssueTitleAnnotation = issue => Option.filterMap(AST.getParseIssueTitleAnnotation(issue.ast), annotation => Option.fromNullable(annotation(issue)));
/** @internal */
const formatTypeMessage = e => getMessage(e).pipe(Effect.orElse(() => getParseIssueTitleAnnotation(e)), Effect.orElse(() => e.message), Effect.catchAll(() => Effect.succeed(`Expected ${e.ast.toString(true)}, actual ${util_.formatUnknown(e.actual)}`)));
exports.formatTypeMessage = formatTypeMessage;
const getParseIssueTitle = issue => Option.getOrElse(getParseIssueTitleAnnotation(issue), () => String(issue.ast));
/** @internal */
const formatForbiddenMessage = e => Option.getOrElse(e.message, () => "is forbidden");
exports.formatForbiddenMessage = formatForbiddenMessage;
const getTree = (issue, onFailure) => Effect.matchEffect(getMessage(issue), {
  onFailure,
  onSuccess: message => Effect.succeed(make(message))
});
const go = e => {
  switch (e._tag) {
    case "Type":
      return Effect.map(formatTypeMessage(e), make);
    case "Forbidden":
      return Effect.succeed(make(getParseIssueTitle(e), [make(formatForbiddenMessage(e))]));
    case "Unexpected":
      return Effect.succeed(make(`is unexpected, expected ${e.ast.toString(true)}`));
    case "Missing":
      return Effect.succeed(make("is missing"));
    case "Union":
      return getTree(e, () => Effect.map(Effect.forEach(e.errors, e => {
        switch (e._tag) {
          case "Member":
            return Effect.map(go(e.error), tree => make(`Union member`, [tree]));
          default:
            return go(e);
        }
      }), forest => make(getParseIssueTitle(e), forest)));
    case "TupleType":
      return getTree(e, () => Effect.map(Effect.forEach(e.errors, index => Effect.map(go(index.error), tree => make(`[${index.index}]`, [tree]))), forest => make(getParseIssueTitle(e), forest)));
    case "TypeLiteral":
      return getTree(e, () => Effect.map(Effect.forEach(e.errors, key => Effect.map(go(key.error), tree => make(`[${util_.formatUnknown(key.key)}]`, [tree]))), forest => make(getParseIssueTitle(e), forest)));
    case "Transformation":
      return getTree(e, () => Effect.map(go(e.error), tree => make(getParseIssueTitle(e), [make(formatTransformationKind(e.kind), [tree])])));
    case "Refinement":
      return getTree(e, () => Effect.map(go(e.error), tree => make(getParseIssueTitle(e), [make(formatRefinementKind(e.kind), [tree])])));
    case "Declaration":
      return getTree(e, () => {
        const error = e.error;
        const shouldSkipDefaultMessage = error._tag === "Type" && error.ast === e.ast;
        return shouldSkipDefaultMessage ? go(error) : Effect.map(go(error), tree => make(getParseIssueTitle(e), [tree]));
      });
  }
};
//# sourceMappingURL=TreeFormatter.js.map