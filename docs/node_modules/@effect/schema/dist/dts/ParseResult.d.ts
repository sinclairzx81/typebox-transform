/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import * as Effect from "effect/Effect";
import * as Either from "effect/Either";
import type { LazyArg } from "effect/Function";
import * as Inspectable from "effect/Inspectable";
import * as Option from "effect/Option";
import * as AST from "./AST.js";
import type * as Schema from "./Schema.js";
/**
 * `ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.
 *
 * @category model
 * @since 1.0.0
 */
export type ParseIssue = Declaration | Refinement | TupleType | TypeLiteral | Union | Transformation | Type | Forbidden;
/**
 * Error that occurs when a declaration has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Declaration {
    readonly ast: AST.Declaration;
    readonly actual: unknown;
    readonly error: ParseIssue;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Declaration";
    constructor(ast: AST.Declaration, actual: unknown, error: ParseIssue);
}
/**
 * Error that occurs when a refinement has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Refinement {
    readonly ast: AST.Refinement<AST.AST>;
    readonly actual: unknown;
    readonly kind: "From" | "Predicate";
    readonly error: ParseIssue;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Refinement";
    constructor(ast: AST.Refinement<AST.AST>, actual: unknown, kind: "From" | "Predicate", error: ParseIssue);
}
/**
 * Error that occurs when an array or tuple has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class TupleType {
    readonly ast: AST.TupleType;
    readonly actual: unknown;
    readonly errors: Arr.NonEmptyReadonlyArray<Index>;
    readonly output: ReadonlyArray<unknown>;
    /**
     * @since 1.0.0
     */
    readonly _tag = "TupleType";
    constructor(ast: AST.TupleType, actual: unknown, errors: Arr.NonEmptyReadonlyArray<Index>, output?: ReadonlyArray<unknown>);
}
/**
 * The `Index` error indicates that there was an error at a specific index in an array or tuple.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Index {
    readonly index: number;
    readonly error: ParseIssue | Missing | Unexpected;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Index";
    constructor(index: number, error: ParseIssue | Missing | Unexpected);
}
/**
 * Error that occurs when a type literal or record has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class TypeLiteral {
    readonly ast: AST.TypeLiteral;
    readonly actual: unknown;
    readonly errors: Arr.NonEmptyReadonlyArray<Key>;
    readonly output: {
        readonly [x: string]: unknown;
    };
    /**
     * @since 1.0.0
     */
    readonly _tag = "TypeLiteral";
    constructor(ast: AST.TypeLiteral, actual: unknown, errors: Arr.NonEmptyReadonlyArray<Key>, output?: {
        readonly [x: string]: unknown;
    });
}
/**
 * The `Key` variant of the `ParseIssue` type represents an error that occurs when a key in a type literal or record is invalid.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Key {
    readonly key: PropertyKey;
    readonly error: ParseIssue | Missing | Unexpected;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Key";
    constructor(key: PropertyKey, error: ParseIssue | Missing | Unexpected);
}
/**
 * Error that occurs when an unexpected key or index is present.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Unexpected {
    readonly ast: AST.AST;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Unexpected";
    constructor(ast: AST.AST);
}
/**
 * Error that occurs when a transformation has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Transformation {
    readonly ast: AST.Transformation;
    readonly actual: unknown;
    readonly kind: "Encoded" | "Transformation" | "Type";
    readonly error: ParseIssue;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Transformation";
    constructor(ast: AST.Transformation, actual: unknown, kind: "Encoded" | "Transformation" | "Type", error: ParseIssue);
}
/**
 * The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
 * The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Type {
    readonly ast: AST.AST;
    readonly actual: unknown;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Type";
    /**
     * @since 1.0.0
     */
    readonly message: Option.Option<string>;
    constructor(ast: AST.AST, actual: unknown, message?: string);
}
/**
 * The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).
 *
 * @category model
 * @since 1.0.0
 */
export declare class Forbidden {
    readonly ast: AST.AST;
    readonly actual: unknown;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Forbidden";
    /**
     * @since 1.0.0
     */
    readonly message: Option.Option<string>;
    constructor(ast: AST.AST, actual: unknown, message?: string);
}
/**
 * Error that occurs when a required key or index is missing.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Missing {
    /**
     * @since 1.0.0
     */
    readonly _tag = "Missing";
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const missing: Missing;
/**
 * Error that occurs when a member in a union has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Member {
    readonly ast: AST.AST;
    readonly error: ParseIssue;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Member";
    constructor(ast: AST.AST, error: ParseIssue);
}
/**
 * Error that occurs when a union has an error.
 *
 * @category model
 * @since 1.0.0
 */
export declare class Union {
    readonly ast: AST.Union;
    readonly actual: unknown;
    readonly errors: Arr.NonEmptyReadonlyArray<Type | TypeLiteral | Member>;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Union";
    constructor(ast: AST.Union, actual: unknown, errors: Arr.NonEmptyReadonlyArray<Type | TypeLiteral | Member>);
}
declare const ParseError_base: new <A extends Record<string, any> = {}>(args: import("effect/Types").Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => import("effect/Cause").YieldableError & {
    readonly _tag: "ParseError";
} & Readonly<A>;
/**
 * @since 1.0.0
 */
export declare class ParseError extends ParseError_base<{
    readonly error: ParseIssue;
}> {
    get message(): string;
    /**
     * @since 1.0.0
     */
    toString(): string;
    /**
     * @since 1.0.0
     */
    toJSON(): {
        _id: string;
        message: string;
    };
    /**
     * @since 1.0.0
     */
    [Inspectable.NodeInspectSymbol](): {
        _id: string;
        message: string;
    };
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const parseError: (issue: ParseIssue) => ParseError;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const succeed: <A>(a: A) => Either.Either<A, ParseIssue>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue>;
declare const _try: <A>(options: {
    try: LazyArg<A>;
    catch: (e: unknown) => ParseIssue;
}) => Either.Either<A, ParseIssue>;
export { 
/**
 * @category constructors
 * @since 1.0.0
 */
_try as try };
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const fromOption: {
    (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>;
    <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const flatMap: {
    <A, B, E1, R1>(f: (a: A) => Effect.Effect<B, E1, R1>): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>;
    <A, E, R, B, E1, R1>(self: Effect.Effect<A, E, R>, f: (a: A) => Effect.Effect<B, E1, R1>): Effect.Effect<B, E | E1, R | R1>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const map: {
    <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>;
    <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const mapError: {
    <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>;
    <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const eitherOrUndefined: <A, E, R>(self: Effect.Effect<A, E, R>) => Either.Either<A, E> | undefined;
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const mapBoth: {
    <E, E2, A, A2>(options: {
        readonly onFailure: (e: E) => E2;
        readonly onSuccess: (a: A) => A2;
    }): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>;
    <A, E, R, E2, A2>(self: Effect.Effect<A, E, R>, options: {
        readonly onFailure: (e: E) => E2;
        readonly onSuccess: (a: A) => A2;
    }): Effect.Effect<A2, E2, R>;
};
/**
 * @category optimisation
 * @since 1.0.0
 */
export declare const orElse: {
    <E, A2, E2, R2>(f: (e: E) => Effect.Effect<A2, E2, R2>): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>;
    <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): Effect.Effect<A2 | A, E2, R2 | R>;
};
/**
 * @since 1.0.0
 */
export type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>;
/**
 * @since 1.0.0
 */
export type DeclarationDecodeUnknown<Out, R> = (u: unknown, options: AST.ParseOptions, ast: AST.Declaration) => Effect.Effect<Out, ParseIssue, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => I;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownPromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknown: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateSync: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => A;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateOption: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateEither: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validatePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => Promise<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validate: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const is: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => u is A;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const asserts: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeSync: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => I;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeOption: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeEither: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodePromise: <A, I>(schema: Schema.Schema<A, I, never>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encode: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R>;
//# sourceMappingURL=ParseResult.d.ts.map