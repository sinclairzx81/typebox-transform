/**
 * @since 1.0.0
 */
import * as array_ from "effect/Array";
import * as bigDecimal_ from "effect/BigDecimal";
import * as brand_ from "effect/Brand";
import * as cause_ from "effect/Cause";
import * as chunk_ from "effect/Chunk";
import * as duration_ from "effect/Duration";
import * as Effect from "effect/Effect";
import * as either_ from "effect/Either";
import * as Equivalence from "effect/Equivalence";
import * as exit_ from "effect/Exit";
import * as fiberId_ from "effect/FiberId";
import type { LazyArg } from "effect/Function";
import * as hashMap_ from "effect/HashMap";
import * as hashSet_ from "effect/HashSet";
import * as list_ from "effect/List";
import * as option_ from "effect/Option";
import type * as Order from "effect/Order";
import type { Pipeable } from "effect/Pipeable";
import * as Predicate from "effect/Predicate";
import * as Request from "effect/Request";
import * as secret_ from "effect/Secret";
import * as sortedSet_ from "effect/SortedSet";
import type * as Types from "effect/Types";
import type { LazyArbitrary } from "./Arbitrary.js";
import type { ParseOptions } from "./AST.js";
import * as AST from "./AST.js";
import * as ParseResult from "./ParseResult.js";
import * as pretty_ from "./Pretty.js";
import type * as Serializable from "./Serializable.js";
/**
 * @since 1.0.0
 */
export type SimplifyMutable<A> = {
    -readonly [K in keyof A]: A[K];
} extends infer B ? B : never;
/**
 * @since 1.0.0
 * @category symbol
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type TypeId = typeof TypeId;
/**
 * @category model
 * @since 1.0.0
 */
export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {
    readonly ast: AST.AST;
    annotations(annotations: Annotations.Schema<A>): Schema<A, I, R>;
}
/**
 * @category annotations
 * @since 1.0.0
 */
export declare namespace Annotable {
    /**
     * @since 1.0.0
     */
    type Self<S extends All> = ReturnType<S["annotations"]>;
    /**
     * @since 1.0.0
     */
    type Any = Annotable<any, any, any, unknown>;
    /**
     * @since 1.0.0
     */
    type All = Any | Annotable<any, any, never, unknown> | Annotable<any, never, any, unknown> | Annotable<any, never, never, unknown>;
}
/**
 * @category annotations
 * @since 1.0.0
 */
export interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {
    annotations(annotations: Annotations.Schema<A>): Self;
}
/**
 * @since 1.0.0
 */
export declare const asSchema: <S extends Schema.All>(schema: S) => Schema<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>;
/**
 * @category hashing
 * @since 1.0.0
 */
export declare const hash: <A, I, R>(schema: Schema<A, I, R>) => number;
/**
 * @category formatting
 * @since 1.0.0
 */
export declare const format: <A, I, R>(schema: Schema<A, I, R>) => string;
/**
 * @since 1.0.0
 */
export declare namespace Schema {
    /**
     * @since 1.0.0
     */
    interface Variance<A, I, R> {
        readonly [TypeId]: {
            readonly _A: Types.Invariant<A>;
            readonly _I: Types.Invariant<I>;
            readonly _R: Types.Covariant<R>;
        };
    }
    /**
     * @since 1.0.0
     */
    type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never;
    /**
     * @since 1.0.0
     */
    type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never;
    /**
     * @since 1.0.0
     */
    type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never;
    /**
     * @since 1.0.0
     */
    type ToAsserts<S extends AnyNoContext> = (input: unknown, options?: AST.ParseOptions) => asserts input is Schema.Type<S>;
    /**
     * Any schema, except for `never`.
     *
     * @since 1.0.0
     */
    type Any = Schema<any, any, unknown>;
    /**
     * Any schema with `Context = never`, except for `never`.
     *
     * @since 1.0.0
     */
    type AnyNoContext = Schema<any, any, never>;
    /**
     * Any schema, including `never`.
     *
     * @since 1.0.0
     */
    type All = Any | Schema<any, never, unknown> | Schema<never, any, unknown> | Schema<never, never, unknown>;
}
/**
 * @since 1.0.0
 */
export declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => Schema<I>;
/**
 * @since 1.0.0
 */
export declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => Schema<A>;
export { 
/**
 * @category validation
 * @since 1.0.0
 */
asserts, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeSync, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownOption, 
/**
 * @category decoding
 * @since 1.0.0
 */
decodeUnknownSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeSync, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownOption, 
/**
 * @category encoding
 * @since 1.0.0
 */
encodeUnknownSync, 
/**
 * @category validation
 * @since 1.0.0
 */
is, 
/**
 * @category validation
 * @since 1.0.0
 */
validateOption, 
/**
 * @category validation
 * @since 1.0.0
 */
validateSync } from "./ParseResult.js";
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError>;
/**
 * @category encoding
 * @since 1.0.0
 */
export declare const encodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (a: A, overrideOptions?: ParseOptions) => Promise<I>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknown: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeUnknownPromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decode: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodeEither: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category decoding
 * @since 1.0.0
 */
export declare const decodePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (i: I, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validate: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validateEither: <A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError>;
/**
 * @category validation
 * @since 1.0.0
 */
export declare const validatePromise: <A, I>(schema: Schema<A, I, never>, options?: ParseOptions) => (u: unknown, overrideOptions?: ParseOptions) => Promise<A>;
/**
 * Tests if a value is a `Schema`.
 *
 * @category guards
 * @since 1.0.0
 */
export declare const isSchema: (u: unknown) => u is Schema.Any;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const make: <A, I = A, R = never>(ast: AST.AST) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>> extends Annotable<Literal<Literals>, Literals[number]> {
    readonly literals: Readonly<Literals>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare function Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(...literals: Literals): Literal<Literals>;
export declare function Literal(): Never;
export declare function Literal<Literals extends ReadonlyArray<AST.LiteralValue>>(...literals: Literals): Schema<Literals[number]>;
/**
 * Creates a new `Schema` from a literal schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { Either } from "effect"
 *
 * const schema = S.Literal("a", "b", "c").pipe(S.pickLiteral("a", "b"))
 *
 * assert.deepStrictEqual(S.decodeSync(schema)("a"), "a")
 * assert.deepStrictEqual(S.decodeSync(schema)("b"), "b")
 * assert.strictEqual(Either.isLeft(S.decodeUnknownEither(schema)("c")), true)
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const pickLiteral: <A extends AST.LiteralValue, L extends readonly [A, ...A[]]>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const UniqueSymbolFromSelf: <S extends symbol>(symbol: S) => Schema<S>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Enums<A extends {
    [x: string]: string | number;
}> extends Annotable<Enums<A>, A[keyof A]> {
    readonly enums: A;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const Enums: <A extends {
    [x: string]: string | number;
}>(enums: A) => Enums<A>;
type Join<T> = T extends [infer Head, ...infer Tail] ? `${Head & (string | number | bigint | boolean | null | undefined)}${Tail extends [] ? "" : Join<Tail>}` : never;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const TemplateLiteral: <T extends [Schema.AnyNoContext, ...Schema.AnyNoContext[]]>(...[head, ...tail]: T) => Schema<Join<{ [K in keyof T]: Schema.Type<T[K]>; }>, Join<{ [K in keyof T]: Schema.Type<T[K]>; }>, never>;
/**
 * The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
 * This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const declare: {
    <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): Schema<A>;
    <const P extends ReadonlyArray<Schema.Any>, I, A>(typeParameters: P, options: {
        readonly decode: (...typeParameters: {
            readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>;
        }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>;
        readonly encode: (...typeParameters: {
            readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>;
        }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>;
    }, annotations?: Annotations.Schema<A, {
        readonly [K in keyof P]: Schema.Type<P[K]>;
    }>): Schema<A, I, Schema.Context<P[number]>>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BrandTypeId: unique symbol;
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const fromBrand: <C extends brand_.Brand<string | symbol>>(constructor: brand_.Brand.Constructor<C>, annotations?: Annotations.Filter<brand_.Brand.Unbranded<C>>) => <R, I, A extends brand_.Brand.Unbranded<C>>(self: Schema<A, I, R>) => Schema<A & C, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const InstanceOfTypeId: unique symbol;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface instanceOf<A> extends Annotable<instanceOf<A>, A> {
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A, annotations?: Annotations.Schema<InstanceType<A>>) => instanceOf<InstanceType<A>>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Undefined extends Annotable<Undefined, undefined> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Undefined: Undefined;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Void extends Annotable<Void, void> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Void: Void;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Null extends Annotable<Null, null> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Null: Null;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Never extends Annotable<Never, never> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Never: Never;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Unknown extends Annotable<Unknown, unknown> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Unknown: Unknown;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Any extends Annotable<Any, any> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const Any: Any;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $String extends Annotable<$String, string> {
}
declare const $String: $String;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Number extends Annotable<$Number, number> {
}
declare const $Number: $Number;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Boolean extends Annotable<$Boolean, boolean> {
}
declare const $Boolean: $Boolean;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BigIntFromSelf extends Annotable<BigIntFromSelf, bigint> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const BigIntFromSelf: BigIntFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface SymbolFromSelf extends Annotable<SymbolFromSelf, symbol> {
}
/**
 * @category primitives
 * @since 1.0.0
 */
export declare const SymbolFromSelf: SymbolFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Object extends Annotable<$Object, object> {
}
declare const $Object: $Object;
export { 
/**
 * @category primitives
 * @since 1.0.0
 */
$Boolean as Boolean, 
/**
 * @category primitives
 * @since 1.0.0
 */
$Number as Number, 
/**
 * @category primitives
 * @since 1.0.0
 */
$Object as Object, 
/**
 * @category primitives
 * @since 1.0.0
 */
$String as String };
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Union<Members extends ReadonlyArray<Schema.Any>> extends Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>> {
    readonly members: Readonly<Members>;
    annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members>;
}
/**
 * @category combinators
 * @since 1.0.0
 */
export declare function Union<Members extends AST.Members<Schema.Any>>(...members: Members): Union<Members>;
export declare function Union<Member extends Schema.Any>(member: Member): Member;
export declare function Union(): Never;
export declare function Union<Members extends ReadonlyArray<Schema.Any>>(...members: Members): Schema<Schema.Type<Members[number]>, Schema.Encoded<Members[number]>, Schema.Context<Members[number]>>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface NullOr<S extends Schema.Any> extends Union<[S, Null]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>;
}
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const NullOr: <S extends Schema.Any>(self: S) => NullOr<S>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface UndefinedOr<S extends Schema.Any> extends Union<[S, Undefined]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>;
}
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const UndefinedOr: <S extends Schema.Any>(self: S) => UndefinedOr<S>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface NullishOr<S extends Schema.Any> extends Union<[S, Null, Undefined]> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>;
}
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const NullishOr: <S extends Schema.Any>(self: S) => NullishOr<S>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const keyof: <A, I, R>(self: Schema<A, I, R>) => Schema<keyof A>;
/**
 * @since 1.0.0
 */
export interface OptionalElement<E extends Schema.Any> extends Schema.Variance<Schema.Type<E>, Schema.Encoded<E>, Schema.Context<E>> {
    readonly optionalElement: E;
}
/**
 * @since 1.0.0
 */
export declare const optionalElement: <E extends Schema.Any>(self: E) => OptionalElement<E>;
/**
 * @since 1.0.0
 */
export declare namespace TupleType {
    type ElementsType<Elements, Out extends ReadonlyArray<any> = readonly []> = Elements extends readonly [infer Head, ...infer Tail] ? Head extends OptionalElement<infer T> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]> : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]> : Out;
    type ElementsEncoded<Elements, Out extends ReadonlyArray<any> = readonly []> = Elements extends readonly [infer Head, ...infer Tail] ? Head extends OptionalElement<infer T> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]> : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]> : Out;
    /**
     * @since 1.0.0
     */
    type Element = Schema.Any | OptionalElement<Schema.Any>;
    /**
     * @since 1.0.0
     */
    type Elements = ReadonlyArray<Element>;
    /**
     * @since 1.0.0
     */
    type Type<Elements extends TupleType.Elements, Rest extends ReadonlyArray<Schema.Any>> = Rest extends [infer Head, ...infer Tail] ? Readonly<[
        ...ElementsType<Elements>,
        ...ReadonlyArray<Schema.Type<Head>>,
        ...{
            readonly [K in keyof Tail]: Schema.Type<Tail[K]>;
        }
    ]> : ElementsType<Elements>;
    /**
     * @since 1.0.0
     */
    type Encoded<Elements extends TupleType.Elements, Rest extends ReadonlyArray<Schema.Any>> = Rest extends [infer Head, ...infer Tail] ? Readonly<[
        ...ElementsEncoded<Elements>,
        ...ReadonlyArray<Schema.Encoded<Head>>,
        ...{
            readonly [K in keyof Tail]: Schema.Encoded<Tail[K]>;
        }
    ]> : ElementsEncoded<Elements>;
}
/**
 * @category api interface
 * @since 1.0.0
 */
export interface TupleType<Elements extends TupleType.Elements, Rest extends ReadonlyArray<Schema.Any>> extends Schema<TupleType.Type<Elements, Rest>, TupleType.Encoded<Elements, Rest>, Schema.Context<Elements[number]> | Schema.Context<Rest[number]>> {
    readonly elements: Readonly<Elements>;
    readonly rest: Readonly<Rest>;
    annotations(annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>): TupleType<Elements, Rest>;
}
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {
    annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare function Tuple<const Elements extends TupleType.Elements, Rest extends array_.NonEmptyReadonlyArray<Schema.Any>>(elements: Elements, ...rest: Rest): TupleType<Elements, Rest>;
export declare function Tuple<Elements extends TupleType.Elements>(...elements: Elements): Tuple<Elements>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Array<Value extends Schema.Any> extends TupleType<[], [Value]> {
    readonly value: Value;
    annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): $Array<Value>;
}
declare const $Array: <Value extends Schema.Any>(value: Value) => $Array<Value>;
export { 
/**
 * @category constructors
 * @since 1.0.0
 */
$Array as Array };
/**
 * @category api interface
 * @since 1.0.0
 */
export interface NonEmptyArray<Value extends Schema.Any> extends TupleType<[Value], [Value]> {
    readonly value: Value;
    annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>): NonEmptyArray<Value>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const NonEmptyArray: <Value extends Schema.Any>(value: Value) => NonEmptyArray<Value>;
/**
 * @since 1.0.0
 */
export declare namespace PropertySignature {
    /**
     * @since 1.0.0
     */
    type Token = "?:" | ":";
    /**
     * @since 1.0.0
     */
    type GetToken<B extends boolean> = B extends true ? "?:" : ":";
    /**
     * @since 1.0.0
     */
    type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<Token, any, Key, Token, any, unknown>;
    /**
     * @since 1.0.0
     */
    type All<Key extends PropertyKey = PropertyKey> = Any<Key> | PropertySignature<Token, never, Key, Token, any, unknown> | PropertySignature<Token, any, Key, Token, never, unknown> | PropertySignature<Token, never, Key, Token, never, unknown>;
    /**
     * @since 1.0.0
     */
    type AST = PropertySignatureDeclaration | PropertySignatureTransformation;
    /**
     * @since 1.0.0
     */
    interface Annotations<A> extends Annotations.Doc<A> {
    }
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare class PropertySignatureDeclaration {
    readonly type: AST.AST;
    readonly isOptional: boolean;
    readonly isReadonly: boolean;
    readonly annotations: AST.Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "PropertySignatureDeclaration";
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations);
    /**
     * @since 1.0.0
     */
    toString(): string;
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare class FromPropertySignature implements AST.Annotated {
    readonly type: AST.AST;
    readonly isOptional: boolean;
    readonly isReadonly: boolean;
    readonly annotations: AST.Annotations;
    readonly fromKey?: PropertyKey | undefined;
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations, fromKey?: PropertyKey | undefined);
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare class ToPropertySignature implements AST.Annotated {
    readonly type: AST.AST;
    readonly isOptional: boolean;
    readonly isReadonly: boolean;
    readonly annotations: AST.Annotations;
    constructor(type: AST.AST, isOptional: boolean, isReadonly: boolean, annotations: AST.Annotations);
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare class PropertySignatureTransformation {
    readonly from: FromPropertySignature;
    readonly to: ToPropertySignature;
    readonly decode: AST.PropertySignatureTransformation["decode"];
    readonly encode: AST.PropertySignatureTransformation["encode"];
    /**
     * @since 1.0.0
     */
    readonly _tag = "PropertySignatureTransformation";
    constructor(from: FromPropertySignature, to: ToPropertySignature, decode: AST.PropertySignatureTransformation["decode"], encode: AST.PropertySignatureTransformation["encode"]);
    /**
     * @since 1.0.0
     */
    toString(): string;
}
/**
 * @since 1.0.0
 * @category symbol
 */
export declare const PropertySignatureTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type PropertySignatureTypeId = typeof PropertySignatureTypeId;
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export interface PropertySignature<TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R = never> extends Schema.Variance<Type, Encoded, R>, Pipeable {
    readonly [PropertySignatureTypeId]: null;
    readonly _EncodedToken: EncodedToken;
    readonly _TypeToken: TypeToken;
    readonly _Key: Key;
    readonly ast: PropertySignature.AST;
    annotations(annotations: PropertySignature.Annotations<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>;
}
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare const propertySignature: <A, I, R>(self: Schema<A, I, R>) => PropertySignature<PropertySignature.GetToken<false>, A, never, PropertySignature.GetToken<false>, I, R>;
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare const fromKey: {
    <Key extends PropertyKey>(key: Key): <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>;
    <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, R>;
};
/**
 * - `decode`: `none` as argument means: the value is missing in the input
 * - `encode`: `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
export declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: {
    readonly decode: (o: option_.Option<FA>) => TI;
    readonly encode: (ti: TI) => option_.Option<FA>;
}) => PropertySignature<":", TA, never, "?:", FI, FR | TR>;
/**
 * - `decode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 * - `encode`:
 *   - `none` as argument means: the value is missing in the input
 *   - `none` as return value means: the value will be missing in the output
 *
 * @category PropertySignature
 * @since 1.0.0
 */
export declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(from: Schema<FA, FI, FR>, to: Schema<TA, TI, TR>, options: {
    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>;
    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>;
}) => PropertySignature<"?:", TA, never, "?:", FI, FR | TR>;
/**
 * @category PropertySignature
 * @since 1.0.0
 */
export declare const optional: {
    <A, const Options extends {
        readonly default?: never;
        readonly as?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | {
        readonly default: () => A;
        readonly as?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | {
        readonly as: "Option";
        readonly default?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | undefined>(options?: Options): <I, R>(schema: Schema<A, I, R>) => [undefined] extends [Options] ? PropertySignature<"?:", A | undefined, never, "?:", I | undefined, R> : PropertySignature<Types.Has<Options, "as" | "default"> extends true ? ":" : "?:", (Types.Has<Options, "as"> extends true ? option_.Option<A> : A) | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined), never, "?:", I | (Types.Has<Options, "nullable"> extends true ? null : never) | (Types.Has<Options, "exact"> extends true ? never : undefined), R>;
    <A, I, R, const Options extends {
        readonly default?: never;
        readonly as?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | {
        readonly default: () => A;
        readonly as?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | {
        readonly as: "Option";
        readonly default?: never;
        readonly exact?: true;
        readonly nullable?: true;
    } | undefined>(schema: Schema<A, I, R>, options?: Options): [undefined] extends [Options] ? PropertySignature<"?:", A | undefined, never, "?:", I | undefined, R> : PropertySignature<Types.Has<Options, "as" | "default"> extends true ? ":" : "?:", (Types.Has<Options, "as"> extends true ? option_.Option<A> : A) | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined), never, "?:", I | (Types.Has<Options, "nullable"> extends true ? null : never) | (Types.Has<Options, "exact"> extends true ? never : undefined), R>;
};
/**
 * @since 1.0.0
 */
export declare namespace Struct {
    /**
     * @since 1.0.0
     */
    type Fields = {
        readonly [x: PropertyKey]: Schema.All | PropertySignature.All;
    };
    type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never : F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key : K;
    type EncodedTokenKeys<Fields extends Struct.Fields> = {
        [K in keyof Fields]: Fields[K] extends PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", any, unknown> | PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", never, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", any, unknown> | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", never, unknown> ? K : never;
    }[keyof Fields];
    type TypeTokenKeys<Fields extends Struct.Fields> = {
        [K in keyof Fields]: Fields[K] extends OptionalPropertySignature ? K : never;
    }[keyof Fields];
    type OptionalPropertySignature = PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, any, unknown> | PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, never, unknown> | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, any, unknown> | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, never, unknown>;
    /**
     * @since 1.0.0
     */
    type Type<F extends Fields> = Types.UnionToIntersection<{
        [K in keyof F]: F[K] extends OptionalPropertySignature ? {
            readonly [H in K]?: Schema.Type<F[H]>;
        } : {
            readonly [h in K]: Schema.Type<F[h]>;
        };
    }[keyof F]> extends infer Q ? Q : never;
    /**
     * @since 1.0.0
     */
    type Encoded<F extends Fields> = {
        readonly [K in Exclude<keyof F, EncodedTokenKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]>;
    } & {
        readonly [K in EncodedTokenKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]>;
    };
    /**
     * @since 1.0.0
     */
    type Context<F extends Fields> = Schema.Context<F[keyof F]>;
}
/**
 * @since 1.0.0
 */
export declare namespace IndexSignature {
    /**
     * @since 1.0.0
     */
    type Record = {
        readonly key: Schema.All;
        readonly value: Schema.All;
    };
    /**
     * @since 1.0.0
     */
    type Records = ReadonlyArray<Record>;
    /**
     * @since 1.0.0
     */
    type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>;
    /**
     * @since 1.0.0
     */
    type Type<Records extends IndexSignature.Records> = Types.UnionToIntersection<{
        [K in keyof Records]: {
            readonly [P in Schema.Type<Records[K]["key"]>]: Schema.Type<Records[K]["value"]>;
        };
    }[number]>;
    /**
     * @since 1.0.0
     */
    type Encoded<Records extends IndexSignature.Records> = Types.UnionToIntersection<{
        [K in keyof Records]: {
            readonly [P in Schema.Encoded<Records[K]["key"]>]: Schema.Encoded<Records[K]["value"]>;
        };
    }[number]>;
    /**
     * @since 1.0.0
     */
    type Context<Records extends IndexSignature.Records> = {
        [K in keyof Records]: Schema.Context<Records[K]["key"]> | Schema.Context<Records[K]["value"]>;
    }[number];
}
/**
 * @since 1.0.0
 */
export declare namespace TypeLiteral {
    /**
     * @since 1.0.0
     */
    type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> = Struct.Type<Fields> & IndexSignature.Type<Records>;
    /**
     * @since 1.0.0
     */
    type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> = Struct.Encoded<Fields> & IndexSignature.Encoded<Records>;
}
/**
 * @category api interface
 * @since 1.0.0
 */
export interface TypeLiteral<Fields extends Struct.Fields, Records extends IndexSignature.Records> extends Schema<Types.Simplify<TypeLiteral.Type<Fields, Records>>, Types.Simplify<TypeLiteral.Encoded<Fields, Records>>, Struct.Context<Fields> | IndexSignature.Context<Records>> {
    readonly fields: {
        readonly [K in keyof Fields]: Fields[K];
    };
    readonly records: Readonly<Records>;
    annotations(annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<Fields, Records>>>): TypeLiteral<Fields, Records>;
}
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Struct<Fields extends Struct.Fields> extends TypeLiteral<Fields, []> {
    annotations(annotations: Annotations.Schema<Types.Simplify<Struct.Type<Fields>>>): Struct<Fields>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare function Struct<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(fields: Fields, ...records: Records): TypeLiteral<Fields, Records>;
export declare function Struct<Fields extends Struct.Fields>(fields: Fields): Struct<Fields>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Record<K extends Schema.All, V extends Schema.All> extends TypeLiteral<{}, [{
    key: K;
    value: V;
}]> {
    readonly key: K;
    readonly value: V;
    annotations(annotations: Annotations.Schema<Types.Simplify<TypeLiteral.Type<{}, [{
        key: K;
        value: V;
    }]>>>): $Record<K, V>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const Record: <K extends Schema.All, V extends Schema.All>(key: K, value: V) => $Record<K, V>;
/**
 * @category struct transformations
 * @since 1.0.0
 */
export declare const pick: <A, I, Keys extends readonly (keyof A & keyof I)[]>(...keys: Keys) => <R>(self: Schema<A, I, R>) => Schema<Types.Simplify<Pick<A, Keys[number]>>, Types.Simplify<Pick<I, Keys[number]>>, R>;
/**
 * @category struct transformations
 * @since 1.0.0
 */
export declare const omit: <A, I, Keys extends readonly (keyof A & keyof I)[]>(...keys: Keys) => <R>(self: Schema<A, I, R>) => Schema<Types.Simplify<Omit<A, Keys[number]>>, Types.Simplify<Omit<I, Keys[number]>>, R>;
/**
 * Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
 * producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * // ---------------------------------------------
 * // use case: pull out a single field from a
 * // struct through a transformation
 * // ---------------------------------------------
 *
 * const mytable = S.Struct({
 *   column1: S.NumberFromString,
 *   column2: S.Number
 * })
 *
 * // const pullOutColumn: S.Schema<number, {
 * //     readonly column1: string;
 * // }, never>
 * const pullOutColumn = mytable.pipe(S.pluck("column1"))
 *
 * console.log(S.decodeUnknownEither(S.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
 * // Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
 *
 * @category struct transformations
 * @since 1.0.0
 */
export declare const pluck: {
    <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => Schema<A[K], {
        readonly [P in K]: I[P];
    }, R>;
    <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): Schema<A[K], {
        readonly [P in K]: I[P];
    }, R>;
};
/**
 * @category branding
 * @since 1.0.0
 */
export interface BrandSchema<A extends brand_.Brand<any>, I> extends Annotable<BrandSchema<A, I>, A, I>, brand_.Brand.Constructor<A> {
}
/**
 * @category api interface
 * @since 1.0.0
 */
export interface brand<S extends Schema.AnyNoContext, B extends string | symbol> extends BrandSchema<Schema.Type<S> & brand_.Brand<B>, Schema.Encoded<S>> {
    annotations(annotations: Annotations.Schema<Schema.Type<S> & brand_.Brand<B>>): brand<S, B>;
}
/**
 * @category branding
 * @since 1.0.0
 */
export declare const asBrandSchema: <A extends brand_.Brand<any>, I>(schema: BrandSchema<A, I>) => BrandSchema<A, I>;
/**
 * Returns a nominal branded schema by applying a brand to a given schema.
 *
 * ```
 * Schema<A> + B -> Schema<A & Brand<B>>
 * ```
 *
 * @param self - The input schema to be combined with the brand.
 * @param brand - The brand to apply.
 *
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
 * type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
 *
 * @category branding
 * @since 1.0.0
 */
export declare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & brand_.Brand<B>>) => (self: S) => brand<S, B>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const partial: {
    <const Options extends {
        readonly exact: true;
    } | undefined>(options?: Options): <A, I, R>(self: Schema<A, I, R>) => Schema<{
        [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never);
    }, {
        [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never);
    }, R>;
    <A, I, R, const Options extends {
        readonly exact: true;
    } | undefined>(self: Schema<A, I, R>, options?: Options): Schema<{
        [K in keyof A]?: A[K] | ([undefined] extends [Options] ? undefined : never);
    }, {
        [K in keyof I]?: I[K] | ([undefined] extends [Options] ? undefined : never);
    }, R>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const required: <A, I, R>(self: Schema<A, I, R>) => Schema<{ [K in keyof A]-?: A[K]; }, { [K_1 in keyof I]-?: I[K_1]; }, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface mutable<S extends Schema.Any> extends Annotable<mutable<S>, SimplifyMutable<Schema.Type<S>>, SimplifyMutable<Schema.Encoded<S>>, Schema.Context<S>> {
}
/**
 * Creates a new schema with shallow mutability applied to its properties.
 *
 * @param schema - The original schema to make properties mutable (shallowly).
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface extend<Self extends Schema.Any, That extends Schema.Any> extends Schema<Types.Simplify<Schema.Type<Self> & Schema.Type<That>>, Types.Simplify<Schema.Encoded<Self> & Schema.Encoded<That>>, Schema.Context<Self> | Schema.Context<That>> {
}
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const extend: {
    <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>;
    <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>;
};
/**
 * @category combinators
 * @since 1.0.0
 */
export declare const compose: {
    <D, C extends B, R2, B>(to: Schema<D, C, R2>): <A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>;
    <D, C, R2>(to: Schema<D, C, R2>): <B extends C, A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>;
    <C, B, R2>(to: Schema<C, B, R2>, options?: {
        readonly strict: true;
    }): <A, R1>(from: Schema<B, A, R1>) => Schema<C, A, R1 | R2>;
    <D, C, R2>(to: Schema<D, C, R2>, options: {
        readonly strict: false;
    }): <B, A, R1>(from: Schema<B, A, R1>) => Schema<D, A, R1 | R2>;
    <B, A, R1, D, C extends B, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): Schema<D, A, R1 | R2>;
    <B extends C, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): Schema<D, A, R1 | R2>;
    <B, A, R1, C, R2>(from: Schema<B, A, R1>, to: Schema<C, B, R2>, options?: {
        readonly strict: true;
    }): Schema<C, A, R1 | R2>;
    <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>, options: {
        readonly strict: false;
    }): Schema<D, A, R1 | R2>;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface suspend<A, I, R> extends Schema<A, I, R> {
    annotations(annotations: Annotations.Schema<A>): suspend<A, I, R>;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const suspend: <A, I, R>(f: () => Schema<A, I, R>) => suspend<A, I, R>;
/**
 * @category combinators
 * @since 1.0.0
 */
export declare function filter<A>(f: (a: A, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>, annotations?: Annotations.Filter<A>): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
export declare function filter<C extends A, B extends A, A = C>(refinement: Predicate.Refinement<A, B>, annotations?: Annotations.Filter<A>): <I, R>(self: Schema<C, I, R>) => Schema<C & B, I, R>;
export declare function filter<A>(predicate: Predicate.Predicate<Types.NoInfer<A>>, annotations?: Annotations.Filter<Types.NoInfer<A>>): <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface transformOrFail<From extends Schema.Any, To extends Schema.Any, R> extends Annotable<transformOrFail<From, To, R>, Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R> {
    readonly from: From;
    readonly to: To;
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided decoding functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const transformOrFail: {
    <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>;
        readonly strict: false;
    }): (from: From) => transformOrFail<From, To, RD | RE>;
    <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>;
        readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>;
        readonly strict: false;
    }): transformOrFail<From, To, RD | RE>;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface transform<From extends Schema.Any, To extends Schema.Any> extends transformOrFail<From, To, never> {
    annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>;
}
/**
 * Create a new `Schema` by transforming the input and output of an existing `Schema`
 * using the provided mapping functions.
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const transform: {
    <To extends Schema.Any, From extends Schema.Any>(to: To, options: {
        readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>;
        readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>) => unknown;
        readonly encode: (toI: Schema.Encoded<To>) => unknown;
        readonly strict: false;
    }): (from: From) => transform<From, To>;
    <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: {
        readonly decode: (fromA: Schema.Type<From>) => Schema.Encoded<To>;
        readonly encode: (toI: Schema.Encoded<To>) => Schema.Type<From>;
        readonly strict?: true;
    } | {
        readonly decode: (fromA: Schema.Type<From>) => unknown;
        readonly encode: (toI: Schema.Encoded<To>) => unknown;
        readonly strict: false;
    }): transform<From, To>;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface transformLiteral<Type, Encoded> extends Annotable<transformLiteral<Type, Encoded>, Type, Encoded> {
}
/**
 * Creates a new `Schema` which transforms literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const schema = S.transformLiteral(0, "a")
 *
 * assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>;
/**
 * Creates a new `Schema` which maps between corresponding literal values.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const Animal = S.transformLiterals(
 *   [0, "cat"],
 *   [1, "dog"],
 *   [2, "cow"]
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
 *
 * @category constructors
 * @since 1.0.0
 */
export declare function transformLiterals<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{
    -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>;
}>;
export declare function transformLiterals<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>;
export declare function transformLiterals<const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>;
/**
 * Attaches a property signature with the specified key and value to the schema.
 * This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
 * but rather maps to another schema, for example when you want to add a discriminant to a simple union.
 *
 * @param self - The input schema.
 * @param key - The name of the property to add to the schema.
 * @param value - The value of the property to add to the schema.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 * import { pipe } from "effect/Function"
 *
 * const Circle = S.Struct({ radius: S.Number })
 * const Square = S.Struct({ sideLength: S.Number })
 * const Shape = S.Union(
 *   Circle.pipe(S.attachPropertySignature("kind", "circle")),
 *   Square.pipe(S.attachPropertySignature("kind", "square"))
 * )
 *
 * assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
 *   kind: "circle",
 *   radius: 10
 * })
 *
 * @category combinators
 * @since 1.0.0
 */
export declare const attachPropertySignature: {
    <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(key: K, value: V, annotations?: Annotations.Schema<Types.Simplify<A & {
        readonly [k in K]: V;
    }>>): <I, R>(schema: Schema<A, I, R>) => Schema<Types.Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
    <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(schema: Schema<A, I, R>, key: K, value: V, annotations?: Annotations.Schema<Types.Simplify<A & {
        readonly [k in K]: V;
    }>>): Schema<Types.Simplify<A & {
        readonly [k in K]: V;
    }>, I, R>;
};
/**
 * @category annotations
 * @since 1.0.0
 */
export declare namespace Annotations {
    /**
     * @category annotations
     * @since 1.0.0
     */
    interface Doc<A> extends AST.Annotations {
        readonly title?: AST.TitleAnnotation;
        readonly description?: AST.DescriptionAnnotation;
        readonly documentation?: AST.DocumentationAnnotation;
        readonly examples?: AST.ExamplesAnnotation<A>;
        readonly default?: AST.DefaultAnnotation<A>;
    }
    /**
     * @since 1.0.0
     */
    interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {
        readonly identifier?: AST.IdentifierAnnotation;
        readonly message?: AST.MessageAnnotation;
        readonly typeId?: AST.TypeAnnotation | {
            id: AST.TypeAnnotation;
            annotation: unknown;
        };
        readonly jsonSchema?: AST.JSONSchemaAnnotation;
        readonly arbitrary?: (...arbitraries: {
            readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]>;
        }) => LazyArbitrary<A>;
        readonly pretty?: (...pretties: {
            readonly [K in keyof TypeParameters]: pretty_.Pretty<TypeParameters[K]>;
        }) => pretty_.Pretty<A>;
        readonly equivalence?: (...equivalences: {
            readonly [K in keyof TypeParameters]: Equivalence.Equivalence<TypeParameters[K]>;
        }) => Equivalence.Equivalence<A>;
        readonly concurrency?: AST.ConcurrencyAnnotation;
        readonly batching?: AST.BatchingAnnotation;
        readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation;
    }
    /**
     * @since 1.0.0
     */
    interface Filter<A> extends Schema<A, readonly [A]> {
    }
}
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const annotations: {
    <S extends Annotable.All>(annotations: Annotations.Schema<Schema.Type<S>>): (self: S) => Annotable.Self<S>;
    <S extends Annotable.All>(self: S, annotations: Annotations.Schema<Schema.Type<S>>): Annotable.Self<S>;
};
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const message: (message: AST.MessageAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const identifier: (identifier: AST.IdentifierAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const title: (title: AST.TitleAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const description: (description: AST.DescriptionAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const examples: <S extends Annotable.All>(examples: readonly [Schema.Type<S>, ...Schema.Type<S>[]]) => (self: S) => Annotable.Self<S>;
declare const $default: <S extends Annotable.All>(value: Schema.Type<S>) => (self: S) => Annotable.Self<S>;
export { 
/**
 * @category annotations
 * @since 1.0.0
 */
$default as default };
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const documentation: (documentation: AST.DocumentationAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * Attaches a JSON Schema annotation to a schema that represents a refinement.
 *
 * If the schema is composed of more than one refinement, the corresponding annotations will be merged.
 *
 * @category annotations
 * @since 1.0.0
 */
export declare const jsonSchema: (jsonSchema: AST.JSONSchemaAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const equivalence: <S extends Annotable.All>(equivalence: Equivalence.Equivalence<Schema.Type<S>>) => (self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const concurrency: (concurrency: AST.ConcurrencyAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const batching: (batching: AST.BatchingAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const parseIssueTitle: (f: AST.ParseIssueTitleAnnotation) => <S extends Annotable.All>(self: S) => Annotable.Self<S>;
type Rename<A, M> = {
    [K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K] : never : K]: A[K];
};
/**
 * @category renaming
 * @since 1.0.0
 */
export declare const rename: {
    <A, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(mapping: M): <I, R>(self: Schema<A, I, R>) => Schema<Types.Simplify<Rename<A, M>>, I, R>;
    <A, I, R, const M extends {
        readonly [K in keyof A]?: PropertyKey;
    } & {
        readonly [K in Exclude<keyof M, keyof A>]: never;
    }>(self: Schema<A, I, R>, mapping: M): Schema<Types.Simplify<Rename<A, M>>, I, R>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const TrimmedTypeId: unique symbol;
/**
 * Verifies that a string contains no leading or trailing whitespaces.
 *
 * Note. This combinator does not make any transformations, it only validates.
 * If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const trimmed: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MaxLengthTypeId = typeof MaxLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const maxLength: <A extends string>(maxLength: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinLengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MinLengthTypeId = typeof MinLengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const minLength: <A extends string>(minLength: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PatternTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const pattern: <A extends string>(regex: RegExp, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const StartsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const startsWith: <A extends string>(startsWith: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const EndsWithTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const endsWith: <A extends string>(endsWith: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IncludesTypeId: unique symbol;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const includes: <A extends string>(searchString: string, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LowercasedTypeId: unique symbol;
/**
 * Verifies that a string is lowercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const lowercased: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Lowercased: $String;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UppercasedTypeId: unique symbol;
/**
 * Verifies that a string is uppercased.
 *
 * @category string filters
 * @since 1.0.0
 */
export declare const uppercased: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Uppercased: $String;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LengthTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LengthTypeId = typeof LengthTypeId;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const length: <A extends string>(length: number | {
    readonly min: number;
    readonly max: number;
}, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * A schema representing a single character.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const Char: Schema<string, string, never>;
/**
 * @category string filters
 * @since 1.0.0
 */
export declare const nonEmpty: <A extends string>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Lowercase extends Annotable<Lowercase, string> {
}
/**
 * This schema converts a string to lowercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Lowercase: Lowercase;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Uppercase extends Annotable<Uppercase, string> {
}
/**
 * This schema converts a string to uppercase.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Uppercase: Uppercase;
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const Trimmed: $String;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Trim extends Annotable<Trim, string> {
}
/**
 * This schema allows removing whitespaces from the beginning and end of a string.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const Trim: Trim;
/**
 * Returns a schema that allows splitting a string into an array of strings.
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const split: (separator: string) => Schema<ReadonlyArray<string>, string>;
/**
 * @since 1.0.0
 */
export type ParseJsonOptions = {
    readonly reviver?: Parameters<typeof JSON.parse>[1];
    readonly replacer?: Parameters<typeof JSON.stringify>[1];
    readonly space?: Parameters<typeof JSON.stringify>[2];
};
/**
 * The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
 * functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.
 *
 * You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.
 *
 * Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson())(`{"a":"1"}`), { a: "1" })
 * assert.deepStrictEqual(S.decodeUnknownSync(S.parseJson(S.Struct({ a: S.NumberFromString })))(`{"a":"1"}`), { a: 1 })
 *
 * @category string transformations
 * @since 1.0.0
 */
export declare const parseJson: {
    <A, I, R>(schema: Schema<A, I, R>, options?: ParseJsonOptions): Schema<A, string, R>;
    (options?: ParseJsonOptions): Schema<unknown, string>;
};
/**
 * @category string constructors
 * @since 1.0.0
 */
export declare const NonEmpty: $String;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const UUIDTypeId: unique symbol;
/**
 * Represents a Universally Unique Identifier (UUID).
 *
 * This schema ensures that the provided string adheres to the standard UUID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const UUID: $String;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ULIDTypeId: unique symbol;
/**
 * Represents a Universally Unique Lexicographically Sortable Identifier (ULID).
 *
 * ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
 * This schema ensures that the provided string adheres to the standard ULID format.
 *
 * @category string constructors
 * @since 1.0.0
 */
export declare const ULID: $String;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const FiniteTypeId: unique symbol;
/**
 * Ensures that the provided value is a finite number.
 *
 * This schema filters out non-finite numeric values, allowing only finite numbers to pass through.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const finite: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanTypeId = typeof GreaterThanTypeId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const greaterThan: <A extends number>(min: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanOrEqualToTypeId = typeof GreaterThanOrEqualToTypeId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualTo: <A extends number>(min: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MultipleOfTypeId: unique symbol;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const multipleOf: <A extends number>(divisor: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const IntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type IntTypeId = typeof IntTypeId;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const int: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanTypeId = typeof LessThanTypeId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const lessThan: <A extends number>(max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanOrEqualToTypeId = typeof LessThanOrEqualToTypeId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualTo: <A extends number>(max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type BetweenTypeId = typeof BetweenTypeId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 1.0.0
 */
export declare const between: <A extends number>(min: number, max: number, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNaNTypeId: unique symbol;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonNaN: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const positive: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const negative: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonPositive: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category number filters
 * @since 1.0.0
 */
export declare const nonNegative: <A extends number>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a number between a minimum and a maximum value.
 *
 * @category number transformations
 * @since 1.0.0
 */
export declare const clamp: (minimum: number, maximum: number) => <R, I, A extends number>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface NumberFromString extends Annotable<NumberFromString, number, string> {
}
/**
 * This schema transforms a `string` into a `number` by parsing the string using the `Number` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * The following special string values are supported: "NaN", "Infinity", "-Infinity".
 *
 * @category number constructors
 * @since 1.0.0
 */
export declare const NumberFromString: NumberFromString;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Finite: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Int: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonNaN: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Positive: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const Negative: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonPositive: $Number;
/**
 * @category number constructors
 * @since 1.0.0
 */
export declare const NonNegative: $Number;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const JsonNumberTypeId: unique symbol;
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
 * format.
 *
 * @example
 * import * as S from "@effect/schema/Schema"
 *
 * const is = S.is(S.JsonNumber)
 *
 * assert.deepStrictEqual(is(42), true)
 * assert.deepStrictEqual(is(Number.NaN), false)
 * assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
 * assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
 *
 * @category number constructors
 * @since 1.0.0
 */
export declare const JsonNumber: $Number;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Not extends Annotable<Not, boolean> {
}
/**
 * @category boolean transformations
 * @since 1.0.0
 */
export declare const Not: Not;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Symbol extends Annotable<$Symbol, symbol, string> {
}
declare const $Symbol: $Symbol;
export { 
/**
 * This schema transforms a `string` into a `symbol`.
 *
 * @category symbol transformations
 * @since 1.0.0
 */
$Symbol as Symbol };
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanBigIntTypeId = typeof GreaterThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const greaterThanBigInt: <A extends bigint>(min: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type GreaterThanOrEqualToBigIntTypeId = typeof GreaterThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigInt: <A extends bigint>(min: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanBigIntTypeId = typeof LessThanBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const lessThanBigInt: <A extends bigint>(max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type LessThanOrEqualToBigIntTypeId = typeof LessThanOrEqualToBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigInt: <A extends bigint>(max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigIntTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type BetweenBigIntTypeId = typeof BetweenBigIntTypeId;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const betweenBigInt: <A extends bigint>(min: bigint, max: bigint, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const positiveBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const negativeBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const nonNegativeBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category bigint filters
 * @since 1.0.0
 */
export declare const nonPositiveBigInt: <A extends bigint>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a bigint between a minimum and a maximum value.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export declare const clampBigInt: (minimum: bigint, maximum: bigint) => <R, I, A extends bigint>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $BigInt extends Annotable<$BigInt, bigint, string> {
}
declare const bigint: $BigInt;
export { 
/**
 * This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.
 *
 * It returns an error if the value can't be converted (for example when non-numeric characters are provided).
 *
 * @category bigint transformations
 * @since 1.0.0
 */
bigint as BigInt };
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const PositiveBigIntFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const PositiveBigInt: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NegativeBigIntFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NegativeBigInt: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigIntFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigInt: Schema<bigint, string>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigIntFromSelf: Schema<bigint>;
/**
 * @category bigint constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigInt: Schema<bigint, string>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BigIntFromNumber extends Annotable<BigIntFromNumber, bigint, number> {
}
/**
 * This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.
 *
 * It returns an error if the value can't be safely encoded as a `number` due to being out of range.
 *
 * @category bigint transformations
 * @since 1.0.0
 */
export declare const BigIntFromNumber: BigIntFromNumber;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface SecretFromSelf extends Annotable<SecretFromSelf, secret_.Secret> {
}
/**
 * @category Secret constructors
 * @since 1.0.0
 */
export declare const SecretFromSelf: SecretFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Secret extends Annotable<Secret, secret_.Secret, string> {
}
/**
 * A schema that transforms a `string` into a `Secret`.
 *
 * @category Secret transformations
 * @since 1.0.0
 */
export declare const Secret: Secret;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface DurationFromSelf extends Annotable<DurationFromSelf, duration_.Duration> {
}
/**
 * @category Duration constructors
 * @since 1.0.0
 */
export declare const DurationFromSelf: DurationFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface DurationFromNanos extends Annotable<DurationFromNanos, duration_.Duration, bigint> {
}
/**
 * A schema that transforms a `bigint` tuple into a `Duration`.
 * Treats the value as the number of nanoseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const DurationFromNanos: DurationFromNanos;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface DurationFromMillis extends Annotable<DurationFromMillis, duration_.Duration, number> {
}
/**
 * A schema that transforms a `number` tuple into a `Duration`.
 * Treats the value as the number of milliseconds.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const DurationFromMillis: DurationFromMillis;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Duration extends Annotable<Duration, duration_.Duration, readonly [seconds: number, nanos: number]> {
}
/**
 * A schema that transforms a `[number, number]` tuple into a `Duration`.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const Duration: Duration;
/**
 * Clamps a `Duration` between a minimum and a maximum value.
 *
 * @category Duration transformations
 * @since 1.0.0
 */
export declare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <R, I, A extends duration_.Duration>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const lessThanDuration: <A extends duration_.Duration>(max: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToDuration: <A extends duration_.Duration>(max: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const greaterThanDuration: <A extends duration_.Duration>(min: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToDuration: <A extends duration_.Duration>(min: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenDurationTypeId: unique symbol;
/**
 * @category Duration filters
 * @since 1.0.0
 */
export declare const betweenDuration: <A extends duration_.Duration>(minimum: duration_.DurationInput, maximum: duration_.DurationInput, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category Uint8Array constructors
 * @since 1.0.0
 */
export declare const Uint8ArrayFromSelf: Schema<Uint8Array>;
declare const $Uint8Array: Schema<Uint8Array, ReadonlyArray<number>>;
export { 
/**
 * A schema that transforms a `number` array into a `Uint8Array`.
 *
 * @category Uint8Array transformations
 * @since 1.0.0
 */
$Uint8Array as Uint8Array };
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Base64: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Base64Url: Schema<Uint8Array, string>;
/**
 * @category Encoding transformations
 * @since 1.0.0
 */
export declare const Hex: Schema<Uint8Array, string>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MinItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MinItemsTypeId = typeof MinItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const minItems: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<ReadonlyArray<A>, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const MaxItemsTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type MaxItemsTypeId = typeof MaxItemsTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const maxItems: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<ReadonlyArray<A>, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ItemsCountTypeId: unique symbol;
/**
 * @category type id
 * @since 1.0.0
 */
export type ItemsCountTypeId = typeof ItemsCountTypeId;
/**
 * @category ReadonlyArray filters
 * @since 1.0.0
 */
export declare const itemsCount: <A>(n: number, annotations?: Annotations.Filter<ReadonlyArray<A>>) => <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<ReadonlyArray<A>, I, R>;
/**
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const getNumberIndexedAccess: <A extends readonly any[], I extends readonly any[], R>(self: Schema<A, I, R>) => Schema<A[number], I[number], R>;
/**
 * Get the first element of a `ReadonlyArray`, or `None` if the array is empty.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const head: <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<option_.Option<A>, I, R>;
/**
 * Retrieves the first element of a `ReadonlyArray`.
 *
 * If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.
 *
 * @category ReadonlyArray transformations
 * @since 1.0.0
 */
export declare const headOrElse: {
    <A>(fallback?: LazyArg<A>): <I, R>(self: Schema<ReadonlyArray<A>, I, R>) => Schema<A, I, R>;
    <A, I, R>(self: Schema<ReadonlyArray<A>, I, R>, fallback?: LazyArg<A>): Schema<A, I, R>;
};
/**
 * @category type id
 * @since 1.0.0
 */
export declare const ValidDateTypeId: unique symbol;
/**
 * A filter that **excludes invalid** dates (e.g., `new Date("Invalid Date")` is rejected).
 *
 * @category Date filters
 * @since 1.0.0
 */
export declare const validDate: (annotations?: Annotations.Filter<Date>) => <I, R>(self: Schema<Date, I, R>) => Schema<Date, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface DateFromSelf extends Annotable<DateFromSelf, Date> {
}
/**
 * Represents a schema for handling potentially **invalid** `Date` instances (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date constructors
 * @since 1.0.0
 */
export declare const DateFromSelf: DateFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ValidDateFromSelf extends Annotable<ValidDateFromSelf, Date> {
}
/**
 * Represents a schema for handling only **valid** dates. For example, `new Date("Invalid Date")` is rejected, even though it is an instance of `Date`.
 *
 * @category Date constructors
 * @since 1.0.0
 */
export declare const ValidDateFromSelf: ValidDateFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface DateFromString extends Annotable<DateFromString, Date, string> {
}
/**
 * Represents a schema that converts a `string` into a (potentially invalid) `Date` (e.g., `new Date("Invalid Date")` is not rejected).
 *
 * @category Date transformations
 * @since 1.0.0
 */
export declare const DateFromString: DateFromString;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Date extends Annotable<$Date, Date, string> {
}
declare const $Date: $Date;
export { 
/**
 * A schema that transforms a `string` into a **valid** `Date`, ensuring that invalid dates, such as `new Date("Invalid Date")`, are rejected.
 *
 * @category Date transformations
 * @since 1.0.0
 */
$Date as Date };
/**
 * @category Option utils
 * @since 1.0.0
 */
export type OptionEncoded<I> = {
    readonly _tag: "None";
} | {
    readonly _tag: "Some";
    readonly value: I;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface OptionFromSelf<Value extends Schema.Any> extends Annotable<OptionFromSelf<Value>, option_.Option<Schema.Type<Value>>, option_.Option<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const OptionFromSelf: <Value extends Schema.Any>(value: Value) => OptionFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Option<Value extends Schema.Any> extends Annotable<Option<Value>, option_.Option<Schema.Type<Value>>, OptionEncoded<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const Option: <Value extends Schema.Any>(value: Value) => Option<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface OptionFromNullOr<Value extends Schema.Any> extends Annotable<OptionFromNullOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | null, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const OptionFromNullOr: <Value extends Schema.Any>(value: Value) => OptionFromNullOr<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface OptionFromNullishOr<Value extends Schema.Any> extends Annotable<OptionFromNullishOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | null | undefined, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const OptionFromNullishOr: <Value extends Schema.Any>(value: Value, onNoneEncoding: null | undefined) => OptionFromNullishOr<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface OptionFromUndefinedOr<Value extends Schema.Any> extends Annotable<OptionFromUndefinedOr<Value>, option_.Option<Schema.Type<Value>>, Schema.Encoded<Value> | undefined, Schema.Context<Value>> {
}
/**
 * @category Option transformations
 * @since 1.0.0
 */
export declare const OptionFromUndefinedOr: <Value extends Schema.Any>(value: Value) => OptionFromUndefinedOr<Value>;
/**
 * @category Either utils
 * @since 1.0.0
 */
export type RightEncoded<IA> = {
    readonly _tag: "Right";
    readonly right: IA;
};
/**
 * @category Either utils
 * @since 1.0.0
 */
export type LeftEncoded<IE> = {
    readonly _tag: "Left";
    readonly left: IE;
};
/**
 * @category Either utils
 * @since 1.0.0
 */
export type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface EitherFromSelf<R extends Schema.Any, L extends Schema.Any> extends Annotable<EitherFromSelf<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @category Either transformations
 * @since 1.0.0
 */
export declare const EitherFromSelf: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => EitherFromSelf<R, L>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Either<R extends Schema.Any, L extends Schema.Any> extends Annotable<Either<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, EitherEncoded<Schema.Encoded<R>, Schema.Encoded<L>>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @category Either transformations
 * @since 1.0.0
 */
export declare const Either: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => Either<R, L>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface EitherFromUnion<R extends Schema.Any, L extends Schema.Any> extends Annotable<EitherFromUnion<R, L>, either_.Either<Schema.Type<R>, Schema.Type<L>>, Schema.Encoded<R> | Schema.Encoded<L>, Schema.Context<R> | Schema.Context<L>> {
}
/**
 * @example
 * import * as Schema from "@effect/schema/Schema"
 *
 * // Schema<string | number, Either<string, number>>
 * Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
 *
 * @category Either transformations
 * @since 1.0.0
 */
export declare const EitherFromUnion: <R extends Schema.Any, L extends Schema.Any>({ left, right }: {
    readonly left: L;
    readonly right: R;
}) => EitherFromUnion<R, L>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends Annotable<ReadonlyMapFromSelf<K, V>, ReadonlyMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category ReadonlyMap
 * @since 1.0.0
 */
export declare const ReadonlyMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => ReadonlyMapFromSelf<K, V>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends Annotable<MapFromSelf<K, V>, Map<Schema.Type<K>, Schema.Type<V>>, ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category Map
 * @since 1.0.0
 */
export declare const MapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => MapFromSelf<K, V>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $ReadonlyMap<K extends Schema.Any, V extends Schema.Any> extends Annotable<$ReadonlyMap<K, V>, ReadonlyMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category ReadonlyMap transformations
 * @since 1.0.0
 */
export declare const ReadonlyMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => $ReadonlyMap<K, V>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Map<K extends Schema.Any, V extends Schema.Any> extends Annotable<$Map<K, V>, Map<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
declare const map: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => $Map<K, V>;
export { 
/**
 * @category Map transformations
 * @since 1.0.0
 */
map as Map };
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ReadonlySetFromSelf<Value extends Schema.Any> extends Annotable<ReadonlySetFromSelf<Value>, ReadonlySet<Schema.Type<Value>>, ReadonlySet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category ReadonlySet
 * @since 1.0.0
 */
export declare const ReadonlySetFromSelf: <Value extends Schema.Any>(value: Value) => ReadonlySetFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface SetFromSelf<Value extends Schema.Any> extends Annotable<SetFromSelf<Value>, Set<Schema.Type<Value>>, ReadonlySet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Set
 * @since 1.0.0
 */
export declare const SetFromSelf: <Value extends Schema.Any>(value: Value) => SetFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $ReadonlySet<Value extends Schema.Any> extends Annotable<$ReadonlySet<Value>, ReadonlySet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category ReadonlySet transformations
 * @since 1.0.0
 */
export declare const ReadonlySet: <Value extends Schema.Any>(value: Value) => $ReadonlySet<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface $Set<Value extends Schema.Any> extends Annotable<$Set<Value>, Set<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
declare const set: <Value extends Schema.Any>(value: Value) => $Set<Value>;
export { 
/**
 * @category Set transformations
 * @since 1.0.0
 */
set as Set };
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BigDecimalFromSelf extends Annotable<BigDecimalFromSelf, bigDecimal_.BigDecimal> {
}
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const BigDecimalFromSelf: BigDecimalFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BigDecimal extends Annotable<BigDecimal, bigDecimal_.BigDecimal, string> {
}
/**
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const BigDecimal: BigDecimal;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BigDecimalFromNumber extends Annotable<BigDecimalFromNumber, bigDecimal_.BigDecimal, number> {
}
/**
 * A schema that transforms a `number` into a `BigDecimal`.
 * When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const BigDecimalFromNumber: BigDecimalFromNumber;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const greaterThanBigDecimal: <A extends bigDecimal_.BigDecimal>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const GreaterThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const greaterThanOrEqualToBigDecimal: <A extends bigDecimal_.BigDecimal>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const lessThanBigDecimal: <A extends bigDecimal_.BigDecimal>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const LessThanOrEqualToBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const lessThanOrEqualToBigDecimal: <A extends bigDecimal_.BigDecimal>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const PositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const positiveBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const PositiveBigDecimalFromSelf: Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonNegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const nonNegativeBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NonNegativeBigDecimalFromSelf: Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NegativeBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const negativeBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NegativeBigDecimalFromSelf: Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const NonPositiveBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const nonPositiveBigDecimal: <A extends bigDecimal_.BigDecimal>(annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category BigDecimal constructors
 * @since 1.0.0
 */
export declare const NonPositiveBigDecimalFromSelf: Schema<bigDecimal_.BigDecimal, bigDecimal_.BigDecimal, never>;
/**
 * @category type id
 * @since 1.0.0
 */
export declare const BetweenBigDecimalTypeId: unique symbol;
/**
 * @category BigDecimal filters
 * @since 1.0.0
 */
export declare const betweenBigDecimal: <A extends bigDecimal_.BigDecimal>(minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<A>) => <I, R>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * Clamps a `BigDecimal` between a minimum and a maximum value.
 *
 * @category BigDecimal transformations
 * @since 1.0.0
 */
export declare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <R, I, A extends bigDecimal_.BigDecimal>(self: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ChunkFromSelf<Value extends Schema.Any> extends Annotable<ChunkFromSelf<Value>, chunk_.Chunk<Schema.Type<Value>>, chunk_.Chunk<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export declare const ChunkFromSelf: <Value extends Schema.Any>(value: Value) => ChunkFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Chunk<Value extends Schema.Any> extends Annotable<Chunk<Value>, chunk_.Chunk<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category Chunk transformations
 * @since 1.0.0
 */
export declare const Chunk: <Value extends Schema.Any>(value: Value) => Chunk<Value>;
/**
 * @category Data transformations
 * @since 1.0.0
 */
export declare const DataFromSelf: <R, I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<A, I, R>) => Schema<A, I, R>;
/**
 * @category Data transformations
 * @since 1.0.0
 */
export declare const Data: <R, I extends readonly any[] | Readonly<Record<string, any>>, A extends readonly any[] | Readonly<Record<string, any>>>(item: Schema<A, I, R>) => Schema<A, I, R>;
type MissingSelfGeneric<Usage extends string, Params extends string = ""> = `Missing \`Self\` generic - use \`class Self extends ${Usage}<Self>()(${Params}{ ... })\``;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Class<Self, Fields extends Struct.Fields, A, I, R, C, Inherited, Proto> extends Schema<Self, I, R> {
    new (props: keyof C extends never ? void | {} : C, disableValidation?: boolean | undefined): A & Omit<Inherited, keyof A> & Proto;
    readonly fields: {
        readonly [K in keyof Fields]: Fields[K];
    };
    readonly identifier: string;
    readonly extend: <Extended = never>(identifier: string) => <newFields extends Struct.Fields>(fields: newFields, annotations?: Annotations.Schema<Extended>) => [Extended] extends [never] ? MissingSelfGeneric<"Base.extend"> : Class<Extended, Fields & newFields, Types.Simplify<A & Struct.Type<newFields>>, Types.Simplify<I & Struct.Encoded<newFields>>, R | Struct.Context<newFields>, Types.Simplify<C & Struct.Type<newFields>>, Self, Proto>;
    readonly transformOrFail: <Transformed = never>(identifier: string) => <newFields extends Struct.Fields, R2, R3>(fields: newFields, options: {
        readonly decode: (input: A, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Types.Simplify<A & Struct.Type<newFields>>, ParseResult.ParseIssue, R2>;
        readonly encode: (input: Types.Simplify<A & Struct.Type<newFields>>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<A, ParseResult.ParseIssue, R3>;
    }, annotations?: Annotations.Schema<Transformed>) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transform"> : Class<Transformed, Fields & newFields, Types.Simplify<A & Struct.Type<newFields>>, I, R | Struct.Context<newFields> | R2 | R3, Types.Simplify<C & Struct.Type<newFields>>, Self, Proto>;
    readonly transformOrFailFrom: <Transformed = never>(identifier: string) => <newFields extends Struct.Fields, R2, R3>(fields: newFields, options: {
        readonly decode: (input: I, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<Types.Simplify<I & Struct.Encoded<newFields>>, ParseResult.ParseIssue, R2>;
        readonly encode: (input: Types.Simplify<I & Struct.Encoded<newFields>>, options: ParseOptions, ast: AST.Transformation) => Effect.Effect<I, ParseResult.ParseIssue, R3>;
    }, annotations?: Annotations.Schema<Transformed>) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transformFrom"> : Class<Transformed, Fields & newFields, Types.Simplify<A & Struct.Type<newFields>>, I, R | Struct.Context<newFields> | R2 | R3, Types.Simplify<C & Struct.Type<newFields>>, Self, Proto>;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare const Class: <Self = never>(identifier: string) => <Fields extends Struct.Fields>(fields: Fields, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"Class"> : Class<Self, Fields, Types.Simplify<Struct.Type<Fields>>, Types.Simplify<Struct.Encoded<Fields>>, Struct.Context<Fields>, Types.Simplify<Struct.Type<Fields>>, {}, {}>;
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedClass: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fields: Fields, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedClass", `"Tag", `> : Class<Self, {
    readonly _tag: Literal<[Tag]>;
} & Fields, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Type<Fields>>, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Encoded<Fields>>, Struct.Context<Fields>, Types.Simplify<Struct.Type<Fields>>, {}, {}>;
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedError: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields>(tag: Tag, fields: Fields, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedError", `"Tag", `> : Class<Self, {
    readonly _tag: Literal<[Tag]>;
} & Fields, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Type<Fields>>, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Encoded<Fields>>, Struct.Context<Fields>, Types.Simplify<Struct.Type<Fields>>, {}, cause_.YieldableError>;
/**
 * @category classes
 * @since 1.0.0
 */
export interface TaggedRequest<Tag extends string, S, SI, SR, A, AI, E, EI, RR> extends Request.Request<A, E>, Serializable.SerializableWithResult<S, SI, SR, A, AI, E, EI, RR> {
    readonly _tag: Tag;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare namespace TaggedRequest {
    /**
     * @category classes
     * @since 1.0.0
     */
    type Any = TaggedRequest<string, any, any, any, any, any, any, any, any> | TaggedRequest<string, any, any, any, any, any, never, never, any>;
}
/**
 * @category classes
 * @since 1.0.0
 */
export declare const TaggedRequest: <Self = never>(identifier?: string) => <Tag extends string, Fields extends Struct.Fields, EA, EI, ER, AA, AI, AR>(tag: Tag, Failure: Schema<EA, EI, ER>, Success: Schema<AA, AI, AR>, fields: Fields, annotations?: Annotations.Schema<Self>) => [Self] extends [never] ? MissingSelfGeneric<"TaggedRequest", `"Tag", SuccessSchema, FailureSchema, `> : Class<Self, {
    readonly _tag: Literal<[Tag]>;
} & Fields, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Type<Fields>>, Types.Simplify<{
    readonly _tag: Tag;
} & Struct.Encoded<Fields>>, Struct.Context<Fields>, Types.Simplify<Struct.Type<Fields>>, TaggedRequest<Tag, Self, {
    readonly _tag: Tag;
} & Struct.Encoded<Fields>, Struct.Context<Fields>, AA, AI, EA, EI, ER | AR>, {}>;
/**
 * @category FiberId
 * @since 1.0.0
 */
export type FiberIdEncoded = {
    readonly _tag: "Composite";
    readonly left: FiberIdEncoded;
    readonly right: FiberIdEncoded;
} | {
    readonly _tag: "None";
} | {
    readonly _tag: "Runtime";
    readonly id: number;
    readonly startTimeMillis: number;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface FiberIdFromSelf extends Annotable<FiberIdFromSelf, fiberId_.FiberId> {
}
/**
 * @category FiberId constructors
 * @since 1.0.0
 */
export declare const FiberIdFromSelf: FiberIdFromSelf;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface FiberId extends Annotable<FiberId, fiberId_.FiberId, FiberIdEncoded> {
}
/**
 * @category FiberId transformations
 * @since 1.0.0
 */
export declare const FiberId: FiberId;
/**
 * @category Cause utils
 * @since 1.0.0
 */
export type CauseEncoded<E> = {
    readonly _tag: "Empty";
} | {
    readonly _tag: "Fail";
    readonly error: E;
} | {
    readonly _tag: "Die";
    readonly defect: unknown;
} | {
    readonly _tag: "Interrupt";
    readonly fiberId: FiberIdEncoded;
} | {
    readonly _tag: "Sequential";
    readonly left: CauseEncoded<E>;
    readonly right: CauseEncoded<E>;
} | {
    readonly _tag: "Parallel";
    readonly left: CauseEncoded<E>;
    readonly right: CauseEncoded<E>;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface CauseFromSelf<E extends Schema.Any, DR> extends Annotable<CauseFromSelf<E, DR>, cause_.Cause<Schema.Type<E>>, cause_.Cause<Schema.Encoded<E>>, Schema.Context<E> | DR> {
}
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export declare const CauseFromSelf: <E extends Schema.Any, DR = never>({ defect, error }: {
    readonly error: E;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => CauseFromSelf<E, DR>;
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export declare const CauseDefectUnknown: Unknown;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Cause<E extends Schema.All, DR> extends Annotable<Cause<E, DR>, cause_.Cause<Schema.Type<E>>, CauseEncoded<Schema.Encoded<E>>, Schema.Context<E> | DR> {
}
/**
 * @category Cause transformations
 * @since 1.0.0
 */
export declare const Cause: <E extends Schema.All, DR = never>({ defect, error }: {
    readonly error: E;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => Cause<E, DR>;
/**
 * @category Exit utils
 * @since 1.0.0
 */
export type ExitEncoded<A, E> = {
    readonly _tag: "Failure";
    readonly cause: CauseEncoded<E>;
} | {
    readonly _tag: "Success";
    readonly value: A;
};
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ExitFromSelf<A extends Schema.Any, E extends Schema.Any, DR> extends Annotable<ExitFromSelf<A, E, DR>, exit_.Exit<Schema.Type<A>, Schema.Type<E>>, exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>, Schema.Context<A> | Schema.Context<E> | DR> {
}
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export declare const ExitFromSelf: <A extends Schema.Any, E extends Schema.Any, DR = never>({ defect, failure, success }: {
    readonly failure: E;
    readonly success: A;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => ExitFromSelf<A, E, DR>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface Exit<A extends Schema.All, E extends Schema.All, DR> extends Annotable<Exit<A, E, DR>, exit_.Exit<Schema.Type<A>, Schema.Type<E>>, ExitEncoded<Schema.Encoded<A>, Schema.Encoded<E>>, Schema.Context<A> | Schema.Context<E> | DR> {
}
/**
 * @category Exit transformations
 * @since 1.0.0
 */
export declare const Exit: <A extends Schema.All, E extends Schema.All, DR = never>({ defect, failure, success }: {
    readonly failure: E;
    readonly success: A;
    readonly defect?: Schema<unknown, unknown, DR> | undefined;
}) => Exit<A, E, DR>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface HashSetFromSelf<Value extends Schema.Any> extends Annotable<HashSetFromSelf<Value>, hashSet_.HashSet<Schema.Type<Value>>, hashSet_.HashSet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export declare const HashSetFromSelf: <Value extends Schema.Any>(value: Value) => HashSetFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface HashSet<Value extends Schema.Any> extends Annotable<HashSet<Value>, hashSet_.HashSet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category HashSet transformations
 * @since 1.0.0
 */
export declare const HashSet: <Value extends Schema.Any>(value: Value) => HashSet<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends Annotable<HashMapFromSelf<K, V>, hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>, hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export declare const HashMapFromSelf: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => HashMapFromSelf<K, V>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface HashMap<K extends Schema.Any, V extends Schema.Any> extends Annotable<HashMap<K, V>, hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>, ReadonlyArray<readonly [Schema.Encoded<K>, Schema.Encoded<V>]>, Schema.Context<K> | Schema.Context<V>> {
}
/**
 * @category HashMap transformations
 * @since 1.0.0
 */
export declare const HashMap: <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
    readonly key: K;
    readonly value: V;
}) => HashMap<K, V>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface ListFromSelf<Value extends Schema.Any> extends Annotable<ListFromSelf<Value>, list_.List<Schema.Type<Value>>, list_.List<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category List transformations
 * @since 1.0.0
 */
export declare const ListFromSelf: <Value extends Schema.Any>(value: Value) => ListFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface List<Value extends Schema.Any> extends Annotable<List<Value>, list_.List<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category List transformations
 * @since 1.0.0
 */
export declare const List: <Value extends Schema.Any>(value: Value) => List<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface SortedSetFromSelf<Value extends Schema.Any> extends Annotable<SortedSetFromSelf<Value>, sortedSet_.SortedSet<Schema.Type<Value>>, sortedSet_.SortedSet<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
export declare const SortedSetFromSelf: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>, ordI: Order.Order<Schema.Encoded<Value>>) => SortedSetFromSelf<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface SortedSet<Value extends Schema.Any> extends Annotable<SortedSet<Value>, sortedSet_.SortedSet<Schema.Type<Value>>, ReadonlyArray<Schema.Encoded<Value>>, Schema.Context<Value>> {
}
/**
 * @category SortedSet transformations
 * @since 1.0.0
 */
export declare const SortedSet: <Value extends Schema.Any>(value: Value, ordA: Order.Order<Schema.Type<Value>>) => SortedSet<Value>;
/**
 * @category api interface
 * @since 1.0.0
 */
export interface BooleanFromUnknown extends Annotable<BooleanFromUnknown, boolean, unknown> {
}
/**
 * Converts an arbitrary value to a `boolean` by testing whether it is truthy.
 * Uses `!!val` to coerce the value to a `boolean`.
 *
 * @see https://developer.mozilla.org/docs/Glossary/Truthy
 * @category boolean constructors
 * @since 1.0.0
 */
export declare const BooleanFromUnknown: BooleanFromUnknown;
//# sourceMappingURL=Schema.d.ts.map