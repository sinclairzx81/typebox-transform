/**
 * @since 1.0.0
 */
import * as Arr from "effect/Array";
import type { Effect } from "effect/Effect";
import * as Option from "effect/Option";
import type { Concurrency } from "effect/Types";
import type { ParseIssue } from "./ParseResult.js";
/**
 * @category model
 * @since 1.0.0
 */
export type AST = Declaration | Literal | UniqueSymbol | UndefinedKeyword | VoidKeyword | NeverKeyword | UnknownKeyword | AnyKeyword | StringKeyword | NumberKeyword | BooleanKeyword | BigIntKeyword | SymbolKeyword | ObjectKeyword | Enums | TemplateLiteral | Refinement | TupleType | TypeLiteral | Union | Suspend | Transformation;
/**
 * @category annotations
 * @since 1.0.0
 */
export type BrandAnnotation = Arr.NonEmptyReadonlyArray<string | symbol>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const BrandAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type TypeAnnotation = symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const TypeAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type MessageAnnotation = (issue: ParseIssue) => string | Effect<string>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const MessageAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type IdentifierAnnotation = string;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const IdentifierAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type TitleAnnotation = string;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const TitleAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type DescriptionAnnotation = string;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const DescriptionAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type ExamplesAnnotation<A> = Arr.NonEmptyReadonlyArray<A>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const ExamplesAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type DefaultAnnotation<A> = A;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const DefaultAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type JSONSchemaAnnotation = object;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const JSONSchemaAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type DocumentationAnnotation = string;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const DocumentationAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type ConcurrencyAnnotation = Concurrency | undefined;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const ConcurrencyAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type BatchingAnnotation = boolean | "inherit" | undefined;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const BatchingAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export type ParseIssueTitleAnnotation = (issue: ParseIssue) => string | undefined;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const ParseIssueTitleAnnotationId: unique symbol;
/**
 * @category annotations
 * @since 1.0.0
 */
export interface Annotations {
    readonly [_: symbol]: unknown;
}
/**
 * @category annotations
 * @since 1.0.0
 */
export interface Annotated {
    readonly annotations: Annotations;
}
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getAnnotation: {
    <A>(key: symbol): (annotated: Annotated) => Option.Option<A>;
    <A>(annotated: Annotated, key: symbol): Option.Option<A>;
};
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getBrandAnnotation: (annotated: Annotated) => Option.Option<readonly [string | symbol, ...(string | symbol)[]]>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getMessageAnnotation: (annotated: Annotated) => Option.Option<MessageAnnotation>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getTitleAnnotation: (annotated: Annotated) => Option.Option<string>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getIdentifierAnnotation: (annotated: Annotated) => Option.Option<string>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getDescriptionAnnotation: (annotated: Annotated) => Option.Option<string>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getExamplesAnnotation: (annotated: Annotated) => Option.Option<readonly [unknown, ...unknown[]]>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getDefaultAnnotation: (annotated: Annotated) => Option.Option<unknown>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getJSONSchemaAnnotation: (annotated: Annotated) => Option.Option<object>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getDocumentationAnnotation: (annotated: Annotated) => Option.Option<string>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getConcurrencyAnnotation: (annotated: Annotated) => Option.Option<ConcurrencyAnnotation>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getBatchingAnnotation: (annotated: Annotated) => Option.Option<BatchingAnnotation>;
/**
 * @category annotations
 * @since 1.0.0
 */
export declare const getParseIssueTitleAnnotation: (annotated: Annotated) => Option.Option<ParseIssueTitleAnnotation>;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Declaration implements Annotated {
    readonly typeParameters: ReadonlyArray<AST>;
    readonly decodeUnknown: (...typeParameters: ReadonlyArray<AST>) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>;
    readonly encodeUnknown: (...typeParameters: ReadonlyArray<AST>) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Declaration";
    constructor(typeParameters: ReadonlyArray<AST>, decodeUnknown: (...typeParameters: ReadonlyArray<AST>) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>, encodeUnknown: (...typeParameters: ReadonlyArray<AST>) => (input: unknown, options: ParseOptions, self: Declaration) => Effect<any, ParseIssue, any>, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isDeclaration: (ast: AST) => ast is Declaration;
/**
 * @category model
 * @since 1.0.0
 */
export type LiteralValue = string | number | boolean | null | bigint;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Literal implements Annotated {
    readonly literal: LiteralValue;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Literal";
    constructor(literal: LiteralValue, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isLiteral: (ast: AST) => ast is Literal;
declare const $null: Literal;
export { 
/**
 * @category constructors
 * @since 1.0.0
 */
$null as null };
/**
 * @category model
 * @since 1.0.0
 */
export declare class UniqueSymbol implements Annotated {
    readonly symbol: symbol;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "UniqueSymbol";
    constructor(symbol: symbol, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isUniqueSymbol: (ast: AST) => ast is UniqueSymbol;
/**
 * @category model
 * @since 1.0.0
 */
export declare class UndefinedKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "UndefinedKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const undefinedKeyword: UndefinedKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isUndefinedKeyword: (ast: AST) => ast is UndefinedKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class VoidKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "VoidKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const voidKeyword: VoidKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isVoidKeyword: (ast: AST) => ast is VoidKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class NeverKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "NeverKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const neverKeyword: NeverKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isNeverKeyword: (ast: AST) => ast is NeverKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class UnknownKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "UnknownKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const unknownKeyword: UnknownKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isUnknownKeyword: (ast: AST) => ast is UnknownKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class AnyKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "AnyKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const anyKeyword: AnyKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isAnyKeyword: (ast: AST) => ast is AnyKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class StringKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "StringKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const stringKeyword: StringKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isStringKeyword: (ast: AST) => ast is StringKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class NumberKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "NumberKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const numberKeyword: NumberKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isNumberKeyword: (ast: AST) => ast is NumberKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class BooleanKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "BooleanKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const booleanKeyword: BooleanKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isBooleanKeyword: (ast: AST) => ast is BooleanKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class BigIntKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "BigIntKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const bigIntKeyword: BigIntKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isBigIntKeyword: (ast: AST) => ast is BigIntKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class SymbolKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "SymbolKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const symbolKeyword: SymbolKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isSymbolKeyword: (ast: AST) => ast is SymbolKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class ObjectKeyword implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "ObjectKeyword";
    constructor(annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const objectKeyword: ObjectKeyword;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isObjectKeyword: (ast: AST) => ast is ObjectKeyword;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Enums implements Annotated {
    readonly enums: ReadonlyArray<readonly [string, string | number]>;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Enums";
    constructor(enums: ReadonlyArray<readonly [string, string | number]>, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isEnums: (ast: AST) => ast is Enums;
/**
 * @category model
 * @since 1.0.0
 */
export declare class TemplateLiteralSpan {
    readonly type: StringKeyword | NumberKeyword;
    readonly literal: string;
    constructor(type: StringKeyword | NumberKeyword, literal: string);
    /**
     * @since 1.0.0
     */
    toString(): "${string}" | "${number}";
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category model
 * @since 1.0.0
 */
export declare class TemplateLiteral implements Annotated {
    readonly head: string;
    readonly spans: Arr.NonEmptyReadonlyArray<TemplateLiteralSpan>;
    readonly annotations: Annotations;
    static make: (head: string, spans: ReadonlyArray<TemplateLiteralSpan>, annotations?: Annotations) => TemplateLiteral | Literal;
    /**
     * @since 1.0.0
     */
    readonly _tag = "TemplateLiteral";
    private constructor();
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isTemplateLiteral: (ast: AST) => ast is TemplateLiteral;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Element {
    readonly type: AST;
    readonly isOptional: boolean;
    constructor(type: AST, isOptional: boolean);
    /**
     * @since 1.0.0
     */
    toJSON(): object;
    /**
     * @since 1.0.0
     */
    toString(): string;
}
/**
 * @category model
 * @since 1.0.0
 */
export declare class TupleType implements Annotated {
    readonly elements: ReadonlyArray<Element>;
    readonly rest: ReadonlyArray<AST>;
    readonly isReadonly: boolean;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "TupleType";
    constructor(elements: ReadonlyArray<Element>, rest: ReadonlyArray<AST>, isReadonly: boolean, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isTupleType: (ast: AST) => ast is TupleType;
/**
 * @category model
 * @since 1.0.0
 */
export declare class PropertySignature implements Annotated {
    readonly name: PropertyKey;
    readonly type: AST;
    readonly isOptional: boolean;
    readonly isReadonly: boolean;
    readonly annotations: Annotations;
    constructor(name: PropertyKey, type: AST, isOptional: boolean, isReadonly: boolean, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @since 1.0.0
 */
export type Parameter = StringKeyword | SymbolKeyword | TemplateLiteral | Refinement<Parameter>;
/**
 * @since 1.0.0
 */
export declare const isParameter: (ast: AST) => ast is Parameter;
/**
 * @category model
 * @since 1.0.0
 */
export declare class IndexSignature {
    readonly type: AST;
    readonly isReadonly: boolean;
    /**
     * @since 1.0.0
     */
    readonly parameter: Parameter;
    constructor(parameter: AST, type: AST, isReadonly: boolean);
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category model
 * @since 1.0.0
 */
export declare class TypeLiteral implements Annotated {
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "TypeLiteral";
    /**
     * @since 1.0.0
     */
    readonly propertySignatures: ReadonlyArray<PropertySignature>;
    /**
     * @since 1.0.0
     */
    readonly indexSignatures: ReadonlyArray<IndexSignature>;
    constructor(propertySignatures: ReadonlyArray<PropertySignature>, indexSignatures: ReadonlyArray<IndexSignature>, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isTypeLiteral: (ast: AST) => ast is TypeLiteral;
/**
 * @since 1.0.0
 */
export type Members<A> = readonly [A, A, ...Array<A>];
/**
 * @category model
 * @since 1.0.0
 */
export declare class Union implements Annotated {
    readonly types: Members<AST>;
    readonly annotations: Annotations;
    static make: (candidates: ReadonlyArray<AST>, annotations?: Annotations) => AST;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Union";
    private constructor();
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isUnion: (ast: AST) => ast is Union;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Suspend implements Annotated {
    readonly f: () => AST;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Suspend";
    constructor(f: () => AST, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isSuspend: (ast: AST) => ast is Suspend;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Refinement<From extends AST = AST> implements Annotated {
    readonly from: From;
    readonly filter: (input: any, options: ParseOptions, self: Refinement) => Option.Option<ParseIssue>;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Refinement";
    constructor(from: From, filter: (input: any, options: ParseOptions, self: Refinement) => Option.Option<ParseIssue>, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isRefinement: (ast: AST) => ast is Refinement<AST>;
/**
 * @category model
 * @since 1.0.0
 */
export interface ParseOptions {
    /** default "first" */
    readonly errors?: "first" | "all" | undefined;
    /** default "ignore" */
    readonly onExcessProperty?: "ignore" | "error" | "preserve" | undefined;
}
/**
 * @since 1.0.0
 */
export declare const defaultParseOption: ParseOptions;
/**
 * @category model
 * @since 1.0.0
 */
export declare class Transformation implements Annotated {
    readonly from: AST;
    readonly to: AST;
    readonly transformation: TransformationKind;
    readonly annotations: Annotations;
    /**
     * @since 1.0.0
     */
    readonly _tag = "Transformation";
    constructor(from: AST, to: AST, transformation: TransformationKind, annotations?: Annotations);
    /**
     * @since 1.0.0
     */
    toString(verbose?: boolean): string;
    /**
     * @since 1.0.0
     */
    toJSON(): object;
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isTransformation: (ast: AST) => ast is Transformation;
/**
 * @category model
 * @since 1.0.0
 */
export type TransformationKind = FinalTransformation | ComposeTransformation | TypeLiteralTransformation;
/**
 * @category model
 * @since 1.0.0
 */
export declare class FinalTransformation {
    readonly decode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>;
    readonly encode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>;
    /**
     * @since 1.0.0
     */
    readonly _tag = "FinalTransformation";
    constructor(decode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>, encode: (input: any, options: ParseOptions, self: Transformation) => Effect<any, ParseIssue, any>);
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isFinalTransformation: (ast: TransformationKind) => ast is FinalTransformation;
/**
 * @category model
 * @since 1.0.0
 */
export declare class ComposeTransformation {
    /**
     * @since 1.0.0
     */
    readonly _tag = "ComposeTransformation";
}
/**
 * @category constructors
 * @since 1.0.0
 */
export declare const composeTransformation: ComposeTransformation;
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isComposeTransformation: (ast: TransformationKind) => ast is ComposeTransformation;
/**
 * Represents a `PropertySignature -> PropertySignature` transformation
 *
 * The semantic of `decode` is:
 * - `none()` represents the absence of the key/value pair
 * - `some(value)` represents the presence of the key/value pair
 *
 * The semantic of `encode` is:
 * - `none()` you don't want to output the key/value pair
 * - `some(value)` you want to output the key/value pair
 *
 * @category model
 * @since 1.0.0
 */
export declare class PropertySignatureTransformation {
    readonly from: PropertyKey;
    readonly to: PropertyKey;
    readonly decode: (o: Option.Option<any>) => Option.Option<any>;
    readonly encode: (o: Option.Option<any>) => Option.Option<any>;
    constructor(from: PropertyKey, to: PropertyKey, decode: (o: Option.Option<any>) => Option.Option<any>, encode: (o: Option.Option<any>) => Option.Option<any>);
}
/**
 * @category model
 * @since 1.0.0
 */
export declare class TypeLiteralTransformation {
    readonly propertySignatureTransformations: ReadonlyArray<PropertySignatureTransformation>;
    /**
     * @since 1.0.0
     */
    readonly _tag = "TypeLiteralTransformation";
    constructor(propertySignatureTransformations: ReadonlyArray<PropertySignatureTransformation>);
}
/**
 * @category guards
 * @since 1.0.0
 */
export declare const isTypeLiteralTransformation: (ast: TransformationKind) => ast is TypeLiteralTransformation;
/**
 * Adds a group of annotations, potentially overwriting existing annotations.
 *
 * @since 1.0.0
 */
export declare const annotations: (ast: AST, annotations: Annotations) => AST;
/**
 * Equivalent at runtime to the TypeScript type-level `keyof` operator.
 *
 * @since 1.0.0
 */
export declare const keyof: (ast: AST) => AST;
/**
 * @since 1.0.0
 */
export declare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp;
/**
 * @since 1.0.0
 */
export declare const getPropertySignatures: (ast: AST) => Array<PropertySignature>;
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Pick`.
 *
 * @since 1.0.0
 */
export declare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation;
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Omit`.
 *
 * @since 1.0.0
 */
export declare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation;
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Partial`.
 *
 * @since 1.0.0
 */
export declare const partial: (ast: AST, options?: {
    readonly exact: true;
}) => AST;
/**
 * Equivalent at runtime to the built-in TypeScript utility type `Required`.
 *
 * @since 1.0.0
 */
export declare const required: (ast: AST) => AST;
/**
 * Creates a new AST with shallow mutability applied to its properties.
 *
 * @param ast - The original AST to make properties mutable (shallowly).
 *
 * @since 1.0.0
 */
export declare const mutable: (ast: AST) => AST;
/**
 * @since 1.0.0
 */
export type Compiler<A> = (ast: AST) => A;
/**
 * @since 1.0.0
 */
export type Match<A> = {
    [K in AST["_tag"]]: (ast: Extract<AST, {
        _tag: K;
    }>, compile: Compiler<A>) => A;
};
/**
 * @since 1.0.0
 */
export declare const getCompiler: <A>(match: Match<A>) => Compiler<A>;
/**
 * @since 1.0.0
 */
export declare const typeAST: (ast: AST) => AST;
/**
 * @since 1.0.0
 */
export declare const encodedAST: (ast: AST) => AST;
/**
 * @since 1.0.0
 */
export declare const hash: (ast: AST) => number;
//# sourceMappingURL=AST.d.ts.map